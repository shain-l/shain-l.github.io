{"meta":{"title":"shain","subtitle":"缘来是你","description":null,"author":"~鑫~","url":"http://shain.top","root":"/"},"pages":[{"title":"标签","date":"2019-07-12T06:03:03.000Z","updated":"2020-08-26T11:26:46.537Z","comments":true,"path":"tags/index.html","permalink":"http://shain.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-12T06:01:59.000Z","updated":"2020-08-26T11:26:36.180Z","comments":true,"path":"categories/index.html","permalink":"http://shain.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-26T12:28:37.000Z","updated":"2020-09-14T11:57:59.286Z","comments":true,"path":"about/index.html","permalink":"http://shain.top/about/index.html","excerpt":"","text":""}],"posts":[{"title":"OSPF综合实验二","slug":"OSPF综合实验二","date":"2020-11-17T02:16:51.000Z","updated":"2020-11-17T02:31:01.291Z","comments":true,"path":"2020/11/17/OSPF综合实验二/","link":"","permalink":"http://shain.top/2020/11/17/OSPF%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E4%BA%8C/","excerpt":"","text":"一、实验目的（1）理解和掌握OSPF stub区域的特点和配置 （2）理解和掌握OSPF totally stub区域的特点和配置 （3）理解和掌握OSPF NSSA区域的特点和配置 （4）理解和掌握OSPF totally NSSA区域的特点和配置 （5）掌握被动接口的作用 （6）掌握OSPF LSA7的作用 （7）掌握OSPF邻居间的验证 二、实验拓扑 三、实验步骤1、参考拓扑，完成各路由器的基本配置，除图示地址标识外，设备间的地址自己规划 在各路由器的相应接口配置IP地址 12345678910111213141516171819202122//此处以路由器R1为例，配置R1上各接口的IP地址R1(config)#int s1/0R1(config-if)#ip address 12.12.12.1 255.255.255.0R1(config-if)#no shutdown R1(config)#int s1/1R1(config-if)#ip address 13.13.13.1 255.255.255.0R1(config)#int loopback 1R1(config-if)#ip address 11.1.1.1 255.255.255.0R1(config)#int loopback 2R1(config-if)#ip address 11.1.2.1 255.255.255.0R1(config)#int loopback 3R1(config-if)#ip address 11.1.3.1 255.255.255.0R1(config)#int loopback 4R1(config-if)#ip address 11.1.4.1 255.255.255.0R1(config)#int loopback 5R1(config-if)#ip address 11.1.5.1 255.255.255.0R1(config)#int loopback 6R1(config-if)#ip address 11.1.6.1 255.255.255.0R1(config)#int loopback 7R1(config-if)#ip address 11.1.7.1 255.255.255.0R1(config)#int loopback 8R1(config-if)#ip address 11.1.8.1 255.255.255.0 2、完成各路由协议的基本配置，在R2上进行OSPF与RIPv2的双向重分布，在R6上进行EIGRP与OSPF的双向重分布，然后完成必要的配置，实现全网可达，并且在OSPF区域内的各个路由器上手工指定各路由器的RID为各路由器的编号 在相应路由器上进行OSPF的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354R1(config)#router ospf 1R1(config-router)#router-id 1.1.1.1R1(config-router)#network 12.12.12.0 0.0.0.255 area 123R1(config-router)#network 13.13.13.0 0.0.0.255 area 123R1(config)#int range lo1-8R1(config-if-range)#ip ospf 1 area 123R2(config)#router ospf 1R2(config-router)#router-id 2.2.2.2R2(config-router)#network 12.12.12.0 0.0.0.255 area 123R2(config-router)#network 12.1.1.0 0.0.0.255 area 123R2(config-router)#network 12.1.2.0 0.0.0.255 area 123R2(config-router)#network 25.25.25.0 0.0.0.255 area 0R3(config)#router ospf 1R3(config-router)#router-id 3.3.3.3R3(config-router)#network 13.13.13.0 0.0.0.255 area 123R3(config-router)#network 13.1.1.0 0.0.0.255 area 123R3(config-router)#network 13.1.2.0 0.0.0.255 area 123R3(config-router)#network 34.34.34.0 0.0.0.255 area 0R4(config)#router ospf 1R4(config-router)#router-id 4.4.4.4R4(config-router)#network 34.34.34.0 0.0.0.255 area 0R4(config-router)#network 14.1.1.0 0.0.0.255 area 0R4(config-router)#network 14.1.2.0 0.0.0.255 area 0R4(config-router)#network 47.47.47.0 0.0.0.255 area 4567R5(config)#router ospf 1R5(config-router)#router-id 5.5.5.5R5(config-router)#network 25.25.25.0 0.0.0.255 area 0R5(config-router)#network 15.1.1.0 0.0.0.255 area 0R5(config-router)#network 15.1.2.0 0.0.0.255 area 0R5(config-router)#network 56.56.56.0 0.0.0.255 area 4567R6(config)#router ospf 1R6(config-router)#router-id 6.6.6.6R6(config-router)#network 56.56.56.0 0.0.0.255 area 4567R6(config-router)#network 67.67.67.0 0.0.0.255 area 4567R6(config-router)#network 16.1.1.0 0.0.0.255 area 4567R6(config-router)#network 16.1.2.0 0.0.0.255 area 4567R7(config)#router ospf 1R7(config-router)#rouR7(config-router)#router-id 7.7.7.7R7(config-router)#network 47.47.47.0 0.0.0.255 areR7(config-router)#network 67.67.67.0 0.0.0.255 area 4567R7(config-router)#network 78.78.78.0 0.0.0.255 area 78R8(config)#router ospf 1R8(config-router)#router-id 8.8.8.8R8(config-router)#network 78.78.78.0 0.0.0.255 area 78R8(config-router)#network 18.1.1.0 0.0.0.255 area 78R8(config-router)#network 18.1.2.0 0.0.0.255 area 78 在R2和R9上配置RIPv2，并在R2上执行重分布 12345678910111213141516R9(config)#router ripR9(config-router)#version 2R9(config-router)#no auto-summary R9(config-router)#network 19.1.1.0 R9(config-router)#network 19.1.2.0R9(config-router)#network 29.29.29.0R2(config)#router ripR2(config-router)#version 2R2(config-router)#no auto-summary R2(config-router)#network 29.29.29.0//将OSPF路由重分布进RIPR2(config-router)#redistribute ospf 1 metric 2R2(config)#router ospf 1//将RIP路由重分布进OSPF，默认的metric为20，类型为O E2，并且在传递过程中保持metric为20不变R2(config-router)#redistribute rip subnets 在R6和R10上配置EIGRP，并在R6上执行重分布 1234567891011121314R10(config)#router eigrp 90R10(config-router)#no auto-summary R10(config-router)#network 106.106.106.0 0.0.0.255R10(config-router)#network 192.168.1.0 0.0.0.255R10(config-router)#network 192.168.2.0 0.0.0.255R6(config)#router eigrp 90R6(config-router)#no auto-summary R6(config-router)#network 106.106.106.0 0.0.0.255//将OSPF路由重分布进EIGRPR6(config-router)#redistribute ospf 1 metric 10000 1 1 1 1R6(config)#router ospf 1//将EIGRP路由重分布进OSPFR6(config-router)#redistribute eigrp 90 subnets 由于区域78没有与骨干区域相连，所以在R4和R7、R5和R7上配置隧道 123456789101112131415161718192021222324252627282930313233//进入隧道接口R4(config)#int tunnel 47//指定隧道源地址R4(config-if)#tunnel source 47.47.47.4 //指定隧道目的地址R4(config-if)#tunnel destination 47.47.47.7 //配置隧道的IP地址R4(config-if)#ip address 172.16.47.4 255.255.255.0R4(config-if)#no shutdown //将隧道接口加入OSPFR4(config-if)#ip ospf 1 area 0R5(config)#int tunnel 57R5(config-if)#tunnel source 56.56.56.5 R5(config-if)#tunnel destination 67.67.67.7R5(config-if)#ip address 172.16.57.5 255.255.255.0R5(config-if)#no shutdownR5(config-if)#ip ospf 1 area 0R7(config)#int tunnel 47R7(config-if)#tunnel source 47.47.47.7R7(config-if)#tunnel destination 47.47.47.4R7(config-if)#ip address 172.16.47.7 255.255.255.0R7(config-if)#no shutdown R7(config-if)#ip ospf 1 area 0*Nov 16 12:54:24.285: %OSPF-5-ADJCHG: Process 1, Nbr 4.4.4.4 on Tunnel47 from LOADING to FULL, Loading DoneR7(config)#int tunnel 57R7(config-if)#tunnel source 67.67.67.7 R7(config-if)#tunnel destination 56.56.56.5R7(config-if)#ip address 172.16.57.7 255.255.255.0R7(config-if)#no shutdown R7(config-if)#ip ospf 1 area 0*Nov 16 12:54:58.398: %OSPF-5-ADJCHG: Process 1, Nbr 5.5.5.5 on Tunnel57 from LOADING to FULL, Loading Done 查看R8的路由表，此时已经学习到全网的路由 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950R8#show ip route ospf&lt;省略部分输出&gt; 11.0.0.0/32 is subnetted, 8 subnetsO IA 11.1.1.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0O IA 11.1.2.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0O IA 11.1.3.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0O IA 11.1.4.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0O IA 11.1.5.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0O IA 11.1.6.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0O IA 11.1.7.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0O IA 11.1.8.1 [110/1139] via 78.78.78.7, 00:02:29, Serial1/0 12.0.0.0/8 is variably subnetted, 3 subnets, 2 masksO IA 12.1.1.1/32 [110/1075] via 78.78.78.7, 00:01:55, Serial1/0O IA 12.1.2.1/32 [110/1075] via 78.78.78.7, 00:01:55, Serial1/0O IA 12.12.12.0/24 [110/1138] via 78.78.78.7, 00:01:55, Serial1/0 13.0.0.0/8 is variably subnetted, 3 subnets, 2 masksO IA 13.1.1.1/32 [110/1075] via 78.78.78.7, 00:02:29, Serial1/0O IA 13.1.2.1/32 [110/1075] via 78.78.78.7, 00:02:29, Serial1/0O IA 13.13.13.0/24 [110/1138] via 78.78.78.7, 00:02:29, Serial1/0 14.0.0.0/32 is subnetted, 2 subnetsO IA 14.1.1.1 [110/1065] via 78.78.78.7, 00:02:29, Serial1/0O IA 14.1.2.1 [110/1065] via 78.78.78.7, 00:02:29, Serial1/0 15.0.0.0/32 is subnetted, 2 subnetsO IA 15.1.1.1 [110/1065] via 78.78.78.7, 00:01:55, Serial1/0O IA 15.1.2.1 [110/1065] via 78.78.78.7, 00:01:55, Serial1/0 16.0.0.0/32 is subnetted, 2 subnetsO IA 16.1.1.1 [110/75] via 78.78.78.7, 00:02:29, Serial1/0O IA 16.1.2.1 [110/75] via 78.78.78.7, 00:02:29, Serial1/0 19.0.0.0/24 is subnetted, 2 subnetsO E2 19.1.1.0 [110/20] via 78.78.78.7, 00:02:19, Serial1/0O E2 19.1.2.0 [110/20] via 78.78.78.7, 00:02:19, Serial1/0 25.0.0.0/24 is subnetted, 1 subnetsO IA 25.25.25.0 [110/1074] via 78.78.78.7, 00:01:55, Serial1/0 29.0.0.0/24 is subnetted, 1 subnetsO E2 29.29.29.0 [110/20] via 78.78.78.7, 00:02:19, Serial1/0 34.0.0.0/24 is subnetted, 1 subnetsO IA 34.34.34.0 [110/1074] via 78.78.78.7, 00:02:29, Serial1/0 47.0.0.0/24 is subnetted, 1 subnetsO IA 47.47.47.0 [110/74] via 78.78.78.7, 00:02:29, Serial1/0 56.0.0.0/24 is subnetted, 1 subnetsO IA 56.56.56.0 [110/84] via 78.78.78.7, 00:02:29, Serial1/0 67.0.0.0/24 is subnetted, 1 subnetsO IA 67.67.67.0 [110/74] via 78.78.78.7, 00:02:29, Serial1/0 106.0.0.0/24 is subnetted, 1 subnetsO E2 106.106.106.0 [110/20] via 78.78.78.7, 00:02:29, Serial1/0 172.16.0.0/24 is subnetted, 2 subnetsO IA 172.16.47.0 [110/1064] via 78.78.78.7, 00:02:29, Serial1/0O IA 172.16.57.0 [110/1064] via 78.78.78.7, 00:01:55, Serial1/0O E2 192.168.1.0/24 [110/20] via 78.78.78.7, 00:02:29, Serial1/0O E2 192.168.2.0/24 [110/20] via 78.78.78.7, 00:02:29, Serial1/0 测试连通性 使用R9的loopback接口 ping R8上的loopback接口 使用R1的loopback接口 ping R10上的loopback接口 3、在R1上，采用合适的方式将相应的接口设置为passive-interface 通过将某个接口设置为被动接口，则该接口不会接收OSPF报文，也不会发送OSPF报文 123456R1(config)#router ospf 1//在进程下将所有接口设为被动接口R1(config-router)#passive-interface default //取消s1/0和s1/1的被动接口设置R1(config-router)#no passive-interface s1/0R1(config-router)#no passive-interface s1/1 4、在R1与R2的链路之间使用链路明文认证，密码为”cisco”，并使用wireshark抓包观察认证信息 在R1与R2上配置明文认证 12345678//在R1的s1/0接口开启OSPF明文认证，密码为ciscoR1(config)#int s1/0R1(config-if)#ip ospf authentication R1(config-if)#ip ospf authentication-key cisco//在R2的s1/0接口开启OSPF明文认证，密码为ciscoR2(config)#int s1/0R2(config-if)#ip ospf authenticationR2(config-if)#ip ospf authentication-key cisco 使用wireshark抓包，报文如下图所示 由于使用明文认证，则可以使用抓包工具获取到进行认证的密码 5、在R1与R3的链路之间使用链路MD5认证，密码为”shain”，并使用wireshark抓包观察认证信息 在R1与R3上配置密文认证 123456789R1(config)#int s1/1//指定认证方式为密文认证R1(config-if)#ip ospf authentication message-digest //指定密文认证的密码R1(config-if)#ip ospf message-digest-key 1 md5 shainR3(config)#int s1/1R3(config-if)#ip ospf authentication message-digest R3(config-if)#ip ospf message-digest-key 1 md5 shain 使用wireshark抓包，报文如下图所示 由于使用了密文认证，此时无法通过抓包工具获取到认证的密码 6、在area4567上使用区域间的MD5认证，密码自定 123456789101112131415R4(config)#int e0/1R4(config-if)#ip ospf authentication message-digest R4(config-if)#ip ospf message-digest-key 1 md5 shainR5(config)#int e0/1R5(config-if)#ip ospf authentication message-digest R5(config-if)#ip ospf message-digest-key 1 md5 shainR6(config)#int range e0/0-1R6(config-if-range)#ip ospf authentication message-digest R6(config-if-range)#ip ospf message-digest-key 1 md5 shainR7(config)#int range e0/0-1R7(config-if-range)#ip ospf authentication message-digest R7(config-if-range)#ip ospf message-digest-key 1 md5 shain 7、在骨干区域上采用区域间的明文认证，密码自定 123456789101112131415R2(config)#int e0/0R2(config-if)#ip ospf authenticationR2(config-if)#ip ospf authentication-key shain R3(config)#int e0/0R3(config-if)#ip ospf authenticationR3(config-if)#ip ospf authentication-key shainR4(config)#int e0/0R4(config-if)#ip ospf authenticationR4(config-if)#ip ospf authentication-key shainR5(config)#int e0/0R5(config-if)#ip ospf authenticationR5(config-if)#ip ospf authentication-key shain 8、仔细观察各区域路由器的路由表，观察各OSPF路由器LSDB数据库的信息，重点观察各OSPF路由器存在哪些类型的LSA信息 此处以R1为例 查看R1的路由表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869R1#show ip route &lt;省略部分输出&gt; 11.0.0.0/8 is variably subnetted, 16 subnets, 2 masksC 11.1.1.0/24 is directly connected, Loopback1L 11.1.1.1/32 is directly connected, Loopback1C 11.1.2.0/24 is directly connected, Loopback2L 11.1.2.1/32 is directly connected, Loopback2C 11.1.3.0/24 is directly connected, Loopback3L 11.1.3.1/32 is directly connected, Loopback3C 11.1.4.0/24 is directly connected, Loopback4L 11.1.4.1/32 is directly connected, Loopback4C 11.1.5.0/24 is directly connected, Loopback5L 11.1.5.1/32 is directly connected, Loopback5C 11.1.6.0/24 is directly connected, Loopback6L 11.1.6.1/32 is directly connected, Loopback6C 11.1.7.0/24 is directly connected, Loopback7L 11.1.7.1/32 is directly connected, Loopback7C 11.1.8.0/24 is directly connected, Loopback8L 11.1.8.1/32 is directly connected, Loopback8 12.0.0.0/8 is variably subnetted, 4 subnets, 2 masksO 12.1.1.1/32 [110/65] via 12.12.12.2, 00:37:21, Serial1/0O 12.1.2.1/32 [110/65] via 12.12.12.2, 00:37:21, Serial1/0C 12.12.12.0/24 is directly connected, Serial1/0L 12.12.12.1/32 is directly connected, Serial1/0 13.0.0.0/8 is variably subnetted, 4 subnets, 2 masksO 13.1.1.1/32 [110/65] via 13.13.13.3, 00:37:21, Serial1/1O 13.1.2.1/32 [110/65] via 13.13.13.3, 00:37:21, Serial1/1C 13.13.13.0/24 is directly connected, Serial1/1L 13.13.13.1/32 is directly connected, Serial1/1 14.0.0.0/32 is subnetted, 2 subnetsO IA 14.1.1.1 [110/75] via 13.13.13.3, 00:37:21, Serial1/1O IA 14.1.2.1 [110/75] via 13.13.13.3, 00:37:21, Serial1/1 15.0.0.0/32 is subnetted, 2 subnetsO IA 15.1.1.1 [110/75] via 12.12.12.2, 00:13:12, Serial1/0O IA 15.1.2.1 [110/75] via 12.12.12.2, 00:13:12, Serial1/0 16.0.0.0/32 is subnetted, 2 subnetsO IA 16.1.1.1 [110/85] via 12.12.12.2, 00:13:12, Serial1/0O IA 16.1.2.1 [110/85] via 12.12.12.2, 00:13:12, Serial1/0 18.0.0.0/32 is subnetted, 2 subnetsO IA 18.1.1.1 [110/1139] via 13.13.13.3, 00:37:21, Serial1/1 [110/1139] via 12.12.12.2, 00:13:12, Serial1/0O IA 18.1.2.1 [110/1139] via 13.13.13.3, 00:37:21, Serial1/1 [110/1139] via 12.12.12.2, 00:13:12, Serial1/0 19.0.0.0/24 is subnetted, 2 subnetsO E2 19.1.1.0 [110/20] via 12.12.12.2, 00:37:21, Serial1/0O E2 19.1.2.0 [110/20] via 12.12.12.2, 00:37:21, Serial1/0 25.0.0.0/24 is subnetted, 1 subnetsO IA 25.25.25.0 [110/74] via 12.12.12.2, 00:37:21, Serial1/0 29.0.0.0/24 is subnetted, 1 subnetsO E2 29.29.29.0 [110/20] via 12.12.12.2, 00:37:21, Serial1/0 34.0.0.0/24 is subnetted, 1 subnetsO IA 34.34.34.0 [110/74] via 13.13.13.3, 00:37:21, Serial1/1 47.0.0.0/24 is subnetted, 1 subnetsO IA 47.47.47.0 [110/84] via 13.13.13.3, 00:37:21, Serial1/1 56.0.0.0/24 is subnetted, 1 subnetsO IA 56.56.56.0 [110/84] via 12.12.12.2, 00:13:12, Serial1/0 67.0.0.0/24 is subnetted, 1 subnetsO IA 67.67.67.0 [110/94] via 13.13.13.3, 00:18:29, Serial1/1 [110/94] via 12.12.12.2, 00:13:12, Serial1/0 78.0.0.0/24 is subnetted, 1 subnetsO IA 78.78.78.0 [110/1138] via 13.13.13.3, 00:37:21, Serial1/1 [110/1138] via 12.12.12.2, 00:13:12, Serial1/0 106.0.0.0/24 is subnetted, 1 subnetsO E2 106.106.106.0 [110/20] via 12.12.12.2, 00:13:07, Serial1/0 172.16.0.0/24 is subnetted, 2 subnetsO IA 172.16.47.0 [110/1074] via 13.13.13.3, 00:37:21, Serial1/1O IA 172.16.57.0 [110/1074] via 12.12.12.2, 00:13:12, Serial1/0O E2 192.168.1.0/24 [110/20] via 12.12.12.2, 00:13:07, Serial1/0O E2 192.168.2.0/24 [110/20] via 12.12.12.2, 00:13:07, Serial1/0 查看R1的拓扑表。存在类型1、类型3、类型4、类型5的LSA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263R1#show ip ospf database OSPF Router with ID (1.1.1.1) (Process ID 1) Router Link States (Area 123)Link ID ADV Router Age Seq# Checksum Link count1.1.1.1 1.1.1.1 533 0x8000000E 0x006EC0 122.2.2.2 2.2.2.2 1490 0x8000000B 0x00BC3B 43.3.3.3 3.3.3.3 1392 0x8000000A 0x009D4C 4 Summary Net Link States (Area 123)Link ID ADV Router Age Seq# Checksum14.1.1.1 2.2.2.2 895 0x80000001 0x004BF514.1.1.1 3.3.3.3 1392 0x80000007 0x00B95514.1.2.1 2.2.2.2 895 0x80000001 0x0040FF14.1.2.1 3.3.3.3 1392 0x80000007 0x00AE5F15.1.1.1 2.2.2.2 895 0x80000001 0x00D64115.1.1.1 3.3.3.3 1160 0x80000001 0x00201C15.1.2.1 2.2.2.2 896 0x80000001 0x00CB4B15.1.2.1 3.3.3.3 1160 0x80000001 0x00152616.1.1.1 2.2.2.2 895 0x80000001 0x002EDE16.1.1.1 3.3.3.3 1213 0x80000008 0x00669116.1.2.1 2.2.2.2 895 0x80000001 0x0023E816.1.2.1 3.3.3.3 1213 0x80000008 0x005B9B18.1.1.1 2.2.2.2 895 0x80000001 0x00658318.1.1.1 3.3.3.3 392 0x80000006 0x003DA218.1.2.1 2.2.2.2 895 0x80000001 0x005A8D18.1.2.1 3.3.3.3 392 0x80000006 0x0032AC25.25.25.0 2.2.2.2 1490 0x80000007 0x001EBB25.25.25.0 3.3.3.3 1160 0x80000001 0x00D72234.34.34.0 2.2.2.2 895 0x80000001 0x00B03234.34.34.0 3.3.3.3 1392 0x80000007 0x00BAFF47.47.47.0 2.2.2.2 895 0x80000001 0x003C4347.47.47.0 3.3.3.3 1392 0x80000007 0x00494056.56.56.0 2.2.2.2 895 0x80000001 0x002E4A56.56.56.0 3.3.3.3 1213 0x80000008 0x00CA8E67.67.67.0 2.2.2.2 895 0x80000001 0x00054867.67.67.0 3.3.3.3 1213 0x80000008 0x00D86978.78.78.0 2.2.2.2 895 0x80000001 0x0064AF78.78.78.0 3.3.3.3 392 0x80000006 0x003CCE172.16.47.0 2.2.2.2 895 0x80000001 0x008CDA172.16.47.0 3.3.3.3 392 0x80000006 0x003119172.16.57.0 2.2.2.2 895 0x80000001 0x00EA5E172.16.57.0 3.3.3.3 392 0x80000006 0x00F55E Summary ASB Link States (Area 123)Link ID ADV Router Age Seq# Checksum2.2.2.2 3.3.3.3 892 0x80000001 0x00F4476.6.6.6 2.2.2.2 895 0x80000001 0x00F2156.6.6.6 3.3.3.3 1136 0x8000000C 0x0023CB Type-5 AS External Link StatesLink ID ADV Router Age Seq# Checksum Tag19.1.1.0 2.2.2.2 1490 0x80000006 0x0092EB 019.1.2.0 2.2.2.2 1490 0x80000006 0x0087F5 029.29.29.0 2.2.2.2 1490 0x80000006 0x0089B2 0106.106.106.0 6.6.6.6 968 0x80000006 0x003212 0192.168.1.0 6.6.6.6 968 0x80000006 0x006CAC 0192.168.2.0 6.6.6.6 967 0x80000006 0x0061B6 0 9、将area 123设置为stub区域，然后观察R1上的OSPF数据库和R1路由条目的变化，并测试R1与其他区域的连通性 查看R1上的数据库摘要信息 总共有44条LSA。其中类型1有3条，类型3有32条，类型4有3条，类型5有6条 将区域123设置为stub区域 12345678R1(config)#router ospf 1R1(config-router)#area 123 stub R2(config)#router ospf 1R2(config-router)#area 123 stubR3(config)#router ospf 1R3(config-router)#area 123 stub 再次查看R1的数据库摘要 由于将区域123设置为stub区域，所以R2、R3会将类型4和类型5的LSA过滤，并下发三类的默认路由 此时总共有37条LSA。其中类型1有3条，类型3有34条 R2和R3分别向区域123下发了一条类型3的默认路由 10、将area 123设置为totally stub区域，再次观察R1上的OSPF数据库和路由条目的变化，并测试R1与其他区域的连通性 在ABR上进行配置 12345R2(config)#router ospf 1R2(config-router)#area 123 stub no-summary R3(config)#router ospf 1R3(config-router)#area 123 stub no-summary 查看R1的OSPF数据库的摘要信息 由于将区域123配置成了完全末梢区域，所以R2、R3会在末梢区域的基础上，在将类型3的LSA进行过滤 此时，总共有5条LSA。其中类型1有3条，类型3有2条 11、将area 4567设置为NSSA区域，再次观察各路由条目的变化，完成必要的配置，实现全网可达 将区域4567设置为NSSA 1234567891011R4(config)#router ospf 1R4(config-router)#area 4567 nssaR5(config)#router ospf 1R5(config-router)#area 4567 nssaR6(config)#router ospf 1R6(config-router)#area 4567 nssaR7(config)#router ospf 1R7(config-router)#area 4567 nssa 由于配置成NSSA，所以类型4、类型5的LSA将被过滤，并且不会下发三类默认路由 在R6上进行ping测试 R4、R5下发默认路由 12345R4(config)#router ospf 1 R4(config-router)#area 4567 nssa default-information-originate R5(config)#router ospf 1 R5(config-router)#area 4567 nssa default-information-originate 查看R6的数据库，由R4和R5下发的默认路由将以类型7的LSA存在 此时R6可以正常访问外部网络 12、将area 4567设置为totally NSSA区域，再次观察各路由条目的变化，完成必要的配置，实现全网可达 在R4和R5上将区域4567配置成totally NSSA区域 12345R4(config)#router ospf 1 R4(config-router)#area 4567 nssa no-summary R5(config)#router ospf 1R5(config-router)#area 4567 nssa no-summary 此时R4和R5将会下发三类默认路由 在R6上进行ping测试","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"}]},{"title":"OSPF综合实验一","slug":"OSPF综合实验一","date":"2020-11-15T14:06:42.000Z","updated":"2020-11-15T14:34:17.822Z","comments":true,"path":"2020/11/15/OSPF综合实验一/","link":"","permalink":"http://shain.top/2020/11/15/OSPF%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E4%B8%80/","excerpt":"","text":"一、实验目的（1）熟悉OSPF的基本配置 （2）熟悉OSPF网络类型的应用 （3）理解不连续区域的网络环境及不连续区域对OSPF路由选择的影响 （4）掌握OSPF不连续区域的几种解决方案 （5）掌握OSPF区域间和外部路由的汇总 （6）掌握OSPF默认路由的配置及控制 二、实验拓扑 三、实验步骤1、完成各路由器的基本配置，除图示地址标识外，设备间的地址自己规划，并分别在路由器R1、R2、R3、R5和R6上各起一个loopback接口，地址为各路由器的编号，如R1的loopback地址为1.1.1.1，其他以此类推 123456789101112131415161718192021//参照R1的配置，在各路由器接口配置相应的IP地址R1(config)#int e0/0R1(config-if)#ip address 12.12.12.1 255.255.255.0R1(config-if)#no shutdown R1(config-if)#int e0/1R1(config-if)#ip address 16.16.16.1 255.255.255.0R1(config-if)#no shutdownR1(config-if)#int s1/0R1(config-if)#ip address 200.100.100.1 255.255.255.0R1(config-if)#no shutdown//在R1、R2、R3、R5和R6上各起一个loopback接口R1(config)#int lo1R1(config-if)#ip address 1.1.1.1 255.255.255.0R2(config)#int lo1R2(config-if)#ip address 2.2.2.2 255.255.255.0R3(config)#int lo1R3(config-if)#ip address 3.3.3.3 255.255.255.0R5(config)#int lo1R5(config-if)#ip add 5.5.5.5 255.255.255.0R6(config)#int lo1R6(config-if)#ip address 6.6.6.6 255.255.255.0 2、除ISP区域外，全网启用OSPF，并设置各路由器的RID为各路由器的编号，根据图示将各网段划分进相应的OSPF区域中，要求在R5上采用接口级命令将R5相应的接口加入到OSPF区域中，在其他路由器上采用合适的方式启用OSPF，并在R2上进行EIGRP和OSPF的双向重分布 全网启用OSPF 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//R1上进行OSPF配置R1(config)#router ospf 1R1(config-router)#router-id 1.1.1.1R1(config-router)#network 12.12.12.0 0.0.0.255 area 0R1(config-router)#network 16.16.16.0 0.0.0.255 area 0R1(config-router)#network 1.1.1.0 0.0.0.255 area 0//R2上进行OSPF配置R2(config)#router ospf 1R2(config-router)#router-id 2.2.2.2R2(config-router)#network 12.12.12.0 0.0.0.255 area 0R2(config-router)#network 23.23.23.0 0.0.0.255 area 0R2(config-router)#network 2.2.2.0 0.0.0.255 area 0//R3上进行OSPF配置R3(config)#router ospf 1R3(config-router)#router-id 3.3.3.3R3(config-router)#network 23.23.23.0 0.0.0.255 area 0R3(config-router)#network 34.34.34.0 0.0.0.255 area 345R3(config-router)#network 3.3.3.0 0.0.0.255 area 0//R4上进行OSPF配置R4(config)#router ospf 1R4(config-router)#router-id 4.4.4.4R4(config-router)#network 34.34.34.0 0.0.0.255 area 345R4(config-router)#network 45.45.45.0 0.0.0.255 area 345R4(config-router)#network 192.168.1.0 0.0.0.255 area 345R4(config-router)#network 192.168.2.0 0.0.0.255 area 345R4(config-router)#network 192.168.3.0 0.0.0.255 area 345R4(config-router)#network 192.168.4.0 0.0.0.255 area 345//R5上进行OSPF配置R5(config)#router ospf 1R5(config-router)#router-id 5.5.5.5R5(config)#int e0/1 R5(config-if)#ip ospf 1 area 0R5(config-if)#int e0/0R5(config-if)#ip ospf 1 area 345R5(config-if)#int e0/2R5(config-if)#ip ospf 1 area 578R5(config-if)#int lo1R5(config-if)#ip ospf 1 area 0//R6上进行OSPF配置R6(config)#router ospf 1R6(config-router)#router-id 6.6.6.6R6(config-router)#network 16.16.16.0 0.0.0.255 area 0R6(config-router)#network 56.56.56.0 0.0.0.255 area 0R6(config-router)#network 6.6.6.0 0.0.0.255 area 0//R7上进行OSPF配置R7(config)#router ospf 1R7(config-router)#router-id 7.7.7.7R7(config)#int range e0/0,lo1-4R7(config-if-range)#ip ospf 1 area 578//R8上进行OSPF配置R8(config)#router ospf 1R8(config-router)#router-id 8.8.8.8R8(config)#int range e0/0,lo1-4R8(config-if-range)#ip ospf 1 area 578 在R9和R2上进行EIGRP的配置，并在R2上进行重分布 1234567891011121314R9(config)#router eigrp 110R9(config-router)#no auto-summary R9(config-router)#network 29.29.29.0 0.0.0.255R9(config-router)#network 172.16.1.0 0.0.0.255R9(config-router)#network 172.16.2.0 0.0.0.255R9(config-router)#network 172.16.3.0 0.0.0.255R9(config-router)#network 172.16.4.0 0.0.0.255R2(config)#router eigrp 110R2(config-router)#no auto-summary R2(config-router)#network 29.29.29.0 0.0.0.255R2(config-router)#redistribute ospf 1 metric 10000 1 1 1 1R2(config)#router ospf 1R2(config-router)#redistribute eigrp 110 subnets 3、采用合适的命令观察OSPF的邻居表、拓扑表和路由表，仔细观察路由表的各路由类型，并测试图示标注的loopback接口网段间的联通性 查看R1的邻居表 R1与R2、R6建立邻居邻接关系 查看R1的拓扑表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354R1#show ip ospf database OSPF Router with ID (1.1.1.1) (Process ID 1) Router Link States (Area 0)Link ID ADV Router Age Seq# Checksum Link count1.1.1.1 1.1.1.1 193 0x80000008 0x003704 32.2.2.2 2.2.2.2 194 0x80000008 0x009075 33.3.3.3 3.3.3.3 208 0x80000005 0x003D26 25.5.5.5 5.5.5.5 930 0x80000004 0x006220 26.6.6.6 6.6.6.6 194 0x80000005 0x00D31D 3 Net Link States (Area 0)Link ID ADV Router Age Seq# Checksum12.12.12.2 2.2.2.2 194 0x80000001 0x0014EB16.16.16.6 6.6.6.6 194 0x80000001 0x006B6423.23.23.2 2.2.2.2 344 0x80000002 0x00E8EC56.56.56.5 5.5.5.5 931 0x80000001 0x00C685 Summary Net Link States (Area 0)Link ID ADV Router Age Seq# Checksum10.7.1.0 5.5.5.5 298 0x80000001 0x007F8C10.7.2.0 5.5.5.5 298 0x80000001 0x00749610.7.3.0 5.5.5.5 299 0x80000001 0x0069A010.7.4.0 5.5.5.5 299 0x80000001 0x005EAA10.8.1.0 5.5.5.5 285 0x80000001 0x00739710.8.2.0 5.5.5.5 286 0x80000001 0x0068A110.8.3.0 5.5.5.5 286 0x80000001 0x005DAB10.8.4.0 5.5.5.5 286 0x80000001 0x0052B534.34.34.0 3.3.3.3 208 0x80000002 0x00E2A634.34.34.0 5.5.5.5 1020 0x80000001 0x000D6B45.45.45.0 3.3.3.3 1295 0x80000001 0x00BBA345.45.45.0 5.5.5.5 1020 0x80000001 0x00FC9A57.57.57.0 5.5.5.5 1010 0x80000001 0x004B28192.168.1.0 3.3.3.3 316 0x80000001 0x00FE86192.168.1.0 5.5.5.5 318 0x80000001 0x00A40F192.168.2.0 3.3.3.3 316 0x80000001 0x00F390192.168.2.0 5.5.5.5 318 0x80000001 0x009919192.168.3.0 3.3.3.3 316 0x80000001 0x00E89A192.168.3.0 5.5.5.5 318 0x80000001 0x008E23192.168.4.0 3.3.3.3 317 0x80000001 0x00DDA4192.168.4.0 5.5.5.5 319 0x80000001 0x00832D Type-5 AS External Link States Link ID ADV Router Age Seq# Checksum Tag29.29.29.0 2.2.2.2 425 0x80000001 0x0093AD 0172.16.1.0 2.2.2.2 425 0x80000001 0x001BBF 0172.16.2.0 2.2.2.2 425 0x80000001 0x0010C9 0172.16.3.0 2.2.2.2 425 0x80000001 0x0005D3 0172.16.4.0 2.2.2.2 425 0x80000001 0x00F9DD 0 查看R1的路由表中的OSPF路由 1234567891011121314151617181920212223242526272829303132333435363738394041R1#show ip route ospf&lt;省略部分输出&gt; 2.0.0.0/24 is subnetted, 1 subnetsO 2.2.2.0 [110/11] via 12.12.12.2, 00:06:39, Ethernet0/0 3.0.0.0/24 is subnetted, 1 subnetsO 3.3.3.0 [110/21] via 12.12.12.2, 00:06:39, Ethernet0/0 5.0.0.0/24 is subnetted, 1 subnetsO 5.5.5.0 [110/21] via 16.16.16.6, 00:06:39, Ethernet0/1 6.0.0.0/24 is subnetted, 1 subnetsO 6.6.6.0 [110/11] via 16.16.16.6, 00:06:39, Ethernet0/1 10.0.0.0/24 is subnetted, 8 subnetsO IA 10.7.1.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 10.7.2.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 10.7.3.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 10.7.4.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 10.8.1.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 10.8.2.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 10.8.3.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 10.8.4.0 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1 23.0.0.0/24 is subnetted, 1 subnetsO 23.23.23.0 [110/20] via 12.12.12.2, 00:06:39, Ethernet0/0 29.0.0.0/24 is subnetted, 1 subnetsO E2 29.29.29.0 [110/20] via 12.12.12.2, 00:06:39, Ethernet0/0 34.0.0.0/24 is subnetted, 1 subnetsO IA 34.34.34.0 [110/84] via 12.12.12.2, 00:06:39, Ethernet0/0 45.0.0.0/24 is subnetted, 1 subnetsO IA 45.45.45.0 [110/30] via 16.16.16.6, 00:06:39, Ethernet0/1 56.0.0.0/24 is subnetted, 1 subnetsO 56.56.56.0 [110/20] via 16.16.16.6, 00:06:39, Ethernet0/1 57.0.0.0/24 is subnetted, 1 subnetsO IA 57.57.57.0 [110/30] via 16.16.16.6, 00:06:39, Ethernet0/1 172.16.0.0/24 is subnetted, 4 subnetsO E2 172.16.1.0 [110/20] via 12.12.12.2, 00:06:39, Ethernet0/0O E2 172.16.2.0 [110/20] via 12.12.12.2, 00:06:39, Ethernet0/0O E2 172.16.3.0 [110/20] via 12.12.12.2, 00:06:39, Ethernet0/0O E2 172.16.4.0 [110/20] via 12.12.12.2, 00:06:39, Ethernet0/0O IA 192.168.1.0/24 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 192.168.2.0/24 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 192.168.3.0/24 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1O IA 192.168.4.0/24 [110/31] via 16.16.16.6, 00:06:39, Ethernet0/1 连通性测试 4、要求骨干区域能够快速收敛，并让R5成为区域578中的DR 要使骨干区域能够快速收敛，只需将链路的网络类型改为点到点，则不会进行DR/BDR的选举 12345678910R1(config)#int range e0/0-1R1(config-if-range)#ip ospf network point-to-point R2(config)#int range e0/0-1R2(config-if-range)#ip ospf network point-to-point R3(config)#int e0/0R3(config-if)#ip ospf network point-to-point R5(config)#int e0/1 R5(config-if)#ip ospf network point-to-point R6(config)#int range e0/0-1R6(config-if-range)#ip ospf network point-to-point 要使R5成为区域578中的DR，则修改R5上的e0/2接口的OSPF优先级 12R5(config)#int e0/2R5(config-if)#ip ospf priority 10 查看R5的OSPF邻居表，此时R7为DROTHER，R8为BDR 5、采用合适的方案确保当骨干网络的任意链路中断的时候不会影响骨干网的连通性 在R3和R5上创建虚链路 12345R3(config)#router ospf 1R3(config-router)#area 345 virtual-link 5.5.5.5R5(config)#router ospf 1R5(config-router)#area 345 virtual-link 3.3.3.3*Nov 15 10:41:41.581: %OSPF-5-ADJCHG: Process 1, Nbr 3.3.3.3 on OSPF_VL0 from LOADING to FULL, Loading Done 查看R3的邻居表 可知此时R3与R5之间通过虚链路建立邻居邻接关系 尝试将R1的e0/0接口shutdown，测试连通性 12R1(config)#int e0/0R1(config-if)#shutdown 在R9上使用loopback接口 ping R8上的loopback接口 6、观察各路由器上的路由表信息，然后在合适的路由器上进行必要的路由汇总，对比汇总之后各路由器路由表的变化，并观察和测试明细路由与汇总路由之间的关系 三类的路由在ABR上进行汇总 123456//在R3和R5上对三类路由进行汇总R3(config)#router ospf 1R3(config-router)#area 345 range 192.168.0.0 255.255.248.0R5(config)#router ospf 1R5(config-router)#area 345 range 192.168.0.0 255.255.248.0R5(config-router)#area 578 range 10.0.0.0 255.0.0.0 五类的路由在ASBR上汇总 123//在R2上对五类路由进行汇总R2(config)#router ospf 1R2(config-router)#summary-address 172.16.0.0 255.255.248.0 在执行汇总的路由器上都会产生指向NULL 0的路由条目 查看R1的路由表 此时只存在汇总后的路由 7、采用合适的方案，实现图示标注的loopback网段可以访问ISP上的主机100.100.100.100 首先实现R1和R6可以访问ISP上的100.100.100.100 123//在R1和R6上配置默认路由R1(config)#ip route 0.0.0.0 0.0.0.0 s1/0R6(config)#ip route 0.0.0.0 0.0.0.0 s1/0 在R1和R6上分别进行NAT的配置 R1上进行NAT配置 1234567891011//使用ACL匹配允许访问的网段R1(config)#access-list 1 permit 172.16.0.0 0.0.255.255 R1(config)#access-list 1 permit 192.168.0.0 0.0.255.255R1(config)#access-list 1 permit 10.0.0.0 0.255.255.255//使用端口复用NAT进行地址转换R1(config)#ip nat inside source list 1 interface s1/0 overload//指定内外部接口R1(config)#int s1/0R1(config-if)#ip nat outsideR1(config)#int range e0/0-1R1(config-if-range)#ip nat inside R6上进行NAT配置 12345678R6(config)#access-list 1 permit 172.16.0.0 0.0.255.255R6(config)#access-list 1 permit 192.168.0.0 0.0.255.255R6(config)#access-list 1 permit 10.0.0.0 0.255.255.255R6(config)#ip nat inside source list 1 interface s1/0 overload R6(config)#int s1/0R6(config-if)#ip nat outsideR6(config)#int range e0/0-1R6(config-if-range)#ip nat inside 在R1和R6上进行OSPF默认路由的下发 12345R1(config)#router ospf 1R1(config-router)#default-information originate R6(config)#router ospf 1R6(config-router)#default-information originate 查看R9、R4、R7、R8上的路由表，都存在一条默认路由 测试——在R9上 ping loopback接口地址，并在R1上查看地址转换表 测试——在R4上 ping loopback接口地址，并在R6上查看地址转换表 8、要求各链路正常情况下，内网优选ISP1的链路对外部网络进行访问，当与ISP1相连的链路出现故障的时候，自动切换到ISP2的链路对外部网络进行访问，使用tracert观察验证该现象 默认情况下，各链路的带宽如下图所示。其中，以太网链路的默认带宽为10，串行链路的默认带宽为64。则R4、R7和R8会优选ISP2访问外部网络，R9优选ISP1访问外部网络 将链路的带宽进行修改后如下图所示。此时可以实现内网优选ISP1的链路对外部进行访问 修改各链路的带宽 12345678R2(config)#int e0/0R2(config-if)#ip ospf cost 1R3(config)#int e0/0R3(config-if)#ip ospf cost 1R4(config)#int s1/0R4(config-if)#ip ospf cost 1R5(config)#int e0/0R5(config-if)#ip ospf cost 1 跟踪R7访问外网所经过的路径 由下图可知，此时R7通过ISP1的链路对外部网络进行访问 此时将ISP1上的S1/0接口shutdown 12ISP1(config)#int s1/0ISP1(config-if)#shutdown 再次跟踪R7访问外网所经过的路径 此时，R7通过ISP2的链路对外部网络进行访问","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"}]},{"title":"OSPF的配置","slug":"OSPF的配置","date":"2020-11-15T02:25:02.000Z","updated":"2020-11-15T05:14:22.084Z","comments":true,"path":"2020/11/15/OSPF的配置/","link":"","permalink":"http://shain.top/2020/11/15/OSPF%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一、基本的OSPF配置 拓扑如下图所示 （1）在四台路由器的对应接口上分别配置IP地址 123456789101112131415161718R1(config)#int e0/0R1(config-if)#ip address 192.168.12.1 255.255.255.0R1(config-if)#no shutdownR2(config)#int e0/0R2(config-if)#ip address 192.168.12.2 255.255.255.0R2(config-if)#no shutdown R2(config)#int e0/1R2(config-if)#ip address 192.168.23.2 255.255.255.0R2(config-if)#no shutdown R3(config)#int e0/0R3(config-if)#ip address 192.168.23.3 255.255.255.0R3(config-if)#no shutdown R3(config)#int e0/1R3(config-if)#ip address 192.168.34.3 255.255.255.0R3(config-if)#no shutdown R4(config)#int e0/0R4(config-if)#ip address 192.168.34.4 255.255.255.0R4(config-if)#no shutdown （2）基本的OSPF配置 123456789101112131415161718192021//启动一个OSPF进程，进程ID为10，此ID号仅本地有效R1(config)#router ospf 10//指定路由器ID为1.1.1.1R1(config-router)#router-id 1.1.1.1//使用network area命令来指定运行OSPF协议的接口和它们所在的区域//根据network语句来&quot;启动&quot;所有有效接口的IP地址，所有匹配的接口将被分配到根据network命令的area部分指定的区域R1(config-router)#network 192.168.12.0 0.0.0.255 area 1R2(config)#router ospf 20R2(config-router)#router-id 2.2.2.2R2(config-router)#network 192.168.12.0 0.0.0.255 area 1R2(config-router)#network 192.168.23.0 0.0.0.255 area 0R3(config)#router ospf 30R3(config-router)#router-id 3.3.3.3R3(config-router)#network 192.168.23.0 0.0.0.255 area 0R3(config-router)#network 192.168.34.0 0.0.0.255 area 2R4(config)#router ospf 40R4(config-router)#router-id 4.4.4.4R4(config-router)#network 192.168.34.0 0.0.0.255 area 2 （3）使用show ip ospf neighbor命令验证R1和R2上的OSPF邻居关系 输出参数如下 Neighbor ID（邻居ID）：代表邻居的路由器ID Pri（优先级）：邻居接口上用于DR/BDR选举的优先级 State（状态）：Full状态代表OSPF邻居建立过程的最后阶段，表示本地路由器与远程OSPF邻居已经建立了完全邻居邻接关系。DR表示DR/BDR选举过程已经完成，且使用路由器ID2.2.2.2的远程路由器被选择为DR Dead Time（失效时间）：代表失效计时器值。当此计时器过期时，路由器将终结邻居关系。每次路由器从特定邻居收到一个OSPF Hello包时，它都会重置失效计时器值 Address（地址）：邻居路由器的主IPv4地址 Interface（接口）：OSPF邻居关系建立所用的本地接口 （4）使用show ip ospf interface命令验证R1和R2上启用了OSPF的接口 show ip ospf interface命令的输出显示了OSPF进程中启用的所有接口。对于每个启用的接口，都可以看到一些详细信息，如OSPF区域ID、OSPF进程ID以及接口是如何加入到OSPF进程的。 （5）使用show ip route ospf命令在R1路由表中验证OSPF路由 在OSPF自治系统生成的路由中，OSPF清晰地区分了两种类型的路由：区域内路由和区域间路由。在路由表中，区域内路由的代码是O，区域间路由的代码是O IA。从下图可知，R1上学习到的OSPF路由都为区域间路由。 （6）使用show ip ospf route命令查看R1上的OSPF数据库路由 该命令清楚地区分了区域内路由和区域间路由。此外，该命令的输出内容也显示了ABR的基本信息，包括路由器ID、当前区域中的IPv4地址、将路由通告到区域的接口以及区域ID。 （7）使用show ip ospf process-id命令显示指定进程的信息 二、OSPF认证 OSPF存在三种认证方式： 不认证——类型0 明文认证——类型1 密文认证——类型2 接口下和进程下都可以开启认证，接口下的认证方式更优先 （1）明文认证 R1和R2在接口下开启认证 123456789R1(config)#int e0/0//在接口下开启明文认证R1(config-if)#ip ospf authentication//设置密码为shainR1(config-if)#ip ospf authentication-key shainR2(config)#int e0/0R2(config-if)#ip ospf authenticationR2(config-if)#ip ospf authentication-key shain R1与R2都开启了认证，邻居关系仍正常建立 R1和R2在进程下开启认证 1234567891011R1(config)#router ospf 10//R1在进程下针对区域1开启认证R1(config-router)#area 1 authentication //在接口下设置认证密码R1(config)#int e0/0R1(config-if)#ip ospf authentication-key shainR2(config)#router ospf 20R2(config-router)#area 1 authentication R2(config)#int e0/0R2(config-if)#ip ospf authentication-key shain 使用show ip ospf 10查看R1上OSPF进程10的信息，由下图可知区域1进行了明文认证 由于R1和R2都进行了明文认证，则它们的邻居关系仍能正常建立 （2）密文认证 R2和R3在接口下开启密文认证 123456789R2(config)#int e0/1//R2在接口下开启密文认证R2(config-if)#ip ospf authentication message-digest //设置密文密码为shainR2(config-if)#ip ospf message-digest-key 1 md5 shainR3(config)#int e0/0R3(config-if)#ip ospf authentication message-digest R3(config-if)#ip ospf message-digest-key 1 md5 shain R2和R3在进程下开启密文认证 12345678910R2(config)#router ospf 20//R2在进程下针对区域0开启密文认证R2(config-router)#area 0 authentication message-digest //在接口下设置密文密码为shainR2(config-if)#ip ospf message-digest-key 1 md5 shainR3(config)#router ospf 30R3(config-router)#area 0 authentication message-digest R3(config)#int e0/0R3(config-if)#ip ospf message-digest-key 1 md5 shain 使用show ip ospf 20查看R2上OSPF进程20的信息，由下图可知区域0进行了密文认证 三、虚链路 使用虚链路连接两个分段的骨干区域 （1）在各路由器上进行基本的OSPF配置 123456789101112131415161718192021222324R1(config)#router ospf 1//在进程下指定路由器IDR1(config-router)#router-id 1.1.1.1R1(config)#int range e0/0-1//将路由器上的接口加入到对应的OSPF进程和指定的区域中R1(config-if-range)#ip ospf 1 area 0R2(config)#router ospf 1R2(config-router)#router-id 2.2.2.2R2(config)#int range e0/0-1R2(config-if-range)#ip ospf 1 area 0R3(config)#router ospf 1R3(config-router)#router-id 3.3.3.3R3(config)#int range e0/0-1R3(config-if-range)#ip ospf 1 area 0R4(config)#router ospf 1R4(config-router)#router-id 4.4.4.4R4(config)#int range e0/0-1R4(config-if-range)#ip ospf 1 area 0R4(config)#int e0/2R4(config-if)#ip ospf 1 area 1//其余路由器配置同上，此处不再列出 完成上述配置后，路由器之间都建立了OSPF邻居邻接关系。以R4为例，R4与R2、R3、R9之前都建立了邻居邻接关系。 （2）查看R9的路由表中的OSPF路由，可知R9学习到了到达各网段的路由 （3）在R4的路由表中，并不存在到达对端区域0的路由，这是因为骨干区域被分隔开了 （4）在R4和R5上配置虚链路 1234567R4(config)#router ospf 1//配置R4，指定虚链路所使用的传输区域的区域ID为1（注意，该区域不能为特殊区域）；5.5.5.5位虚链路邻居的RIDR4(config-router)#area 1 virtual-link 5.5.5.5R5(config)#router ospf 1R5(config-router)#area 1 virtual-link 4.4.4.4*Nov 12 07:07:22.823: %OSPF-5-ADJCHG: Process 1, Nbr 4.4.4.4 on OSPF_VL2 from LOADING to FULL, Loading Done （5）查看R4的邻居表，此时R4和R5之间通过虚链路建立邻居邻接关系，并且没有死亡时间 （6）查看R4的路由表中的OSPF路由，此时学习到了到达对端骨干区域的路由 （7）配置虚链路之间的认证 由于虚链路属于区域0，所以也可以针对区域0开启认证，以下只针对虚链路进行认证 12345R4(config)#router ospf 1R4(config-router)#area 1 virtual-link 5.5.5.5 authentication-key shainR5(config)#router ospf 1R5(config-router)#area 1 virtual-link 4.4.4.4 authentication-key shain （8）使用show ip ospf interface命令检验身份验证 使用虚链路连接非骨干区域到骨干区域 （1）完成各路由器上的基本的OSPF配置 （2）查看R7的路由表中的OSPF路由 由于R7属于区域2，并且没有与骨干区域相连，所以此时无法学习到OSPF路由 （3）在R3和R6上配置虚链路 123456R3(config)#router ospf 1R3(config-router)#area 1 virtual-link 6.6.6.6R6(config)#router ospf 1R6(config-router)#area 1 virtual-link 3.3.3.3*Nov 12 08:09:02.430: %OSPF-5-ADJCHG: Process 1, Nbr 3.3.3.3 on OSPF_VL0 from LOADING to FULL, Loading Done （4）查看R3的邻居表，此时R3与R6之间通过虚链路建立邻居邻接关系 （5）查看R7的路由表中的OSPF路由，此时R7学习到了到达各网段的路由 四、OSPF 末梢区域 拓扑如下所示 （1）在OSPF自主系统内完成各路由器的OSPF的基本配置 查看R4的路由表 （2）R6与R1上启用EIGRP协议，并在R1上执行重分布 123456789101112131415R6(config)#router eigrp 90R6(config-router)#no auto-summary R6(config-router)#network 192.168.16.0 0.0.0.255R6(config-router)#network 10.10.10.0 0.0.0.255R6(config-router)#network 10.10.20.0 0.0.0.255R6(config-router)#network 10.10.30.0 0.0.0.255R1(config)#router eigrp 90R1(config-router)#no auto-summary R1(config-router)#network 192.168.16.0 0.0.0.255//将OSPF路由重分布进EIGRPR1(config-router)#redistribute ospf 1 metric 10000 1 1 1 1R1(config)#router ospf 1//将EIGRP路由重分布进OSPFR1(config-router)#redistribute eigrp 90 subnets （3）此时查看R4的路由表 R4的路由表中存在带O、O IA、O E2标志的OSPF路由条目 （4）查看R4的链路状态数据库和链路状态数据库的汇总信息 R4的链路状态数据库中存在5种类型的LSA 123456789101112131415161718192021222324252627282930313233343536373839404142R4#show ip ospf database OSPF Router with ID (4.4.4.4) (Process ID 1) Router Link States (Area 1)Link ID ADV Router Age Seq# Checksum Link count2.2.2.2 2.2.2.2 1167 0x80000003 0x00787E 24.4.4.4 4.4.4.4 1137 0x80000003 0x005588 2 Net Link States (Area 1)Link ID ADV Router Age Seq# Checksum192.168.24.2 2.2.2.2 1260 0x80000001 0x00A1F4 Summary Net Link States (Area 1)Link ID ADV Router Age Seq# Checksum1.1.1.1 2.2.2.2 1175 0x80000001 0x008D983.3.3.3 2.2.2.2 1151 0x80000001 0x00957E5.5.5.5 2.2.2.2 1115 0x80000001 0x009D64192.168.10.1 2.2.2.2 1268 0x80000001 0x009124192.168.12.0 2.2.2.2 1297 0x80000002 0x00793B192.168.13.0 2.2.2.2 1268 0x80000001 0x00D4D5192.168.20.1 2.2.2.2 1268 0x80000001 0x002388192.168.30.1 2.2.2.2 1268 0x80000001 0x00B4EC192.168.35.0 2.2.2.2 1268 0x80000001 0x004644192.168.40.1 2.2.2.2 1268 0x80000001 0x004651192.168.50.1 2.2.2.2 1268 0x80000001 0x00D7B5 Summary ASB Link States (Area 1)Link ID ADV Router Age Seq# Checksum1.1.1.1 2.2.2.2 499 0x80000001 0x0075B0 Type-5 AS External Link StatesLink ID ADV Router Age Seq# Checksum Tag10.10.10.0 1.1.1.1 505 0x80000001 0x00601E 010.10.20.0 1.1.1.1 505 0x80000001 0x00F182 010.10.30.0 1.1.1.1 505 0x80000001 0x0083E6 0192.168.16.0 1.1.1.1 505 0x80000001 0x0067BB 0 R4的数据库中总共包括19条LSA。其中：类型3的LSA数目为11，类型4的LSA数目为1，类型5的LSA数目为4 （5）此时，将区域1配置成末梢区域 1234R2(config)#router ospf 1R2(config-router)#area 1 stub R4(config)#router ospf 1R4(config-router)#area 1 stub （6）再次查看R4的数据库的汇总信息 此时，类型3的LSA数目为12、类型4和类型5的数目都为0，总共包含15条LSA 查看数据库，可知此时多了一条3类的汇总LSA，为配置成Stub区域后下发的默认路由 可知：配置成末梢区域后，会过滤4类和5类的LSA，并且下发3类的默认路由 （7）测试：在R4上pingR6上的回环口，测试网络的连通性 （8）将区域1配置成完全末梢区域 通过在命令area stub的末端增加关键字no-summary来实现。此操作只有在ABR上才是必要的，在内部路由器上使用标准的末梢区域配置即可。 12R2(config)#router ospf 1R2(config-router)#area 1 stub no-summary （9）此时查看R4上的数据库的汇总信息和数据库 R4上的数据库总共包括4条LSA，其中1类LSA占2条、2类LSA占1条、3类LSA占1条 可知：配置成完全末梢区域后，会过滤4类和5类的LSA，并下发3类的默认路由，再将3类的LSA进行过滤 查看路由表，R4访问外部网络时都将匹配该默认路由 （10）测试：在R4上pingR6上的回环口，测试网络的连通性 （11）将区域2配置成NSSA区域 1234R3(config)#router ospf 1R3(config-router)#area 2 nssa R5(config)#router ospf 1R5(config-router)#area 2 nssa （12）查看R5的链路状态数据库 此时，4类和5类的LSA被过滤，但是并没有下发默认路由 可知：配置成非完全末梢区域后，会过滤4类和5类的LSA，但是不会下发3类的默认路由 （13）测试：在R5上pingR6上的回环口，测试网络连通性 （14）在命令area nssa的末端添加关键字no-summary实现将区域2配置成totally-nssa。同样，该操作只需在ABR上进行配置 12R3(config)#router ospf 1R3(config-router)#area 2 nssa no-summary （15）此时查看R5的链路状态数据库和路由表 可知：配置成totally-nssa后，过滤掉4类和5类LSA的同时，还会下发3类的默认路由，并且将3类的LSA进行过滤 （16）再次进行连通性测试，此时测试成功 五、OSPF的地址汇总 虽然末梢区域可以通过防止某些LSA进入该区域，从而达到在一个非骨干的域中节省资源的目的，但是从骨干区域上来看，这些区域除了节省资源外并没有其他任何事情。一个区域内的所有地址仍然会通告到骨干区域中。这种情形可以通过地址汇总来解帮助解决。在Cisco路由器上可以执行两种类型的地址汇总：区域间路由汇总和外部路由汇总。 区域间路由汇总（inter-area summarization）：指在区域之间的地址汇总。该类型的汇总通常是在ABR上配置。 外部路由汇总（external route summarization）：允许一组外部地址汇总为一条汇总地址并通过重新分配注入到一个OSPF区域中。该类型的汇总通常是在ASBR上配置。 （1）按照拓扑图完成各路由协议的配置，并在R1上进行重分布 （2）查看R1的路由表 （3）在R2上进行区域间的路由汇总 123R2(config)#router ospf 1//进程下对三类路由进行汇总R2(config-router)#area 1 range 192.168.0.0 255.255.248.0 查看R2的路由表，可知此时生成了一条执行null 0的路由条目。该路由条目用于避免路由黑洞和路由环路。 （4）再次查看R1的路由表，192.168.0.0/21为经过R2汇总过的路由 （5）在R1上对外部路由进行汇总 12R1(config)#router ospf 1R1(config-router)#summary-address 10.10.0.0 255.255.0.0 （6）查看R2的路由表 与上图相比，外部路由被汇总为10.10.0.0/16","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"}]},{"title":"OSPF基本原理","slug":"OSPF基本原理","date":"2020-11-15T02:07:25.000Z","updated":"2020-11-15T02:21:18.086Z","comments":true,"path":"2020/11/15/OSPF基本原理/","link":"","permalink":"http://shain.top/2020/11/15/OSPF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","excerpt":"","text":"1、概述 开放式最短路径优先（Open Shortest Path First，OSPF）协议是由Internet工程任务组（Internet Engineering Task Force，IETF）开发的路由选择协议，用来替代存在一些问题的RIP协议。现在，OSPF协议是IETF组织建议使用的内部网关协议（IGP）。OSPF使用Dijkstra算法来计算最短路径树。像所有的链路状态协议一样，OSPF协议和距离矢量协议相比，一个主要的改善在于它的快速收敛，这使得OSPF协议可以支持更大型的网络，并且不容易受到有害路由选择信息的影响。OSPF协议的其他一些特性有： 使用了区域的概念，这样可以有效地减少路由选择协议对路由器的CPU和内存的占用；划分区域还可以降低路由选择协议的通信量，这使构建一个层次化的网络拓扑成为可能； 完全无类别地处理地址问题，排除了不连续子网这样的有类路由选择协议的问题； 支持无类别路由表查询、VLAM和用来进行有效地址管理的超网技术； 支持无大小限制的、任意的度量值； 支持使用多条路径的效率更高的等价负载均衡； 使用保留的组播地址来减少对不宣告OSPF的设备的影响； 使用可以跟踪外部路由的路由标记 2、OSPF的相关术语 链路：链路就是一个网络或者一个被指定给任一给定网络的路由器接口。当一个接口被添加到OSPF进程时，它就被OSPF认定是一个链路。这个链路或接口都将有一个与它关联的状态信息（up或down），以及一个或多个IP地址 路由器ID：路由器ID（RID）是一个用来标识此路由器的IP地址。该地址可以通过手动指定（必须唯一）；若未指定，则选择路由器上所有活跃的环回接口中最大的IPv4地址；若不存在环回接口，则选择所有活跃的物理接口中最大的IPv4地址 邻居：邻居可以是两个或更多的路由器，这些路由器的某个接口是连接在同一个公共网络上，比如两个通过点到点串行链路连接在一起的路由器 邻接：邻接是指两个OSPF路由器之间的关系，这两个路由器之间允许直接交换路由更新数据。注意，并不是所有的邻居都可以建立邻接关系，这将取决于网络类型和路由器配置 Hello协议：OSPF的Hello协议能够动态地发现邻居，并维护邻居关系。在两台路由器成为邻居之前，需要通告这两台路由器必须相互认可的几个参数。Hello数据包确保了邻居路由器之间的双向通信，并且和链路状态通告（LSA）共同用于建立并维护拓扑数据库 邻居关系数据库：邻居关系数据库是一个OSPF路由器的列表，这些路由器的Hello数据包相互可见。每个路由器上的邻居关系数据库中管理着各种详细的资料，包括路由器ID和状态等信息 拓扑数据库：拓扑数据库中包含有来自同一区域接收的所有链路状态通告数据包的信息。路由器使用来自拓扑数据库中的信息，作为Dijkstra算法的输入，并通过该算法为每个网络计算出最短路径 链路状态通告（LSA）：LSA中包含着OSPF路由器共享的链路状态和路由选择信息 指定路由器和备用指定路由器：当OSPF路由器被连接到同一多路访问网络时，都需要选择一个指定路由器（DR）和备用指定路由器（BDR）。DR负责将路由选择信息分发到广播网络或链路中其他路由器上，或收集其他路由器的路由选择信息。如果DR失效了，那么BDR将成为新的DR。DR和BDR的选择规则如下： 先比较优先级，优先级大的优先；默认情况下以太网接口的优先级为1，串行接口的优先级为0（优先级为0不参与DR/BDR的选举） 若优先级相同，则继续比较RID，RID越大越优先 注意，DR和BDR的选举是非抢占的（也就是说，在已经选取了DR和BDR路由器后，如果一台具有更高优先级的路由器加入，那么这台新的路由器将不会替代DR和BDR路由器的任何一台） 3、OSPF的网络类型 点到点网络（point-to-point） 点到点网络，像T1、DS-3或SONET链路，是连接单独一对路由器的。在点到点网络上的有效邻居总是可以形成邻接关系。在这些网络上的OSPF数据包的目的地址也总是保留的D类地址224.0.0.5，这个组播地址称为ALLSPFRouters。在点到点网络类型不需要进行DR/BDR的选举。 广播型网络（broadcast） 广播型网络，像以太网、令牌环网和FDDI，也可以更确切地定义为广播型多址网络。需要进行DR和BDR的选举。由于是广播型的，所以连接在这种网络上的所有设备都可以接收到个别传送的数据包。 非广播多路访问（NBMA）网络 NBMA网络，像X.25、帧中继和ATM等，可以连接两台以上的路由器，但是它们没有广播数据包的能力。一台在NBMA网络上的路由器发送的数据包将不能被其他与之相连的路由器收到。在NBMA网络上的OSPF路由器需要选举DR和BDR，并且所有的OSPF数据包都是单播的，在这些网络上的路由器需要增加另外的配置来获得它们的邻居。 点到多点网络（point-to-multipoint） 点到多点网络是NBMA网络的一个特殊配置，可以被看做是一群点到点链路的集合。在这些网络上的OSPF路由器不需要选举DR和BDR，OSPF数据包以单播方式发送给每一个已知的邻居。 虚链路（virtual links） 虚链路可以被路由器认为是没有编号的点到点网络的一种特殊配置。在虚链路上OSPF数据包是以单播方式发送的。 4、OSPF消息类型 OSPF使用五种类型的路由协议包，共享通用的协议头部。每个OSPF包被直接封装在IP头部中。OSPF的IP协议号是89。 类型一：Hello数据包。Hello数据包负责发现、构建并维持OSPF邻居邻接关系。为了形成一种邻接关系，Hello数据包携带的参数必须和它的邻居保持一致。 类型二：DBD（数据库描述）数据包。数据库描述数据包用于正在建立的邻接关系。它的一个主要的目的是描述始发路由器数据库中的一些或全部LSA信息，以便接收路由器能够确定所收到的LSA在其数据库中是否已经有了一个匹配的LSA。路由器由此判断数据库是否同步。 类型三：LSR（链路状态请求）数据包。在数据库同步过程中如果收到了数据库描述数据包，路由器将会查看数据库描述数据包里有哪些LSA不在自己的数据库中，或者有哪些LSA比自己数据库中的LSA更新。然后，将把这些LSA记录在链路状态请求列表中。接着，路由器会发送一个或多个链路状态请求数据包去向它的邻居请求发送在链路状态请求列表中的这些LSA的副本。 类型四：LSU（链路状态更新）数据包。LSU数据包包括几种类型的LSA。LSU负责泛洪LSA，以及发送对LSR包的LSA响应。LSA响应只会发给之前以LSR包形式请求LSA的直连邻居。进行泛洪时，邻居路由器负责把收到的LSA信息重新封装在新的LSU包中。 类型五：LSAck（链路状态确认）数据包。LSAck负责进行可靠的LSA泛洪。路由器必须明确确认每个收到的LSA，可以用一个LSAck包确认多个LSA。 5、OSPF状态机 Down（失效状态）——这是一个邻居会话的初始状态，用来指明在最近一个路由死亡间隔时间内还没有收到来自邻居路由器的Hello数据包。如果一台邻居路由器从其他更高一些的邻居状态转换到了失效状态，那么路由器将会清空链路状态重传列表、数据库摘要列表和链路状态请求列表。当邻居邻接关系建立成功后，由于接口松动、重启进程或其他一些因素也会是OSPF状态动Full转换到Down。在Down状态，网段上不会收到信息。 Attempt（尝试状态）——这种状态仅仅适用于NBMA网络上的邻居，在NBMA网络上邻居路由器是手工配置的。当NBMA网络上具有DR选取资格的路由器和其邻居路由器相连的接口开始变为有效时，或者当这台路由器成为DR或BDR时，这台具有DR选取资格的路由器会把邻居路由器的状态转换到Attempt状态。在Attempt状态下，路由器将使用HelloInterval的时间代替PollInterval的时间来作为向邻居发送Hello数据包的时间间隔。 Init（初始状态）——这一状态表明在最近的RouterDeadInterval时间里路由器收到了来自邻居路由器的Hello数据包，但是双向通信仍然没有建立。路由器将会在Hello数据包的邻居字段中包含这种状态下或更高状态的所有邻居路由器的路由器ID。 2-Way（双向通信状态）——这一状态表明本地路由器已经在来自邻居路由器的Hello数据包的邻居字段中看到了自己的路由器ID，这也就意味着一个双向通信的会话已经成功建立了。在多址网络中，邻居路由器必须在这个状态或更高状态时才能有资格被选作该网络上的DR或BDR。 ExStart（信息交换初始状态）——在这一状态下，本地路由器和它的邻居将建立起主/从关系，并确定数据库描述数据包的序列号，以便为数据库描述数据包的信息交换做准备。在这里，具有最高路由器ID的邻居路由器将成为”主”路由器。 Exchange（信息交换状态）——在这一状态下，本地路由器将向它的邻居路由器发送可以描述它整个链路状态数据库信息的数据库描述数据包。同时，在这个Exchange状态下，本地路由器也会发送链路状态请求数据包给它的邻居路由器，用来请求最新的LSA。 Loading（信息加载状态）——在这一状态下，本地路由器将会向它的邻居路由器发送链路状态请求数据包，用来请求最新的LSA通告。虽然在Exchange状态下已经发现了这些最新的LSA通告，但是本地路由器还没有收到这些LSA通告。 Full（完全邻接状态）——在这一状态下，邻居路由器之间将建立起完全邻接关系，这种邻接关系出现在路由器LSA和网络LSA中。 6、建立一个邻接关系 在一个邻接关系的创建过程中，OSPF协议使用以下3种数据包类型： 数据库描述数据包 链路状态请求数据包 链路状态更新数据包 在数据库描述数据包中有3个标记位用来管理邻接关系的建立过程： I位：当需要指明所发送的是第一个数据库描述数据包时，该位设置为1； M位：当需要指明所发送的还不是最后一个数据库描述数据包时，该位设置为1； MS位：当数据库描述数据包始发于一个”主”路由器时，该位设置为1. （1）在多路访问的网络上，路由器RT1变为有效状态，并发送一个Hello数据包。由于它还没有学习到任何邻居，因而这个Hello数据包的邻居字段是空的，而DR和BDR字段设置为0.0.0.0。 （2）RT2收到RT1的Hello数据包后，会为RT1创建一个邻居数据结构，并将RT1的状态设置为Init。RT2把RT1的Hello数据包中的RID提取出来，添加到自己的Hello数据包中，发送给RT1。当RT1和RT2在接收到的Hello包中都看到了自己的RID，则会进入2-Way状态。此时会进行DR和BDR的选举。 （3）RT1产生一个空的DBD数据包（没有包含LSA摘要），并把DBD的序列号设置为x。同时设置初始位（I）来指明这个数据包是路由器RT1用来进行本次信息交换的最初的数据库描述数据包，并设置后继位（M）来指明这个数据包不是最后的数据库描述数据包，最后还要设置主从位（MS）来指明RT1声称自己是”主”路由器。 （4）RT2收到来自RT1的数据库描述数据包后，就会把RT1的状态转换到ExStart状态。接着，它将发送一个响应的数据库描述数据包，并把这个数据库描述数据包的序列号设置为y。由于RT2拥有比RT1更高的RID，因此它将把自己的MS位置1。该数据包也用于主从关系协商，因此也是空的。当RT1收到此数据包后，会将RT2的状态转换到ExStart状态。 （5）当两台邻居路由器同意RT2是主路由器后，路由器RT1就把路由器RT2的状态转换为Exchange状态。路由器RT1将产生一个数据库描述数据包，这个数据包的序列号使用RT2的数据库描述数据包的序列号y，并设置MS位为0用来指明RT1是”从”路由器。同时，该数据包将会传送路由器RT1的链路状态摘要列表中的LSA头部。 （6）当路由器RT2收到来自RT1的数据库描述数据包，就会把它的邻居状态转化到Exchange状态。接着，它将发送一个数据库描述数据包，这个数据包包含路由器RT2自己的链路状态摘要列表中的LSA头部，并使它的数据库描述序列号增加到y+1。 （7）当路由器RT1从路由器RT2收到上述的数据库描述数据包后，路由器RT1就会发送一个包含相同序列号的确认数据包。这个过程将一直延续，路由器RT2发送一个单一的数据库描述数据包，接着等待从RT1发出的包含相同序列号的确认数据包，然后RT2再发送下一个数据库描述数据包，直到路由器RT2发出包含最后一个LSA摘要的数据库描述数据包，并把这个数据包的M位设置为0。 （8）收到上述数据包并且确信它所发出的确认数据包包含它自己最后的LSA摘要后，路由器RT1就会认为Exchange过程已经完成。然而，路由器RT1的链路状态请求列表中还存在LSA条目，因此，它将转换到信息加载状态（Loading）。 （9）当路由器RT2收到RT1的最后一个数据库描述数据包时，路由器RT2将把RT1的状态转换为完全邻接状态（Full），这是因为在它（RT2）的链路状态请求列表中已经没有LSA条目了。 （10）路由器RT1发送链路状态请求数据包，而路由器RT2通过链路状态更新数据包发送被请求的LSA通告，这个过程一直持续到路由器RT1的链路状态请求列表变为空。然后，路由器RT1也将路由器RT2的状态转换到完全邻接状态。 7、OSPF的区域 OSPF协议由于使用了多个数据库和复杂的算法，因而相比其他的路由选择协议而言，他将会耗费路由器更多的内存和更多的CPU处理能力。当网络的规模不断增大时，对路由器的性能要求就会显得比较重要甚至达到了路由器性能的极限。另一方面，虽然LSA的泛洪扩散比RIP协议中周期性的、全路由表的更新更加有效率，但是对于一个大型的网络来说，它依然给大量数据链路带来了无法承受的负担。 OSPF协议可以利用区域的概念来缩小这些不利的影响。在OSPF协议的环境下，区域是一组逻辑上的OSPF路由器和链路，它可以有效地把一个OSPF域分割成几个子域。在一个区域内的路由器将不再需要了解他们所在区域外部的拓扑细节。在这种环境下： 路由器仅需要和它所在区域的其他路由器具有相同的链路状态数据库，因此，链路状态数据库大小的缩减就降低了对路由器内存的消耗 链路状态数据库的减少也意味着处理较少的LSA，从而也就降低了对路由器CPU的消耗 由于链路状态数据库只需要在一个区域内进行维护，因此，大量的LSA泛洪扩散也就被限制在一个区域里面了 OSPF使用两层的区域分级： 骨干区域（区域0）——骨干区域的要求为，骨干区域必须连接所有其他非骨干区域；骨干区域必须连续；非骨干区域之间要通信必须经过骨干区域。一般来说，骨干区域中没有终端用户。 非骨干区域——此区域的主要功能是连接终端用户和资源。非骨干区域通常根据功能性或地理位置进行划分。不同非骨干区域之间的流量必须总是经过骨干区域。 虚链路（virtual link）是指一条通过一个非骨干区域连接到骨干区域的链路。虚链路主要应用于以下几种目的： 通过一个非骨干区域连接一个区域到骨干区域 通过一个非骨干区域连接一个分段的骨干区域两边的部分区域 在上述例子中，虚链路和具体的物理链路没有关系。虚链路事实上是一个逻辑通道，数据包可以通过选择最优的路径从一端到达另一端。在配置虚链路时，相关的规则说明如下： 虚链路必须配置在两台ABR路由器之间 配置了虚链路所经过的区域必须拥有全部的路由选择信息，这样的区域又被称为传送区域（transit areaa） 传送区域不能是一个末梢区域 正如前面所提及的，OSPF协议也把虚链路归类为一个网络类型。更特别的是，虚链路可以看成是在两台ABR路由器之间的一个无编码的——也就是说无编址地址——链路，并且它是属于骨干区域的。这些ABR路由器之间虽然没有物理的数据链路相连，但是它们可以看作是通过他们之间的虚链路逻辑上虚拟连接的邻居。在每一个ABR路由器的路由表中，当发现有到达邻居的ABR路由器的路由时，虚链路将转换到完全可操作的点到点接口状态。这条虚链路的代价就是到达它的邻居路由器的代价。当接口状态变为点到点状态时，一个邻接关系将通过这条虚链路建立成功。 虚链路的存在增加了网络的复杂度，使故障的排除更加困难。因此，最好避免使用虚链路，而应该在区域上，特别是骨干区域上设计冗余链路来确保防止分段区域的产生。虚链路可以看做是一个标明网络的某个部分是否需要重新设计的标志。事实上，永久虚链路的存在总是一个设计比较糟糕的网络的标志。 8、链路状态数据库 一台路由器中所有有效的LSA都被存放在它的链路状态数据库中。正确的LSA将可以描述一个OSPF区域网络拓扑的结构。一个区域中的每一台路由器都要利用这个数据库的信息来计算它自己的最短路径树，因此，所有区域数据库的统一性对于正确的路由选择来说就变得十分重要。 由于OSPF协议定义了多种路由器的类型，因而定义多种LSA通告的类型也是必要的。每一种LSA通告类型都描述了OSPF网络的一种不同情况。 类型代码 描述 1 路由器LSA 2 网络LSA 3 网络汇总LSA 4 ASBR汇总LSA 5 AS外部LSA 6 组成员LSA 7 NSSA外部LSA 8 外部属性LSA 9 Opaque LSA（链路本地范围） 10 Opaque LSA（本地区域范围） 11 Opaque LSA（AS范围） 路由器LSA（Router LSA）——每一台路由器都会产生路由器LSA通告。这个最基本的LSA通告列出了路由器所有的链路或接口，并指明了它们的状态和沿每条链路方向出站的代价，以及该链路上所有已知的OSPF邻居。这些LSA通告只会在始发它们的区域内部进行泛洪扩散。通过命令show ip ospf database router可以查看数据库中列出的所有路由器LSA通告。 网络LSA（Network LSA）——每一个多路访问网络中的指定路由器（DR）将会产生网络LSA通告。DR路由器可以看作一个”伪”节点，或是一个虚拟路由器，用来描绘一个多路访问网络和与之相连的所有路由器。从这个角度来看，一条网络LSA通告也可以描绘一个逻辑上的”伪”节点，就像一条路由器LSA通告描绘一个物理上的单台路由器一样。网络LSA通告列出了所有与之相连的路由器，包括DR路由器本身。网络LSA仅仅在产生这条网络LSA的区域内部进行泛洪扩散。可以使用命令show ip ospf database network查看网络LSA通告的信息。 网络汇总LSA（Network Summary LSA）——是由ABR路由器始发的。ABR路由器将发送网络汇总LSA到一个区域，用来通告该区域外部的目的地址。换句话说，这些网络汇总LSA就是ABR路由器告诉与其相连的区域内的内部路由器所能到达的目的地址的一种方法。可以通过命令show ip ospf database summary显示链路状态数据库中的网络汇总LSA信息。 ASBR汇总LSA（ASBR Summary LSA）——由ABR路由器始发。ASBR汇总LSA除了所通告的目的地是一台ASBR路由器而不是一个网络外，其他的和网络汇总LSA都是一样的。使用命令show ip ospf database asbr-summary可以查看ASBR汇总LSA的信息。通过ASBR汇总LSA通告的目的地将总是一个主机地址，因为它是一条到达一台路由器的路由。 自主系统外部LSA（Autonomous System External LSA）——即外部LSA，始发于ASBR路由器，用来通告到达OSPF自主系统外部的目的地或者是OSPF自主系统外部的缺省路由的LSA。外部LSA通告将在整个自主系统中进行泛洪扩散。使用命令show ip ospf database external可以查看AS外部LSA的信息。 NSSA外部LSA（NSSA External LSA）——是指在非纯末梢区域（Not-So-Stubby Area，NSSA）内始发于ASBR路由器的LSA通告。NSSA外部LSA通告仅在始发这个NSSA外部LSA通告的非纯末梢区域内部进行泛洪扩散。可以通过命令show ip ospf database nssa-external来显示NSSA外部LSA通告的信息。 9、末梢（Stub）区域 一个学习到外部目的地路由信息的ASBR路由器，将通过在整个OSPF自主系统中泛洪扩散自主系统外部LSA来通告那些外部的目的路由信息。这些外部LSA通告可能会在每台路由器的链路状态数据库中构成较大百分比的LSA数量，对性能不好的路由器产生压力。 末梢区域是一个不允许AS外部LSA通告在其内部进行泛洪扩散的区域。若在一个区域内没有学习到类型5的LSA通告，那么类型4的LSA通告也是不必要的了，因此这些LSA通告也将被阻塞。位于末梢区域边界的ABR路由器将使用网络汇总LSA向这个区域通告一个简单的缺省路由。（即在Stub区域中会将类型4和类型5的LSA进行过滤，并且下发类型3的默认路由） 末梢区域中存在的4个限制条件： 末梢区域内的所有路由器都会在它们的Hello数据包中设置一个标志——E-bit位，并将它设置为0。这样，这些末梢区域路由器将不接受其他路由器发送的任何E-bit为1的Hello数据包。因此，需要将Stub区域内的所有路由器配置成末梢区域路由器。 末梢区域中不能有虚链路的存在 末梢区域内需存在一台或多台ABR路由器，但是不能存在ASBR路由器。 骨干区域不能配置成特殊区域 完全末梢区域（totally stubby area）不仅使用缺省路由到达OSPF自主系统外部的目的地址，而且使用缺省路由到达这个区域外部的所有目的地址。（过滤类型4和类型5的LSA，并且下发类型3的默认路由，再将类型3的LSA进行过滤） 非纯末梢区域（Not-So-Stubby-Area，NSSA）允许外部路由通告到OSPF自主系统内部，而同时保留自主系统其余部分的末梢区域特征。NSSA区域允许ASBR路由器的存在。NSSA外部LSA在它的头部有一个称为P-bit位的标志。NSSA ASBR路由器可以设置或清除这个P-bit位。如果一台NSSA ABR路由器收到一条P-bit设置为1的类型7的LSA数据包，那么它将把这条类型7的LSA转换成为类型5的LSA，并且将这条LSA泛洪扩散到其他区域中。如果这个P-bit位被设置为0，那么将不会转换这条类型7的LSA，而且这条类型7的LSA携带的目的地址也不能通告到这个NSSA区域的外部。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"}]},{"title":"DHCP","slug":"DHCP","date":"2020-11-15T01:40:57.000Z","updated":"2020-11-15T02:01:58.367Z","comments":true,"path":"2020/11/15/DHCP/","link":"","permalink":"http://shain.top/2020/11/15/DHCP/","excerpt":"","text":"1、DHCP概述 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一种帮助网络管理员管理及自动分配IP地址的网络协议。在不使用DHCP的情况下，管理员必须手动为每台终端配置IP地址、子网掩码、默认网关等IP配置。在大型网络中，这将是一项繁重的工作，尤其是在设备物理位置频繁更改的环境中。在企业网环境中，DHCP服务器通常是一台专用设备；然而在小型网络或是分支机构中，DHCP服务器往往由Cisco Catalyst交换机或Cisco路由器配置实现。 2、DHCP工作原理 2.1、DHCP客户端进行IP请求 当一个DHCP客户机启动时，会自动将自己的IP地址配置成0.0.0.0，由于使用0.0.0.0不能进行正常通信，所以客户机就必须通过DHCP服务器来获取一个合法的地址。由于客户机不知道DHCP服务器的IP地址，所以它使用0.0.0.0作为源地址，255.255.255.255作为目标地址，使用UDP68号端口作为源端口，UDP67号端口作为目标地址，广播请求IP地址信息。广播信息DHCP Discover中包含了DHCP客户机的MAC地址和计算机名，以便使DHCP服务器能确定是哪个客户机发送的请求。 2.2、DHCP服务器响应请求 当DHCP服务器接收到客户机请求IP地址的信息时，它就在自己的IP地址池中查找是否有合法的IP地址用于提供给客户机。如果有，DHCP服务器就将此IP地址做上标记，加入到DHCP OFFER的信息中。 由于DHCP客户机此时还未获取到IP地址，所以DHCP服务器使用自己的IP地址作为源IP地址，使用广播地址255.255.255.255作为目标地址，源端口为UDP67号端口，目的端口为UDP68号端口，广播DHCP OFFER信息。DHCP OFFER消息中包括：DHCP客户机的MAC地址、DHCP服务器提供的合法IP地址、子网掩码、默认网关（路由）、租约的期限、DHCP服务器的IP地址等。 2.3、DHCP客户端选择IP DHCP客户机从接收到的第一个DHCP OFFER消息中选择IP地址，发出IP地址的DHCP服务器将该地址保留，这样该地址就不会提供给其他的DHCP客户机。DHCP客户机广播DHCP Request消息至所有的DHCP服务器，表明它接受提供的内容。DHCP Request消息中包含了为该客户机提供IP配置的服务器的服务标识（IP地址）。DHCP服务器查看服务器标识符字段，以确定自己是否被选择为指定的客户机提供IP地址。若DHCP OFFER报文被拒绝，则DHCP服务器会取消提供此IP地址并将其保留，以用于为下一个客户机提供IP。在客户机选择IP的过程中，虽然客户机选择了IP地址，但是还没有正式获取到该IP，所以客户机仍然使用0.0.0.0作为源地址，255.255.255.255作为目标地址，源端口为UDP68，目的端口为UDP67，广播DHCP Request消息。 2.4、DHCP服务器确认租约 服务器确认租约：DHCP ACK DHCP服务器接收到DHCP Request报文后，会向客户机广播DHCP ACK报文。该报文中包含了IP地址的有效租期和其他可能配置的信息。虽然服务器确认了客户机的租约请求，但是客户机此时仍未收到服务器的DHCP ACK报文，所以服务器会使用自己的IP地址作为源地址，使用255.255.255.255作为目的地址，源端口为UDP67，目的端口为UDP68进行广播。当客户机收到DHCP ACK报文后，表示客户机成功获取到了IP地址，完成了TCP/IP的初始化。 服务器拒绝租约：DHCP NACK（DHCP NAK） 如果DHCP Request不成功，例如客户机试图租约之前的IP地址，但该IP地址不再可用，或者因为客户机移动到其他子网，该IP无效时，DHCP服务器将广播否定确认消息DHCP NACK。当客户机接收到不成功的确认时，它将重新开始DHCP的租约过程。 如果DHCP客户机无法找到DHCP服务器，它将从TCP/IP的B类网段169.254. 0.0/16中挑选一个IP地址作为自 己的IP地址,继续每隔5分钟尝试与DHCP服务器进行通讯，一旦与DHCP服务器取得联系，则客户机放弃自动配置的IP地址，而使用DHCP服务器分配的IP地址。 DHCP客户机收到DHCP服务器回应的ACK报文后，通过地址冲突检测(arp)发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送DECLINE报文，通知服务器所分配的IP地址不可用。 2.5、DHCP客户端续租 DHCP客户机会在租期过去50%的时候，直接向为其提供IP地址的DHCP服务器发送DHCP Request报文。如果客户机接收到该服务器回应的DHCP ACK报文，客户机就根据包中所提供的新的租期以及其它已经更新的TCP/IP参数，更新自己的配置，IP租用更新完成；如果服务器拒绝，则停止租用，归还该地址；如果没有收到该服务器的回复，则客户机继续使用现有的IP地址。如果在租期过去50%的时候没有更新，则DHCP客户机将在租期过去87.5%的时候再次与为其提供IP地址的DHCP服务器联系，发送延长租用请求。如果还不成功，到租约的100%时候，DHCP客户机必须放弃这个IP地址，重新申请。如果此时无DHCP服务器可用，DHCP客 户机会使用169.254. 0. 0/16中随机的一个地址，并且每隔5分钟再进行尝试。 2.6、DHCP客户端状态转换 3、在多层交换网络中配置DHCP 拓扑图如下所示，配置DSW为DHCP服务器，PC1、PC2自动获取IP地址，针对PC3配置DHCP绑定 将DSW配置成DHCP服务器 1234567891011121314151617DSW(config)#int vlan 1DSW(config-if)#no shutdownDSW(config-if)#ip address 192.168.10.254 255.255.255.0//开启DHCP功能，Cisco默认开启DSW(config)#service dhcp//创建地址池，名称为VLAN1_POOLDSW(config)#ip dhcp pool VLAN1_POOL//通过IP子网及子网掩码定义地址范围DSW(dhcp-config)#network 192.168.10.0 255.255.255.0//设置分配给客户端的默认网关地址DSW(dhcp-config)#default-router 192.168.10.254//指定DNS服务器地址DSW(dhcp-config)#dns-server 8.8.8.8//设置IP地址的租用期限(默认为1天)DSW(dhcp-config)#lease 2//将192.168.10.254的地址从DHCP地址池中排除，该地址为DSW上的地址DSW(config)#ip dhcp excluded-address 192.168.10.254 在DSW上使用show ip dhcp pool命令检查配置的DHCP地址池 当前还未为任何客户端分配IP地址，并且可以看到地址池中被排除的IP地址个数 在DSW上开启DHCP包的调试功能 12DSW#debug ip dhcp server packet DHCP server packet debugging is on. 在PC1上设置IP地址获取方式为DHCP 1234PC1(config)#int e0/0PC1(config-if)#no shutdown PC1(config-if)#ip address dhcp*Nov 10 02:10:08.051: %DHCP-6-ADDRESS_ASSIGN: Interface Ethernet0/0 assigned DHCP address 192.168.10.1, mask 255.255.255.0, hostname PC1 查看DSW上输出的debug信息 12345678910111213141516*Nov 10 02:10:01.918: DHCPD: Reload workspace interface Vlan1 tableid 0.*Nov 10 02:10:01.918: DHCPD: tableid for 192.168.10.254 on Vlan1 is 0*Nov 10 02:10:01.918: DHCPD: client&#x27;s VPN is .*Nov 10 02:10:01.918: DHCPD: using received relay info.*Nov 10 02:10:01.918: DHCPD: DHCPDISCOVER received from client 0063.6973.636f.2d61.6162.622e.6363.3030.2e33.3030.302d.4574.302f.30 on interface Vlan1.*Nov 10 02:10:01.918: DHCPD: using received relay info.*Nov 10 02:10:03.924: DHCPD: Sending DHCPOFFER to client 0063.6973.636f.2d61.6162.622e.6363.3030.2e33.3030.302d.4574.302f.30 (192.168.10.1).*Nov 10 02:10:03.924: DHCPD: no option 125*Nov 10 02:10:03.924: DHCPD: broadcasting BOOTREPLY to client aabb.cc00.3000.*Nov 10 02:10:03.927: DHCPD: Reload workspace interface Vlan1 tableid 0.*Nov 10 02:10:03.927: DHCPD: tableid for 192.168.10.254 on Vlan1 is 0*Nov 10 02:10:03.927: DHCPD: client&#x27;s VPN is .*Nov 10 02:10:03.927: DHCPD: DHCPREQUEST received from client 0063.6973.636f.2d61.6162.622e.6363.3030.2e33.3030.302d.4574.302f.30.*Nov 10 02:10:03.927: DHCPD: Sending DHCPACK to client 0063.6973.636f.2d61.6162.622e.6363.3030.2e33.3030.302d.4574.302f.30 (192.168.10.1).*Nov 10 02:10:03.927: DHCPD: no option 125*Nov 10 02:10:03.927: DHCPD: broadcasting BOOTREPLY to client aabb.cc00.3000. 查看DHCP地址池 此时已分配地址数为1，下一个待分配的IP地址为192.168.10.2 设置PC2和PC3的IP地址获取方式为DHCP，然后在DSW上查看DHCP绑定表 当前DHCP服务器上已为3个客户端分配了IP地址 配置PC3通过DHCP获取到固定的IP地址 由上图可知，PC3的客户端标示符为0063.6973.636f.2d61.6162.622e.6363.3030.2e35.3030.302d.4574.302f.30，可以通过这个标示符配置静态的DHCP绑定。也可以使用MAC地址作为客户端标示符，只需在PC3的接口上输入ip address client-id ethernet 0/0 12345678//在DSW上清除PC3的DHCP绑定关系DSW#clear ip dhcp binding 192.168.10.3//在DSW上为PC3分配IP地址192.168.10.100DSW(config)#ip dhcp pool PC3DSW(dhcp-config)#host 192.168.10.100 255.255.255.0DSW(dhcp-config)#default-router 192.168.10.254//在某些环境中(例如运行Linux的设备)，设备发送的DHCP消息中是不携带标示符的，此时可以使用MAC地址来手动绑定IP地址，只需将client-identifier命令换成hardware-address命令即可DSW(dhcp-config)#client-identifier 0063.6973.636f.2d61.6162.622e.6363.3030.2e35.3030.302d.4574.302f.30 配置完成后，PC3并不会立刻获得配置的IP地址，只有当租期过期或是重新请求地址时才会分配绑定的IP地址 12345//强制PC3重新从DHCP服务器获取地址PC3(config)#int e0/0PC3(config-if)#shutdown PC3(config-if)#no shutdown *Nov 10 02:51:45.112: %DHCP-6-ADDRESS_ASSIGN: Interface Ethernet0/0 assigned DHCP address 192.168.10.100, mask 255.255.255.0, hostname PC3 在DSW1上查看DHCP绑定表，可知192.168.10.100这个地址的租期为永久有效 4、DHCP中继 DHCP中继是一个小程序，可以实现在不同子网和物理网段之间处理和转发DHCP信息。如果DHCP客户端和DHCP服务器在同一个物理网段，则客户端可以正确地获取到动态分配的IP地址。如果不在同一个物理网段，则需要DHCP中继代理。在配置了DHCP中继地址的前提下，如果交换机从客户端收到了一个广播DHCP请求，则会以单播的形式将这一请求转发至ip helper-address命令中定义的IP地址。配置了DHCP中继特性的交换机会在DHCP客户端与DHCP服务器之间中继DHCP会话。在交换机收到了数据包后，会确保服务器分配的IP地址属于客户端所在的子网。 拓扑如下所示，配置PC1和PC2自动获取IP地址 将PC1和PC2划分入对应的VLAN 1234567SW(config)#vlan 10,20SW(config)#int e0/0SW(config-if)#switchport mode access SW(config-if)#switchport access vlan 10SW(config)#int e0/1SW(config-if)#switchport mode access SW(config-if)#switchport access vlan 20 将SW的e0/2端口配置成三层端口，并配置IP地址 123SW(config)#int e0/2SW(config-if)#no switchport SW(config-if)#ip address 12.12.12.2 255.255.255.0 在DHCP_Srv上配置DHCP地址池 1234567891011121314151617//配置服务器e0/0接口的IP地址DHCP_Srv(config)#int e0/0DHCP_Srv(config-if)#ip address 12.12.12.1 255.255.255.0DHCP_Srv(config-if)#no shutdown //开启DHCP功能（默认开启）DHCP_Srv(config)#service dhcp //创建地址池VLAN10，指定地址池范围和默认网关DHCP_Srv(config)#ip dhcp pool VLAN10DHCP_Srv(dhcp-config)#network 192.168.10.0 255.255.255.0DHCP_Srv(dhcp-config)#default-router 192.168.10.254//创建地址池VLAN20，指定地址池范围和默认网关DHCP_Srv(config)#ip dhcp pool VLAN20DHCP_Srv(dhcp-config)#network 192.168.20.0 255.255.255.0DHCP_Srv(dhcp-config)#default-router 192.168.20.254//将地址池中已用的IP地址排除DHCP_Srv(config)#ip dhcp excluded-address 192.168.10.254DHCP_Srv(config)#ip dhcp excluded-address 192.168.20.254 在SW上进行SVI配置，并指定中继地址 12345678SW(config)#int vlan 10SW(config-if)#ip address 192.168.10.254 255.255.255.0SW(config-if)#no shutdown SW(config-if)#ip helper-address 12.12.12.1SW(config)#int vlan 20SW(config-if)#ip address 192.168.20.254 255.255.255.0SW(config-if)#no shutdown SW(config-if)#ip helper-address 12.12.12.1 配置路由协议使网络可达 123456789SW(config)#router ospf 1SW(config-router)#router-id 2.2.2.2SW(config-router)#network 12.12.12.0 0.0.0.255 area 0SW(config-router)#network 192.168.10.0 0.0.0.255 area 0SW(config-router)#network 192.168.20.0 0.0.0.255 area 0DHCP_Srv(config)#router ospf 1DHCP_Srv(config-router)#router-id 1.1.1.1DHCP_Srv(config-router)#network 12.12.12.0 0.0.0.255 area 0 PC1和PC2自动获取IP地址 123456789PC1(config)#int e0/0PC1(config-if)#no shutdown PC1(config-if)#ip address dhcp*Nov 10 04:54:04.732: %DHCP-6-ADDRESS_ASSIGN: Interface Ethernet0/0 assigned DHCP address 192.168.10.1, mask 255.255.255.0, hostname PC1PC2(config)#int e0/0PC2(config-if)#no shutdown PC2(config-if)#ip address dhcp*Nov 10 04:54:34.798: %DHCP-6-ADDRESS_ASSIGN: Interface Ethernet0/0 assigned DHCP address 192.168.20.1, mask 255.255.255.0, hostname PC2 查看DHCP地址池和DHCP绑定表","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DHCP","slug":"DHCP","permalink":"http://shain.top/tags/DHCP/"},{"name":"DHCP中继","slug":"DHCP中继","permalink":"http://shain.top/tags/DHCP%E4%B8%AD%E7%BB%A7/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2020-10-15T12:01:34.000Z","updated":"2020-11-15T05:29:33.748Z","comments":true,"path":"2020/10/15/Linux常用命令/","link":"","permalink":"http://shain.top/2020/10/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一、命令基本格式1、命令提示符 1[shain-l@study ~]$ []：这是提示符的分隔符号，没有特殊含义 shain-l：显示的是当前的登录用户，如上所示的用户为shain-l @：分隔符号，没有特殊含义 study：当前系统的简写主机名 ~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录 $：命令提示符，普通用户是$，超级用户是# 1234#命令提示符的显示形式可以通过修改变量PS1来自定义，若想永久修改提示符，则需修改/etc/bashrc文件中PS1变量的内容#默认情况下，显示的格式为[当前用户@简写主机名 当前所在目录的最后一个目录]$ [shain-l@study ~]$ echo $PS1[\\u@\\h \\W]\\$ 2、命令的基本格式 1[root@study ~]# 命令 [选项] [参数] 选项：用于调整命令的功能 参数：命令的操作对象，如果省略参数则使用默认参数 二、目录操作命令1、ls命令 英文原意：list directory contents 所在路径：/usr/bin/ls 执行权限：所有用户 功能描述：显示目录下的内容 1234567[root@study ~]# ls [选项] [文件名或目录名]选项： -a 显示出所有文件（包括隐藏文件） -d 显示目录信息，而不是目录下的文件 -h 人性化显示，按照我们习惯的单位显示文件大小 -i 显示inode号码 -l 长格式显示，显示详细信息 示例 123456789101112131415161718192021222324252627282930#使用ls命令查看test目录下的文件[root@study test]# lstest1 test2 test3 test_dir#添加-a选项，查看的内容包括隐藏文件[root@study test]# ls -a. .. test1 test2 test3 test_dir#添加-l参数，显示详细信息，包括文件的属性与权限等数据[root@study test]# ls -ltotal 80-rw-r--r--. 1 root root 9240 Oct 16 13:57 test1-rw-r--r--. 1 root root 63504 Oct 16 13:57 test2-rw-r--r--. 1 root root 6 Oct 16 13:57 test3drwxr-xr-x. 2 root root 6 Oct 16 13:58 test_dir#添加-h选项，将文件容量以人类较易读的方式显示，其中ls -l可以使用ll替代[root@study test]# ll -htotal 80K-rw-r--r--. 1 root root 9.1K Oct 16 13:57 test1-rw-r--r--. 1 root root 63K Oct 16 13:57 test2-rw-r--r--. 1 root root 6 Oct 16 13:57 test3drwxr-xr-x. 2 root root 6 Oct 16 13:58 test_dir#添加-i参数，列出文件的inode号码[root@study test]# ll -itotal 8027407027 -rw-r--r--. 1 root root 9240 Oct 16 13:57 test127407026 -rw-r--r--. 1 root root 63504 Oct 16 13:57 test227407023 -rw-r--r--. 1 root root 6 Oct 16 13:57 test3 4258 drwxr-xr-x. 2 root root 6 Oct 16 13:58 test_dir#添加-d参数，用于显示目录信息[root@study test]# ll -d test_dir/drwxr-xr-x. 2 root root 6 Oct 16 13:58 test_dir/ ls -l 输出内容各字段含义 123[root@study test]# lltotal 80-rw-r--r--. 1 root root 9240 Oct 16 13:57 test1 第一列：文件类型与权限 第二列：链接数 第三列：文件所属主 第四列：文件所属组 第五列：文件大小 第六列：文件最后修改时间 第七列：文件名 2、cd命令 英文原意：change directory 所在路径：Shell内置命令 执行权限：所有用户 功能描述：切换所在目录 特殊目录 特殊符号 作用 . 代表此层目录 .. 代表上一层目录 - 代表前一个工作目录 ~ 代表目前使用者身份所在的家目录 ~shain-l 代表shain-l这个使用者的家目录（shain-l是个账号名称） 示例 12345678910111213#切换工作目录到test_dir[root@study test]# cd test_dir/[root@study test_dir]##切换到上级目录[root@study test_dir]# cd ..[root@study test]##切换到当前用户的家目录，cd命令等价于cd ~[root@study test]# cd[root@study ~]##使用-可以切换到前一个工作目录[root@study test]# cd /tmp[root@study tmp]# cd -/root/test 绝对路径与相对路径 绝对路径：路径的写法一定由根目录/写起，一级一级进入目录，如&quot;/usr/share/doc&quot; 相对路径：以当前目录作为参照物，进行目录查找。例如由 /usr/share/doc 要到 /usr/share/man 下时，可以写成&quot;cd ../man&quot; 3、pwd命令 英文原意：print name of current/working directory 所在路径：/usr/bin/pwd 执行权限：所有用户 功能描述：显示目前所在的目录 123[root@study ~]# pwd [-P]选项与参数： -P：显示出真正的路径，而非使用链接路径 示例 123456789101112131415#显示目前的工作目录[root@study ~]# pwd/root#查看/var/mail和/var/spool/mail两个目录的详细信息，可知/var/mail链接到/var/spool/mail[root@study var]# ll -d mail spool/maillrwxrwxrwx. 1 root root 10 Aug 9 2019 mail -&gt; spool/maildrwxrwxr-x. 2 root mail 44 Oct 15 16:55 spool/mail#切换工作目录到/var/mail下[root@study var]# cd mail#列出目前工作目录[root@study mail]# pwd/var/mail#添加-P后，显示的是实际的工作目录，而非链接文件本身的目录名[root@study mail]# pwd -P/var/spool/mail 4、mkdir命令 英文原意：make directories 所在路径：/usr/bin/mkdir 执行权限：所有用户 功能描述：创建新目录 1234[root@study ~]# mkdir [选项] 目录名选项： -p：递归创建所需目录 -m：设置文件的权限。直接设置，不使用默认权限（umask） 示例 123456789101112#使用-p选项递归创建目录[root@study test]# mkdir -p s/sh/sha/shai/shain[root@study test]# cd s/sh/sha/shai/shain/[root@study shain]# pwd/root/test/s/sh/sha/shai/shain#查看目录s的权限，为rwxr-xr-x，这是系统的默认属性，因为root的umask为022[root@study test]# ll -d sdrwxr-xr-x. 3 root root 16 Oct 16 14:54 s#使用-m选项设置所创建的目录的权限为rwx--x--x[root@study test]# mkdir -m 711 shain[root@study test]# ll -d shaindrwx--x--x. 2 root root 6 Oct 16 14:58 shain 5、rmdir命令 英文原意：remove empty directories 所在路径：/usr/bin/rmdir 执行权限：所有用户 功能描述：删除空目录 123[root@study ~]# rmdir [-p] 目录名选项： -p：递归删除空目录 示例 12345678#查看shain目录下的文件，可知存在一个名为text的文件[root@study test]# ls shain/text#使用rmdir命令删除目录shain，提示无法删除，因为该目录不为空[root@study test]# rmdir shain/rmdir: failed to remove ‘shain/’: Directory not empty#使用-p选项递归删除之前创建的空目录s/sh/sha/shai/shain[root@study test]# rmdir -p s/sh/sha/shai/shain/ 由于rmdir只能用于删除空目录，即被删除的目录中不能存在其他的目录或文件，所以一般使用rm命令删除文件或目录。 三、文件操作命令1、touch命令 英文原意：change file timestamps 所在路径：/usr/bin/touch 执行权限：所有用户 功能描述：修改文件的时间戳 1234567[root@study ~]# touch [选项] 文件选项： -a：仅自定义access time -c：仅修改文件的时间，若该文件不存在则不建立新文件 -d：后面可以接欲自定义的日期而不用目前的日期，也可以使用--date=&quot;日期或时间&quot; -m：仅修改mtime -t：后面可以接欲自定义的时间而不用目前的时间，格式为[YYYYMMDDhhmm] 三个时间参数 修改时间(modification time, mtime) 当文件的内容数据变更时，会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限 状态时间(status time, ctime) 当该文件的状态改变时，就会更新这个时间，例如权限与属性被更改了，就会更新这个时间 读取时间(access time, atime) 当该文件的内容被读取时，就会更新这个读取时间，例如使用cat命令读取文件，则会更新该文件的atime 示例 12345678910111213141516171819202122232425262728293031323334#创建一个新文件，名称为time[root@study test]# touch time#查看当前时间和该文件的三个时间[root@study test]# date; ll time; ll --time=ctime time; ll --time=atime timeFri Oct 16 15:47:28 CST 2020 #当前时间-rw-r--r--. 1 root root 0 Oct 16 15:47 time #mtime-rw-r--r--. 1 root root 0 Oct 16 15:47 time #ctime-rw-r--r--. 1 root root 0 Oct 16 15:47 time #atime#默认ll显示出来的是文件的mtime，即该文件内容上次被修改的时间#向该文件中输入内容[root@study test]# echo &quot;testtest&quot; &gt;&gt; time#此时文件内容被修改，该文件的mtime与ctime都发生了改变，由于为读取过文件内容，故atime不变[root@study test]# date; ll time; ll --time=ctime time; ll --time=atime timeFri Oct 16 15:48:34 CST 2020-rw-r--r--. 1 root root 9 Oct 16 15:48 time #mtime-rw-r--r--. 1 root root 9 Oct 16 15:48 time #ctime-rw-r--r--. 1 root root 9 Oct 16 15:47 time #atime#使用cat命令访问该文件[root@study test]# cat timetesttest#此时atime发生了改变[root@study test]# date; ll time; ll --time=ctime time; ll --time=atime timeFri Oct 16 15:50:24 CST 2020-rw-r--r--. 1 root root 9 Oct 16 15:48 time #mtime-rw-r--r--. 1 root root 9 Oct 16 15:48 time #ctime-rw-r--r--. 1 root root 9 Oct 16 15:50 time #atime#使用chmod命令修改该文件的权限[root@study test]# chmod 755 time#此时该文件的权限发生了改变，故ctime也对应进行更新[root@study test]# date; ll time; ll --time=ctime time; ll --time=atime timeFri Oct 16 15:51:33 CST 2020-rwxr-xr-x. 1 root root 9 Oct 16 15:48 time #mtime-rwxr-xr-x. 1 root root 9 Oct 16 15:51 time #ctime-rwxr-xr-x. 1 root root 9 Oct 16 15:50 time #atime 2、stat命令 英文原意：display file or file system status 所在路径：/usr/bin/stat 执行权限：所有用户 功能描述：显示文件或文件系统的详细信息 12345678910[root@study test]# stat time File: ‘time’ Size: 9 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 27407015 Links: 1Access: (0755/-rwxr-xr-x) Uid: ( 0/ root) Gid: ( 0/ root)Context: unconfined_u:object_r:admin_home_t:s0Access: 2020-10-16 15:50:20.276058996 +0800Modify: 2020-10-16 15:48:32.567058143 +0800Change: 2020-10-16 15:51:31.239059558 +0800 Birth: - 3、cat命令 英文原意：concatenate files and print on the standard output 所在路径：/usr/bin/cat 执行权限：所有用户 功能描述：合并文件并打印输出到标准输出 12345678[root@study ~]# cat [选项] 文件名选项： -A：相当于-vET的整合选项，用于列出一些特殊字符 -b：列出行号，仅针对非空白行做行号显示，空白行不标行号 -E：列出每行结尾的回车符$ -n：显示行号，连同空白行也会有行号 -T：把Tab键用^I显示出来 -v：列出特殊字符 示例 123456789101112131415#查看/etc/issue这个文件的内容[root@study ~]# cat /etc/issue\\SKernel \\r on an \\m#添加-n选项显示行号[root@study ~]# cat -n /etc/issue 1 \\S 2 Kernel \\r on an \\m 3#添加-A选项，显示特殊字符[root@study test]# cat -A timetesttest$tt^Iee$sstt$sha$ 4、more命令 英文原意：file perusal filter for crt viewing 所在路径：/usr/bin/more 执行权限：所有用户 功能描述：分屏显示文件内容 more命令中常用的交互命令 空格键(space)：代表向下翻一页 Enter：代表向下翻一行 /字符串：代表在这个显示的内容中，向下查找字符串这个关键词 q：退出 b：向上翻页，此操作只对文件有用，对管道无用 5、less命令 英文原意：opposite of more 所在路径：/usr/bin/less 执行权限：所有用户 功能描述：分行显示文件内容 6、head命令 英文原意：output the first part of files 所在路径：/usr/bin/head 执行权限：所有用户 功能描述：显示文件开头的内容 1234[root@study ~]# head [选项] 文件名选项： -n 行数：从文件头开始，显示指定行数 -v：显示文件名 示例 1234567[root@study test]# head -n 5 -v head_test ==&gt; head_test &lt;==head head headhead head headhead head headhead head headhead head head 7、tail命令 英文原意：output the last part of files 所在路径：/usr/bin/tail 执行权限：所有用户 功能描述：显示文件结尾的内容 1234[root@study ~]# tail [选项] 文件名选项： -n 行数：从文件结尾开始，显示指定的行数 -f：监听文件的新增内容 示例 123456[root@study test]# tail -n 5 tail_test tail tail tailtail tail tailtail tail tailtail tail tailtail tail tail 8、ln命令 英文原意：make links between files 所在路径：/usr/bin/ln 执行权限：所有用户 功能描述：在文件之间建立链接 1234[root@study ~]# ln [选项] 源文件 目标文件选项： -s：建立软链接，即符号链接。若未添加-s选项，则建立硬链接 -f：强制建立链接。如果目标文件已经存在，则删除目标文件后再建立链接文件 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#首先查看ln_test文件的详细信息，可知链接数为1[root@study test]# ll -i ln_test 27407030 -rw-r--r--. 1 root root 120 Oct 16 17:00 ln_test#建立硬链接文件[root@study test]# ln /root/test/ln_test /tmp/ln_htest#查看两个文件的详细信息，可知具有相同的inode号码，并且两文件的链接数都为2[root@study test]# ll -i ln_test /tmp/ln_htest 27407030 -rw-r--r--. 2 root root 120 Oct 16 17:00 ln_test27407030 -rw-r--r--. 2 root root 120 Oct 16 17:00 /tmp/ln_htest#建立软链接[root@study test]# ln -s /root/test/ln_test /tmp/ln_stest#查看两个文件的详细信息，可知两文件的inode号码不同[root@study test]# ll -i ln_test /tmp/ln_stest 27407030 -rw-r--r--. 2 root root 120 Oct 16 17:00 ln_test16841412 lrwxrwxrwx. 1 root root 18 Oct 16 17:06 /tmp/ln_stest -&gt; /root/test/ln_test#查看ln_test文件的内容，并追加内容[root@study test]# cat ln_test ln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test test[root@study test]# echo &quot;modify&quot; &gt;&gt; ln_test #查看/tmp目录下的ln_htest和ln_stest两个链接文件的内容，可知都发生了改变[root@study test]# cat /tmp/ln_htest ln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test testmodify[root@study test]# cat /tmp/ln_stest ln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test testmodify#此时将ln_test文件删除[root@study test]# rm -f ln_test #查看/tmp目录下的两个链接文件的信息，其中软链接文件ln_stest出现错误，硬链接文件ln_htest正常且链接数变为1[root@study test]# ll /tmp/ln_htest /tmp/ln_stest -rw-r--r--. 1 root root 127 Oct 16 17:11 /tmp/ln_htestlrwxrwxrwx. 1 root root 18 Oct 16 17:06 /tmp/ln_stest -&gt; /root/test/ln_test[root@study test]# cat /tmp/ln_stest cat: /tmp/ln_stest: No such file or directory[root@study test]# cat /tmp/ln_htest ln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test testln ln lntest test testmodify 硬链接与软链接的特征 硬链接的特征 源文件和硬链接文件拥有相同的inode和block 修改任意一个文件，另一个都改变 删除任意一个文件，另一个都能使用 硬链接标记不清，很难确认硬链接文件位置，不建议使用 硬链接不能链接目录 硬链接不能跨分区 软链接的特征 软链接和源文件拥有不同的inode和block 两个文件修改任意一个，另一个都改变 删除软链接，源文件不受影响；删除源文件，软链接不能使用 软链接没有实际数据，只保存源文件的inode，不论源文件多大，软链接大小不变 软链接的权限是最大权限lrwxrwxrwx，但是由于没有实际数据，最终访问时需要参考源文件权限 软链接可以链接目录 软链接可以跨分区 软链接特征明显，建议使用软链接 四、目录和文件都能操作的命令1、rm命令 英文原意：remove files or directories 所在路径：/usr/bin/rm 执行权限：所有用户 功能描述：删除文件或目录 12345[root@study ~]# rm [选项] 文件或目录选项： -r：递归删除，可以删除目录 -f：强制删除 -i：交互删除，在删除之前会询问用户 示例 12345678#使用touch命令创建一个新文件[root@study test]# touch rm_test[root@study test]# lsrm_test test1 test2 test3#使用rm命令将其删除[root@study test]# rm -rf rm_test [root@study test]# lstest1 test2 test3 2、cp命令 英文原意：copy files and directories 所在路径：/usr/bin/cp 执行权限：所有用户 功能描述：复制文件和目录 12345678[root@study ~]# cp [选项] 源文件 目标文件选项： -a：相当于-dpr选项的集合 -d：若源文件为软链接，则复制出的目标文件也为软链接文件（对硬链接无效） -i：若目标文件已经存在，在复制时会先询问是否覆盖 -p：复制后的目标文件保留源文件的属性（包括权限，用户，时间等） -r：递归复制，用于目录的复制操作注意：如果源文件有两个以上，则最后一个目标文件一定要为&quot;目录&quot;才行 示例 123456789101112131415161718192021222324252627282930313233343536373839#查看test目录下的文件信息，其中cp_sln文件为链接文件，链接到该目录下的test1文件[root@study test]# lltotal 12lrwxrwxrwx. 1 root root 5 Oct 17 16:33 cp_sln -&gt; test1-rw-r--r--. 1 root root 9240 Oct 16 13:57 test1#使用cp命令复制链接文件cp_sln，添加-d选项，则目标文件cp1也为链接文件，同样连接到该目录下的test1文件[root@study test]# cp -d cp_sln cp1[root@study test]# ll cp1lrwxrwxrwx. 1 root root 5 Oct 17 16:35 cp1 -&gt; test1#若未添加-d选项，则复制出的目标文件为普通文件[root@study test]# cp cp_sln cp2[root@study test]# ll cp2-rw-r--r--. 1 root root 9240 Oct 17 16:37 cp2#添加-i选项，则当目标文件已存在时，复制时会先进行询问是否覆盖[root@study test]# cp -i test1 cp2cp: overwrite ‘cp2’? y[root@study test]# ll cp2-rw-r--r--. 1 root root 9240 Oct 17 16:39 cp2#由以上示例可以发现复制后的文件与源文件的属性/权限发生了改变，若想保留源文件的属性，则添加-p选项[root@study test]# cp -p test1 cp3[root@study test]# ll test1 cp3-rw-r--r--. 1 root root 9240 Oct 16 13:57 cp3-rw-r--r--. 1 root root 9240 Oct 16 13:57 test1#创建一个目录tes用于进行目录复制的测试[root@study test]# mkdir tes#未添加选项-r则无法进行目录的复制[root@study test]# cp tes cp_tescp: omitting directory ‘tes’#使用选项-r复制目录[root@study test]# cp -r tes cp_tes[root@study test]# ll -d tes cp_tes/drwxr-xr-x. 2 root root 42 Oct 17 16:50 cp_tes/drwxr-xr-x. 2 root root 42 Oct 17 16:49 tes#添加选项-a，相当于-dpr#将test1和cp_test文件一起复制到cp_dir目录下，因为添加了-a选项，所以目标文件保留源文件的属性[root@study test]# cp -a test1 cp_test cp_dir/[root@study test]# ll test1 cp_dir/test1 -rw-r--r--. 1 root root 9240 Oct 16 13:57 cp_dir/test1-rw-r--r--. 1 root root 9240 Oct 16 13:57 test1 3、mv命令 英文原意：move (rename) files 所在路径：/usr/bin/mv 执行权限：所有用户 功能描述：移动文件与目录，或重命名 12345[root@study ~]# mv [选项] 源文件 目标文件选项： -f：强制，如果目标文件已存在，则不会询问而直接覆盖 -i：如果目标文件已存在，则询问是否覆盖 -v：显示详细信息 示例 1234567891011121314#test目录下存在两个文件[root@study test]# lsmvtt test1#使用mv命令对mvtt文件进行重命名[root@study test]# mv -v mvtt shsh‘mvtt’ -&gt; ‘shsh’[root@study test]# lsshsh test1#将shsh文件移动到/tmp目录下[root@study test]# mv shsh /tmp/[root@study test]# lstest1[root@study test]# ll /tmp/shsh -rw-r--r--. 1 root root 9240 Oct 16 13:57 /tmp/shsh 五、权限基本管理1、权限 在使用ls命令时，可以通过添加-l选项来查看文件的详细信息，那么输出信息中的第一列(共10位)就表示文件的类型与权限 12[root@study test]# ll test1 -rw-r--r--. 1 root root 9240 Oct 16 13:57 test1 第1位——文件类型 “-“：普通文件 “d”：目录文件 “b”：块设备文件。存储设备即为块设备文件，如分区文件/dev/sda1 “c”：字符设备文件。输入设备一般都为这种文件，如鼠标、键盘等 “l”：链接文件 “p”：管道符文件 “s”：套接字文件。一些服务支持socket访问，就会产生这样的文件 接下来的字符中，以三个为一组，且均为[rwx]的三个参数的组合。如果没有权限，则会出现[-]。 第2~4位——文件所属主权限 r：代表可读(read) w：代表可写(write) x：代表可执行(execute) 第5~7位——文件所属组权限 第8~10位——其他人权限(此处其他人指既不属于文件所属主，也不属于文件所属组) 2、修改权限命令——chmod 英文原意：change file mode bits 所在路径：/usr/bin/chmod 执行权限：所有用户 功能描述：修改文件的权限模式 123456789101112131415161718192021222324[root@study ~]# chmod [选项] 权限模式 文件名选项： -R：递归设置权限，连同子目录下的所有文件都会修改此处的权限模式可以使用数字权限或用户身份权限来赋予 若使用用户身份，则： ----------- u：代表所属主 g：代表所属组 o：代表其他人 a：代表所有人 ----------- +：加入权限 -：减去权限 =：设置权限 ----------- r：读 w：写 x：执行 若使用数字权限，则： ----------- 4：代表r权限 2：代表w权限 1：代表x权限 ----------- 示例 123456[root@study test]# ll test1 -rw-r--r--. 1 root root 9240 Oct 16 13:57 test1#修改test1文件的权限为755，代表该文件所属主拥有读、写、执行权限；所属组和其他人拥有读和执行权限[root@study test]# chmod 755 test1 [root@study test]# ll test1 -rwxr-xr-x. 1 root root 9240 Oct 16 13:57 test1 3、目录与文件的权限意义 权限对文件的作用 r：对文件有读权限，代表可以读取文件中的数据。即可以使用cat、more、less、head、tail等命令读取文件。 w：对文件有写权限，代表可以修改文件中的数据。即可以使用echo、vim等命令修改文件中的数据。需要注意的是，虽然拥有文件的写权限，但这并不代表可以将文件删除。若想删除文件，则需要拥有该文件的上级目录的写权限。 x：对文件有执行权限，代表该文件具有可以被系统执行的权限。但是该文件是否能正确被执行，还需取决于文件中的代码是不是正确的。对于文件来说，x权限是最高权限。 权限对目录的作用 r：对目录有读权限，代表可以查看目录下的内容。即可以使用ls命令查看该目录下的子文件和子目录。 w：对目录有写权限，代表可以修改目录下的数据，也就是说可以在目录中新建、删除、复制、剪切子文件或子目录。即可以使用touch、cp、rm、mv等命令操作目录。对于目录来说，w权限是最高权限。 x：对目录有执行权限，代表可以进入目录。即可以使用cd命令进入目录。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#修改目录test的权限为000[shain-l@study ~]$ chmod 000 test/[shain-l@study ~]$ ll -d test/d---------. 2 shain-l shain-l 18 Oct 17 20:02 test/#此时使用ls命令和cd命令都被拒绝，因为没有读和执行权限[shain-l@study ~]$ ls test/ls: cannot open directory test/: Permission denied[shain-l@study ~]$ cd test/-bash: cd: test/: Permission denied#赋予该目录的所属主读的权限[shain-l@study ~]$ chmod 400 test/[shain-l@study ~]$ ll -d test/dr--------. 2 shain-l shain-l 18 Oct 17 20:02 test/#虽然具有读的权限，但因为无法进入目录，此时查看test目录下的内容还是会出错[shain-l@study ~]$ ll test/ls: cannot access test/file: Permission deniedtotal 0-????????? ? ? ? ? ? file#赋予该目录r和x的权限[shain-l@study ~]$ chmod 500 test/[shain-l@study ~]$ ll -d test/dr-x------. 2 shain-l shain-l 18 Oct 17 20:02 test/#此时可以查看该目录下的子文件和子目录，也可以进入该目录[shain-l@study ~]$ ll test/total 4----------. 1 shain-l shain-l 10 Oct 17 20:02 file[shain-l@study ~]$ cd test/[shain-l@study test]$#尝试将test目录下的文件重命名，操作被拒绝，因为没有test目录的写权限[shain-l@study test]$ mv file tttmv: cannot move ‘file’ to ‘ttt’: Permission denied#赋予test目录写的权限[shain-l@study ~]$ chmod 700 test/[shain-l@study ~]$ ll -d test/drwx------. 2 shain-l shain-l 18 Oct 17 20:02 test/#此时可以对test目录下的文件重命名[shain-l@study test]$ mv file ttt[shain-l@study test]$ lltotal 4----------. 1 shain-l shain-l 10 Oct 17 20:02 ttt#当前ttt文件的权限为000，即无法对该文件读、写、执行#使用cat命令读取该文件的内容，操作被拒绝[shain-l@study test]$ cat tttcat: ttt: Permission denied#向该文件中执行追加写操作也被拒绝[shain-l@study test]$ echo &quot;12345&quot; &gt;&gt; ttt-bash: ttt: Permission denied#赋予该文件读的权限，则可以读取该文件中的数据[shain-l@study test]$ chmod 400 ttt[shain-l@study test]$ ll ttt-r--------. 1 shain-l shain-l 10 Oct 17 20:02 ttt[shain-l@study test]$ cat ttttest;test#赋予该文件写的权限，则可以向该文件中写入数据[shain-l@study test]$ chmod 600 ttt[shain-l@study test]$ ll ttt-rw-------. 1 shain-l shain-l 10 Oct 17 20:02 ttt[shain-l@study test]$ echo &quot;12345&quot; &gt;&gt; ttt#赋予该文件执行的权限，则当该文件中的代码正确时，即可执行该文件[shain-l@study test]$ chmod 700 ttt[shain-l@study test]$ ll ttt-rwx------. 1 shain-l shain-l 16 Oct 17 20:21 ttt 4、所属主和所属组命令 chown命令 英文原意：change file owner and group 所在路径：/usr/bin/chown 执行权限：所有用户 功能描述：修改文件和目录的所属主和所属组 123456[root@study ~]# chown [选项] 所属主:所属组 文件或目录选项： -R：递归设置权限，也就是给子目录中的所有文件设置权限注意： 普通用户不能修改文件的所属主，即使自己就是该文件的所属主 普通用户可以修改所属主为自己的文件的权限 示例 1234567891011121314151617#使用root用户在/tmp目录下创建一个文件abc[root@study tmp]# touch abc#所创建的文件的所属主和所属组都为root[root@study tmp]# ll abc-rw-r--r--. 1 root root 0 Oct 17 23:35 abc#修改文件的所属主为shain-l[root@study tmp]# chown shain-l abc[root@study tmp]# ll abc-rw-r--r--. 1 shain-l root 0 Oct 17 23:35 abc#将文件的所属组也更改为shain-l[root@study tmp]# chown shain-l:shain-l abc#此时文件abc的所属主和所属组都为shain-l[root@study tmp]# ll abc-rw-r--r--. 1 shain-l shain-l 0 Oct 17 23:35 abc#使用shain-l用户登录，更改/tmp目录下的文件abc的所属主，提示操作被拒绝[shain-l@study tmp]$ chown test abcchown: changing ownership of ‘abc’: Operation not permitted chgrp命令 英文原意：change group ownership 所在路径：/usr/bin/chgrp 执行权限：所有用户 功能描述：修改文件和目录的所属组 示例 123456[root@study tmp]# ll abc-rw-rw-r--. 1 test shain-l 0 Oct 17 23:35 abc#修改文件abc的所属组为test[root@study tmp]# chgrp test abc [root@study tmp]# ll abc-rw-rw-r--. 1 test test 0 Oct 17 23:35 abc 5、umask默认权限 查看系统的默认umask权限 12345678910#root用户的默认权限为022[root@study ~]# umask0022[root@study ~]# umask -Su=rwx,g=rx,o=rx#普通用户的默认权限为002[shain-l@study ~]$ umask0002[shain-l@study ~]$ umask -Su=rwx,g=rwx,o=rx umask权限计算方法 对于文件来说，新建文件的默认最大权限为666，没有执行权限。因为执行权限对于文件来说比较危险，不能在新建文件的时候默认赋予，必须通过用户手工赋予。 对于目录来说，新建目录的默认最大权限为777。因为对于目录而言，执行权限意味着进入目录，并没有什么危险。 由于文件的默认最大权限为666，而root用户的umask的默认值为022，所以root用户在新建文件的时候，文件的默认权限为666扣除默认的所属组和其他人的写权限，即”-rw-rw-rw-“扣除”—–w–w-“，等于”-rw-r–r–”；而普通用户的umask的默认值为002，所以普通用户在新建文件的时候，文件的默认权限为666扣除默认的其他人的写权限，即”-rw-rw-rw-“扣除”——–w-“，等于”-rw-rw–r–” 123456[root@study tmp]# touch uma[root@study tmp]# ll uma-rw-r--r--. 1 root root 0 Oct 18 00:11 uma[shain-l@study tmp]$ touch umb[shain-l@study tmp]$ ll umb-rw-rw-r--. 1 shain-l shain-l 0 Oct 18 00:12 umb 同理，root用户创建目录时默认赋予的权限为”drwxr-xr-x”；普通用户创建目录时默认赋予的权限为”drwxrwxr-x” 123456[root@study tmp]# mkdir umadir[root@study tmp]# ll -d umadir/drwxr-xr-x. 2 root root 6 Oct 18 00:14 umadir/[shain-l@study tmp]$ mkdir umbdir[shain-l@study tmp]$ ll -d umbdir/drwxrwxr-x. 2 shain-l shain-l 6 Oct 18 00:15 umbdir/ 六、帮助命令1、man命令 英文原意：an interface to the on-line reference manuals 所在路径：/usr/bin/man 执行权限：所有用户 功能描述：显示联机帮助手册 1234[root@study ~]# man [选项] 命令选项： -f：查看命令拥有哪个级别的帮助 -k：查看和命令相关的所有帮助 示例 123456789101112131415161718[root@study ~]# man lsLS(1) User Commands LS(1)NAME ls - list directory contentsSYNOPSIS ls [OPTION]... [FILE]...DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with .……省略部分输出…… man命令快捷键 快捷键 作用 上箭头或k 向上移动一行 下箭头或j 向下移动一行 PgUp 向上翻页 PgDn 向下翻页 g 移动到第一页 G 移动到最后一页 q 退出 /字符串 从当前页向下搜索字符串 n 当搜索字符串时，可以使用n键找到下一个字符串 man命令的帮助级别 级别 作用 1 普通用户可以执行的系统命令和可执行文件的帮助 2 内核可以调用的函数和工具的帮助 3 C语言函数的帮助 4 设备和特殊文件的帮助 5 配置文件的帮助 6 游戏的帮助 7 杂项的帮助 8 超级用户可以执行的系统命令的帮助 9 内核的帮助 12345678910#使用 man -f 命令或 whatsis 命令查看命令拥有哪个级别的帮助[root@study ~]# man -f lsls (1) - list directory contentsls (1p) - list directory contents[root@study ~]# whatis passwdsslpasswd (1ssl) - compute password hashespasswd (1) - update user&#x27;s authentication tokenspasswd (5) - password file[root@study ~]# man -f ifconfigifconfig (8) - configure a network interface 2、info命令 info命令的帮助信息是一套完整的资料，每个单独命令的帮助信息只是这套完整资料中的某一个小章节。 快捷键 作用 上箭头 向上移动一行 下箭头 向下移动一行 PgUp 向上翻一页 PgDn 向下翻一页 Tab 在有”*”符号的节点间进行切换 回车 进入有”*”符号的子页面，查看详细帮助信息 u 进入上一层信息 n 进入下一小节信息 p 进入上一小节信息 ？ 查看帮助信息 q 退出info信息 3、help命令 help只能获取Shell内置命令的帮助，可以使用type命令来区分内置命令与外部命令 12345678910111213141516171819[root@study ~]# type catcat is /usr/bin/cat[root@study ~]# type helphelp is a shell builtin#使用help命令查看history命令的帮助[root@study ~]# help historyhistory: history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...] Display or manipulate the history list. Display the history list with line numbers, prefixing each modified entry with a `*&#x27;. An argument of N lists only the last N entries. Options: -c clear the history list by deleting all of the entries -d offset delete the history entry at offset OFFSET. -a append history lines from this session to the history file -n read all history lines not already read from the history file……省略部分输出…… 4、–help选项 绝大多数命令都可以使用”–help”选项来查看帮助 123456789101112131415[root@study ~]# ls --helpUsage: ls [OPTION]... [FILE]...List information about the FILEs (the current directory by default).Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE scale sizes by SIZE before printing them; e.g., &#x27;--block-size=M&#x27; prints sizes in units of 1,048,576 bytes; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ ……省略部分输出…… 七、搜索命令1、whereis命令 英文原意：locate the binary, source, and manual page files for a command 所在路径：/usr/bin/whereis 执行权限：所有用户 功能描述：查找二进制命令、源文件和帮助文档的命令 示例 1234[root@study ~]# whereis lsls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz[root@study ~]# whereis cdcd: /usr/bin/cd /usr/share/man/man1/cd.1.gz /usr/share/man/man1p/cd.1p.gz 注意：whereis命令不能用于搜索普通文件，只能搜索系统命令 2、which命令 英文原意：shows the full path of (shell) commands 所在路径：/usr/bin/which 执行权限：所有用户 功能描述：列出命令的所在路径 示例 12345678910#查找ifconfig命令的完整文件名[root@study ~]# which ifconfig/usr/sbin/ifconfig#查找ls命令的完整文件名，可知ls还存在别名[root@study ~]# which lsalias ls=&#x27;ls --color=auto&#x27; /usr/bin/ls#由于history为bash内置的命令，而which默认查找PATH内所设置的目录，所以无法查找到history命令所在路径[root@study ~]# which history/usr/bin/which: no history in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin) which命令是根据PATH变量所规范的路径来查找执行文件的。若添加-a选项，则可以列出所有的可以找到的同名执行文件。 whereis命令可以在找到二进制命令的同时，查找到帮助文档的位置 which命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。 3、locate命令 英文原意：find files by name 所在路径：/usr/bin/locate 执行权限：所有用户 功能描述：按照文件名搜索文件 123456[root@study ~]# locate [选项] 文件名或部分文件名选项： -c：不输出文件名，仅计算找到的数量 -i：忽略大小写的差异 -l：仅输出几行，如输出5行则是-l 5 -S：输出locate所使用的数据库文件的相关信息，包括该数据库记录的文件/目录数量等 示例 1234567891011121314151617#查找完整文件名中包含passwd的，添加-c选项，则仅计算找到的文件数量[root@study ~]# locate -c passwd135#查找完整文件名中包含passwd的，添加-l选项，指定仅列出5行[root@study ~]# locate -l 5 passwd/etc/passwd/etc/passwd-/etc/pam.d/passwd/etc/security/opasswd/usr/bin/gpasswd#列出locate查询所使用的数据库文件的文件名与各数据数量[root@study ~]# locate -SDatabase /var/lib/mlocate/mlocate.db: 13,632 directories #总记录目录数 154,711 files #总记录文件数 7,749,519 bytes in file names 3,567,270 bytes used to store database 使用locate命令查找数据特别快，这是因为locate寻找的数据是由已建立的数据库/var/lib/mlocate/里面的数据所查找到的，所以不用直接再去硬盘中读取数据。 默认情况下，CentOS 7.x每天更新一次数据库，所以在数据库更新前新建立的文件会查找不到。若想手动更新locate数据库，只需输入updatedb命令即可。updatedb命令会读取/etc/updatedb.conf这个配置文件的设置，然后再去硬盘中进行查找文件名的操作，最后更新整个数据库文件。 updatedb.conf配置文件 123456789[root@study ~]# vi /etc/updatedb.conf #开启搜索限制，让这个配置文件生效 PRUNE_BIND_MOUNTS = &quot;yes&quot; #在locate执行搜索时，禁止搜索这些文件系统类型 PRUNEFS = &quot;……&quot; #在locate执行搜索时，禁止搜索带有这些扩展名的文件 PRUNENAMES = &quot;……&quot; #在locate执行搜索时，禁止搜索这些系统目录 PRUNEPATHS = &quot;……&quot; updatedb：根据/etc/updatedb.conf的设置去查找系统硬盘内的文件，并更新/var/lib/mlocate内的数据库文件 locate：根据/var/lib/mlocate内的数据库记录，找出用户所输入关键词的文件名 4、find命令 英文原意：search for files in a directory hierarchy 所在路径：/usr/bin/find 执行权限：所有用户 功能描述：在目录中搜索文件 按照文件名搜索 12345[root@study ~]# find 搜索路径 [选项] 搜索内容选项： -name：按照文件名搜索 -iname：按照文件名搜索，不区分大小写 -inum：按照inode号搜素 示例 12345678910111213#查找test目录下的文件名为f1的文件所在路径[root@study test]# find . -name f1./tst/f1#使用-iname选项，则不会区分大小写[root@study test]# find -iname f1./tst/f1./tst/F1#查看文件f1的inode号码[root@study tst]# ll -i f14264 -rw-r--r--. 1 root root 0 Oct 18 14:51 f1#使用-inum选项，搜索inode号码为4264的文件[root@study test]# find . -inum 4264./tst/f1 按照文件大小搜索 12345[root@study ~]# find 搜索路径 [选项] 搜索内容选项： -size [+|-] 大小：按照指定大小搜索文件 &quot;+&quot;表示搜索比指定大小还要大的文件 &quot;-&quot;表示搜索比指定大小还要小的文件 示例 12345678910111213141516#tst目录下各文件的大小如下所示[root@study tst]# ll -htotal 3.7M-rw-r--r--. 1 root root 19K Oct 18 15:07 f1-rw-r--r--. 1 root root 218K Oct 18 15:08 F1-rw-r--r--. 1 root root 221 Oct 18 15:09 f2-rw-r--r--. 1 root root 871K Oct 18 15:08 g1-rw-r--r--. 1 root root 2.6M Oct 18 15:09 g2#搜索文件大小大于200k的文件(注意k为小写)[root@study tst]# find . -size +200k./F1./g1./g2#搜索文件大小大于2M的文件(注意M为大写)[root@study tst]# find . -size +2M./g2 按文件大小查找时单位如下所示（若指定大小后未跟上单位，则默认为b，即以512字节为单位） 按照修改时间搜索 12345[root@study ~]# find 搜索路径 [选项] 搜索内容选项： -atmie [+|-]时间：按照文件访问时间搜索 -mtime [+|-]时间：按照文件数据修改时间搜索 -ctime [+|-]时间：按照文件状态修改时间搜索 时间的含义（此处以mtime为例） -5：代表5天内修改的文件 5：代表前5~6天那一天修改的文件 +5：代表6天前修改的文件 示例 1234567891011#列出当前时间，并在当前目录下查找11天前修改过的文件[root@study shell]# date; find . -mtime +10Mon Oct 19 12:21:50 CST 2020./hello.sh./tar/hello.sh./tar/tar_2/hello.sh#查看使用find搜索到的以上文件的信息[root@study shell]# ll hello.sh tar/hello.sh tar/tar_2/hello.sh -rwxr-xr-x. 1 root root 83 Oct 7 18:37 hello.sh-rwxr-xr-x. 1 root root 83 Oct 7 18:37 tar/hello.sh-rwxr-xr-x. 1 root root 83 Oct 7 18:37 tar/tar_2/hello.sh 按照权限搜索 12345[root@study ~]# find 搜索路径 [选项] 搜索内容选项： -perm 权限模式：查找文件权限刚好等于&quot;权限模式&quot;的文件 -perm -权限模式：查找文件权限全部包含&quot;权限模式&quot;的文件 -perm /权限模式：查找文件权限包含&quot;权限模式&quot;的任意一个权限的文件 示例 1234567891011121314151617181920212223242526#在当前目录下查找权限模式为777的文件[root@study ~]# find . -perm 777./aab./aaaaaaa./te[root@study ~]# ll aab-rwxrwxrwx. 1 root root 23960 Oct 16 10:46 aab#在当前目录下查找权限模式包含775的文件[root@study ~]# find . -perm -775./aab./shell/parameter.sh./shell/tar/parameter.sh./shell/tar/tar_2/parameter.sh./aaaaaaa./te[root@study ~]# ll shell/parameter.sh -rwxrwxr-x. 1 root root 63 Oct 8 16:39 shell/parameter.sh#在当前目录下查找权限包含755的任意一个权限的文件，即搜索到的文件的所属主拥有读写执行权限或所属组拥有读和执行权限或其他人拥有读和执行权限都满足条件[root@study ~]# find . -perm /775../.bash_logout./.bash_profile./.cshrc./.tcshrc./anaconda-ks.cfg……省略部分输出…… 按照所有者和所属组搜索 1234567[root@study ~]# find 搜索路径 [选项] 搜索内容选项： -uid 用户ID：按照用户ID查找所属主是指定ID的文件 -gid 组ID：按照用户组ID查找所属组是指定ID的文件 -user 用户名：按照用户名查找所属主是指定用户的文件 -group 组名：按照组名查找所属组是指定用户组的文件 -nouser：查找没有所有者的文件 按照所有者和所属组查找时，”–nouser”选项比较常用，主要用于查找垃圾文件。 示例 12345#查找根目录下所属主是shain-l用户的文件，输出前三行[root@study ~]# find / -user shain-l | head -n 3/home/shain-l/home/shain-l/.mozilla/home/shain-l/.mozilla/extensions 按照文件类型搜索 12345[root@study ~]# find 搜索路径 [选项] 搜索内容选项： -type d：查找目录 -type f：查找普通文件 -type l：查找软链接文件 示例 1234567891011121314151617181920#查找当前目录下的软链接文件[root@study ~]# find . -type l./aaaaaaa./te#文件aaaaaaa和te都链接到文件abc[root@study ~]# ll aaaaaaa telrwxrwxrwx. 1 root root 3 Oct 17 14:36 aaaaaaa -&gt; abclrwxrwxrwx. 1 root root 3 Oct 17 14:36 te -&gt; abc#查找当前目录下的目录文件[root@study ~]# find . -type d../.cache./.cache/dconf./.cache/abrt./.dbus./.dbus/session-bus./.config./.config/abrt./test./test/tst 逻辑运算符 12345[root@study ~]# find 搜索路径 [选项] 搜索内容选项： -a： and 逻辑与 -o： or 逻辑或 -not： not 逻辑非 示例 123456789101112#搜索当前目录下文件大小大于10k并且文件类型为普通文件的文件[root@study ~]# find . -size +10k -a -type f./.bash_history./aab./test/tst/f1./test/tst/F1./test/tst/g1./test/tst/g2./.swp./.swo[root@study ~]# ll -h aab-rwxrwxrwx. 1 root root 24K Oct 16 10:46 aab 其他选项 -exec选项 将find命令的结果交给”-exec”调用的命令2处理。”{}”就代表find命令的查找结果 1[root@study ~]# find 搜索路径 [选项] 搜索内容 -exec 命令2 &#123;&#125; \\; 示例 12345678910#find命令搜索当前目录下文件大小大于10k的文件，并将其详细信息输出[root@study ~]# find . -size +10k -exec ls -lh &#123;&#125; \\;-rw-------. 1 root root 59K Oct 18 21:26 ./.bash_history-rwxrwxrwx. 1 root root 24K Oct 16 10:46 ./aab-rw-r--r--. 1 root root 19K Oct 18 15:07 ./test/tst/f1-rw-r--r--. 1 root root 218K Oct 18 15:08 ./test/tst/F1-rw-r--r--. 1 root root 871K Oct 18 15:08 ./test/tst/g1-rw-r--r--. 1 root root 2.6M Oct 18 15:09 ./test/tst/g2-rw-------. 1 root root 12K Oct 4 15:54 ./.swp-rw-------. 1 root root 12K Oct 4 15:54 ./.swo -ok选项 “-ok”选项和”-exec”选项的作用基本一致。区别在于”-exec”的命令2会直接处理，而不询问；”-ok”的命令2在处理前会询问用户是否进行该操作，在得到确认后才会执行 1234567891011121314151617[root@study ~]# find . -size +10k -ok ls -lh &#123;&#125; \\;&lt; ls ... ./.bash_history &gt; ? y-rw-------. 1 root root 59K Oct 18 21:26 ./.bash_history&lt; ls ... ./aab &gt; ? y-rwxrwxrwx. 1 root root 24K Oct 16 10:46 ./aab&lt; ls ... ./test/tst/f1 &gt; ? y-rw-r--r--. 1 root root 19K Oct 18 15:07 ./test/tst/f1&lt; ls ... ./test/tst/F1 &gt; ? y-rw-r--r--. 1 root root 218K Oct 18 15:08 ./test/tst/F1&lt; ls ... ./test/tst/g1 &gt; ? y-rw-r--r--. 1 root root 871K Oct 18 15:08 ./test/tst/g1&lt; ls ... ./test/tst/g2 &gt; ? y-rw-r--r--. 1 root root 2.6M Oct 18 15:09 ./test/tst/g2&lt; ls ... ./.swp &gt; ? y-rw-------. 1 root root 12K Oct 4 15:54 ./.swp&lt; ls ... ./.swo &gt; ? y-rw-------. 1 root root 12K Oct 4 15:54 ./.swo 5、grep命令 英文原意：print lines matching a pattern 所在路径：/usr/bin/grep 执行权限：所有用户 功能描述：在文件中提取和匹配符合条件的字符串行 123456[root@study ~]# grep [选项] &quot;搜索内容&quot; 文件名选项： -i：忽略大小写 -n：输出行号 -v：反向查找 --color=auto：搜索出的关键字用颜色显示 示例 1234567#搜索光盘中带有httpd的rpm包[root@study ~]# ls /mnt/cdrom/Packages/ | grep httpdhttpd-2.4.6-88.el7.centos.x86_64.rpmhttpd-devel-2.4.6-88.el7.centos.x86_64.rpmhttpd-manual-2.4.6-88.el7.centos.noarch.rpmhttpd-tools-2.4.6-88.el7.centos.x86_64.rpmlibmicrohttpd-0.9.33-2.el7.x86_64.rpm find命令用于在系统中搜索符合条件的文件名。如需模糊查询，则使用通配符进行匹配(通配符是完全匹配)。 grep命令用于在文件中搜索符合条件的字符串。如需模糊查询，则使用正则表达式进行匹配(正则表达式是包含匹配)。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://shain.top/categories/Linux/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"http://shain.top/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"重分布引起的路由环路问题","slug":"重分布引起的路由环路问题","date":"2020-09-27T05:57:54.000Z","updated":"2020-09-30T15:48:58.416Z","comments":true,"path":"2020/09/27/重分布引起的路由环路问题/","link":"","permalink":"http://shain.top/2020/09/27/%E9%87%8D%E5%88%86%E5%B8%83%E5%BC%95%E8%B5%B7%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98/","excerpt":"","text":"1、环境介绍 如下图所示，左边部分运行OSPF，右边部分运行RIP，在R5上启用一个回环口并将其通告进RIP中，在R2和R6上进行重分布 在R2上将RIP重分布进OSPF，在R6上将OSPF重分布进RIP 12345R2(config)#router ospf 1R2(config-router)#redistribute rip subnetsR6(config)#router ripR6(config-router)#redistribute ospf 1 metric 1 //指定跳数为1 将R5上的回环口通告进RIP 12R5(config)#router ripR5(config-router)#network 5.5.5.0 2、产生环路 在R1上跟踪到达R5所经过的路径，产生了环路（R1→R2→R3→R6→R1……） 12345678910111213141516R1#traceroute 5.5.5.5 numeric Type escape sequence to abort.Tracing the route to 5.5.5.5VRF info: (vrf in name/id, vrf out name/id) 1 12.12.12.2 0 msec 0 msec 0 msec 2 23.23.23.3 0 msec 1 msec 0 msec 3 36.36.36.6 1 msec 0 msec 1 msec 4 16.16.16.1 0 msec 1 msec 0 msec 5 12.12.12.2 1 msec 0 msec 0 msec 6 23.23.23.3 1 msec 1 msec 3 msec 7 36.36.36.6 1 msec 1 msec 0 msec 8 16.16.16.1 1 msec 1 msec 1 msec 9 12.12.12.2 0 msec 1 msec 1 msec …… …… …… 3、分析 查看R4的路由表 R4从R5上学习到5.5.5.0/24的路由条目，AD值为120，cost值为1，下一跳为45.45.45.5 1234R4#show ip route //省略部分输出 5.0.0.0/24 is subnetted, 1 subnetsR 5.5.5.0 [120/1] via 45.45.45.5, 00:00:11, Ethernet0/1 查看R3的路由表 R3本应从R4上学习到5.5.5.0/24的路由条目，此时的下一跳却为R6。 分析：若R3从R4上学习5.5.5.0/24的路由，则跳数为2。由于在R6上进行了重分布，将OSPF重分布进RIP时指定了跳数为1，所以在相同协议条件下，优先选择cost值小的，因此R3会选择R6去往5.5.5.0/24网段 1234R3#show ip route //省略部分输出 5.0.0.0/24 is subnetted, 1 subnetsR 5.5.5.0 [120/1] via 36.36.36.6, 00:00:03, Ethernet0/2 查看R2的路由表 显示下一跳为R3，cost值为2 1234R2#show ip route//省略部分输出 5.0.0.0/24 is subnetted, 1 subnetsR 5.5.5.0 [120/2] via 23.23.23.3, 00:00:12, Ethernet0/1 查看R1的路由表 显示下一跳为R2：R2将RIP重分布进了OSPF中，未指定类型，则默认为O E2，传递过程中保持cost值为20 1234R1#show ip route ///省略部分输出/// 5.0.0.0/24 is subnetted, 1 subnetsO E2 5.5.5.0 [110/20] via 12.12.12.2, 00:32:42, Ethernet0/0 查看R6路由表 R6从R1上学习到5.5.5.0/24的路由条目 1234R6#show ip route //省略部分输出 5.0.0.0/24 is subnetted, 1 subnetsO E2 5.5.5.0 [110/20] via 16.16.16.1, 00:32:57, Ethernet0/0 分析总结：R4从R5上学习到了5.5.5.0/24的路由条目，并将其通告给R3，R3此时若通过R4访问5.5.5.5/24，则开销值为2。R3再将自身的路由信息通告给R2和R6，则此时R2和R6到达5.5.5.5/24的开销值都为3，并且管理距离都为120。在R2上将RIP重分布进OSPF，此时R1通过R2学习到的去往5.5.5.0/24的路由的管理距离为110，开销为20。R6与R1建立了OSPF邻居关系，则R6将会从R1上再次学习到5.5.5.0/24的路由条目，此时R6通过两种路由协议学习到了到达同一目的的路由，则会比较管理距离，最后R6选择通过R1去往5.5.5.0/24网段，因为OSPF的管理距离为110，小于RIP的120，所以在R6的路由表上显示的到达5.5.5.0的路由类型为O E2。R6上又将OSPF重分布进了RIP中，并且指定了开销值为1，此时R3通过同种路由协议学习到了到达同一目的地址的路由，会比较开销，最终选择通过R6去往5.5.5.0/24，因为R6告诉R3去往该网段的开销为1。最终，导致了环路的形成。 4、问题解决 【解决措施1】修改跳数——在R6上将OSPF重分布进RIP时将跳数设置为大于2 12R6(config)#router ripR6(config-router)#redistribute ospf 1 metric 3 查看R3的路由表，可知此时通过R4去往5.5.5.0/24网段 在R1上跟踪路由，问题解决 【解决措施2】使用分发列表过滤，在R3上将R6传过来的5.5.5.0/24的路由进行过滤 1234R3(config)#access-list 1 deny 5.5.5.0 /24R3(config)#access-list 1 permit any R3(config)#router ripR3(config-router)#distribute-list 1 in e0/2 查看R3的路由表，可知此时通过R4去往5.5.5.0/24网段 在R1上跟踪路由，问题解决 【解决措施3】针对特定的通告者修改管理距离——把从R6学习到的5.5.5.0/24的路由的AD值改为大于120 1234R3(config)#access-list 1 permit 5.5.5.0 /24R3(config)#router rip//针对R6通告的并被ACL 1匹配到的路由，将其管理距离更改为130R3(config-router)#distance 130 36.36.36.6 0.0.0.0 1 查看R3的路由表，可知此时通过R4去往5.5.5.0/24网段 在R1上跟踪路由，问题解决 【解决措施4】使用前缀列表匹配，并用分发列表过滤 1234567//使用前缀列表拒绝5.5.5.0/24R3(config)#ip prefix-list a deny 5.5.5.0/24//前缀列表允许剩下的所有路由R3(config)#ip prefix-list a permit 0.0.0.0/0 le 32R3(config)#router rip//使用分发列表调用前缀列表R3(config-router)#distribute-list prefix a in e0/2 查看R3的路由表，可知此时通过R4去往5.5.5.0/24网段 在R1上跟踪路由，问题解决 【解决措施5】在R6的out方向调用分发列表 12345R6(config)#access-list 1 deny 5.5.5.0 /24R6(config)#access-list 1 permit any R6(config)#router rip//将ospf重分布进RIP时，只有被ACL 1允许的才会进行重分布R6(config-router)#distribute-list 1 out ospf 1 查看R3的路由表，可知此时通过R4去往5.5.5.0/24网段 在R1上跟踪路由，问题解决 【解决措施6】使用偏移列表（只针对距离矢量有意义） 1234R6(config)#access-list 1 permit 5.5.5.0 /24R6(config)#router rip//针对被ACL 1匹配到的路由，对其跳数进行偏移2，即此时R3从R6上学习到的5.5.5.0/24的路由的跳数为3R6(config-router)#offset-list 1 out 2 e0/1 查看R3的路由表，可知此时通过R4去往5.5.5.0/24网段 在R1上跟踪路由，问题解决","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"重分布","slug":"重分布","permalink":"http://shain.top/tags/%E9%87%8D%E5%88%86%E5%B8%83/"}]},{"title":"生成树综合测试","slug":"生成树综合测试","date":"2020-09-26T11:51:26.000Z","updated":"2020-09-27T05:57:04.714Z","comments":true,"path":"2020/09/26/生成树综合测试/","link":"","permalink":"http://shain.top/2020/09/26/%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95/","excerpt":"","text":"1、实验目的1）掌握RSTP的配置与检验2）掌握MST的配置与检验3）掌握生成树特性的应用4）实现VLAN间的通信 2、拓扑结构 3、实验步骤1、在该园区网络中有4个VLAN，VLAN 10、VLAN 20、VLAN 30、VLAN 40，要求在DSW1上创建这些VLAN，其他交换机同步DSW1上的VLAN信息，并且设置VTP域名为shain.top，VTP密码为shain，所有TRUNK链路全部采用标准的封装模式 在DSW1上创建4个vlan 1DSW1(config)#vlan 10,20,30,40 将交换机之间的端口配置成trunk，采用标准的封装模式 12345678910111213141516171819DSW1(config)#int range e0/0-3DSW1(config-if-range)#switchport trunk encapsulation dot1q DSW1(config-if-range)#switchport mode trunk DSW1(config-if-range)#switchport nonegotiate DSW2(config)#int range e0/0-3DSW2(config-if-range)#switchport trunk encapsulation dot1q DSW2(config-if-range)#switchport mode trunk DSW2(config-if-range)#switchport nonegotiate ASW1(config)#int range e0/2-3ASW1(config-if-range)#switchport trunk encapsulation dot1q ASW1(config-if-range)#switchport mode trunk ASW1(config-if-range)#switchport nonegotiate ASW2(config)#int range e0/2-3ASW2(config-if-range)#switchport trunk encapsulation dot1q ASW2(config-if-range)#switchport mode trunk ASW2(config-if-range)#switchport nonegotiate 在DSW1上设置VTP域名为shain.top，密码为shain，模式为server 123456789101112DSW1(config)#vtp domain shain.topDSW1(config)#vtp password shainDSW1(config)#vtp mode server DSW2(config)#vtp password shainDSW2(config)#vtp mode client ASW1(config)#vtp password shainASW1(config)#vtp mode client ASW2(config)#vtp password shainASW2(config)#vtp mode client 查看DSW2的VTP状态和VLAN信息，可知已和DSW1进行同步 2、DSW1与DSW2之间的链路不足以传递园区内部流量，使用合适的方式建立DSW1与DSW2之间的以太通道链路 在DSW1和DSW2之间配置EtherChannel 12345DSW1(config)#int range e0/2-3DSW1(config-if-range)#channel-group 1 mode active DSW2(config)#int range e0/2-3DSW2(config-if-range)#channel-group 1 mode active 查看EtherChannel的摘要信息 3、要求全网启用基于802.1w标准的生成树，并且实现DSW1为VLAN 10和VLAN 20的主根，为VLAN 30和VLAN 40的次根，实现DSW2为VLAN 10和VLAN 20的次根，为VLAN 30和VLAN 40的主根，并且哪怕将来在接入层中有新的交换机添加进园区网络，也要确保这两台交换机的地位 配置生成树的模式为rapid-pvst 1234DSW1(config)#spanning-tree mode rapid-pvst DSW2(config)#spanning-tree mode rapid-pvst ASW1(config)#spanning-tree mode rapid-pvst ASW2(config)#spanning-tree mode rapid-pvst 指定DSW1为vlan10,20的主根，为vlan30,40的次根；指定DSW2为vlan30,40的主根，为vlan10,20的次根 12345DSW1(config)#spanning-tree vlan 10,20 root primary DSW1(config)#spanning-tree vlan 30,40 root secondary DSW2(config)#spanning-tree vlan 10,20 root secondary DSW2(config)#spanning-tree vlan 30,40 root primary 在DSW1和DSW2上开启Root Guard特性，保证根桥的地位 12345DSW1(config)#int range e0/0-3,e1/0-3DSW1(config-if-range)#spanning-tree guard root DSW2(config)#int range e0/0-3DSW2(config-if-range)#spanning-tree guard root 以下进行验证测试 将ASW1的VLAN 10的生成树优先级设置为4096 1ASW1(config)#spanning-tree vlan 10 priority 4096 此时DSW1和DSW2上提示将e0/0端口阻塞 12345DSW1#*Sep 26 12:45:29.545: %SPANTREE-2-ROOTGUARD_BLOCK: Root guard blocking port Ethernet0/0 on VLAN0010.DSW2#*Sep 26 12:45:29.545: %SPANTREE-2-ROOTGUARD_BLOCK: Root guard blocking port Ethernet0/0 on VLAN0010. DSW1仍然认为自己是VLAN 10的根桥，e0/0端口的状态为根不一致 DSW2仍然认为DSW1为VLAN 10的根桥，并且e0/0端口的状态也为根不一致 将ASW1的VLAN 10的生成树优先级恢复，则日志提示不再阻塞e0/0端口 DSW1由于不再监听到比自己更优的BPDU，自动恢复成根桥 1234567ASW1(config)#spanning-tree vlan 10 priority 32768DSW1#*Sep 26 12:57:16.983: %SPANTREE-2-ROOTGUARD_UNBLOCK: Root guard unblocking port Ethernet0/0 on VLAN0010.DSW2#*Sep 26 12:57:16.976: %SPANTREE-2-ROOTGUARD_UNBLOCK: Root guard unblocking port Ethernet0/0 on VLAN0010. 4、按如下表所示为各PC配置IP地址和网关，并在交换机上将PC划分到相应的VLAN中 设备 VLAN IP地址 默认网关 PC1 10 192.168.10.100 192.168.10.254 PC2 20 192.168.20.100 192.168.20.254 PC3 30 192.168.30.100 192.168.30.254 PC4 40 192.168.40.100 192.168.40.254 为各PC设置IP地址和网关 123456789101112131415PC1(config)#int e0/0PC1(config-if)#ip address 192.168.10.100 255.255.255.0PC1(config-if)#no shutdownPC2(config)#int e0/0PC2(config-if)#ip address 192.168.20.100 255.255.255.0PC2(config-if)#no shutdownPC3(config)#int e0/0PC3(config-if)#ip address 192.168.30.100 255.255.255.0PC3(config-if)#no shutdownPC4(config)#int e0/0PC4(config-if)#ip address 192.168.40.100 255.255.255.0PC4(config-if)#no shutdown 在ASW1和ASW2上将端口划分到对应的VLAN中 12345678910111213ASW1(config)#int e0/0ASW1(config-if)#switchport mode accessASW1(config-if)#switchport access vlan 10ASW1(config)#int e0/1ASW1(config-if)#switchport mode access ASW1(config-if)#switchport access vlan 20ASW2(config)#int e0/0ASW2(config-if)#switchport mode access ASW2(config-if)#switchport access vlan 30ASW2(config)#int e0/1ASW2(config-if)#switchport mode access ASW2(config-if)#switchport access vlan 40 在DSW1上创建相应的SVI接口，成为各PC的网关 123456789101112DSW1(config)#int vlan 10DSW1(config-if)#ip address 192.168.10.254 255.255.255.0DSW1(config-if)#no shutdown DSW1(config)#int vlan 20DSW1(config-if)#ip address 192.168.20.254 255.255.255.0DSW1(config-if)#no shutdown DSW1(config)#int vlan 30DSW1(config-if)#ip address 192.168.30.254 255.255.255.0DSW1(config-if)#no shutdown DSW1(config)#int vlan 40DSW1(config-if)#ip address 192.168.40.254 255.255.255.0DSW1(config-if)#no shutdown 5、要求连接这些主机的交换端口忽视生成树过程，能够直接进入到转发状态，并且这些端口在接收到配置BPDU时就进入err-disabled状态 在接入层交换机连接PC的端口上开启PortFast和BPUD Guard特性 123//在全局下开启PortFast特性，只针对access端口生效ASW1(config)#spanning-tree portfast edge default ASW2(config)#spanning-tree portfast edge default 在连接PC的接口下开启BPDU Guard特性，则当监听到BPDU时，会把端口shutdown，状态置为err-disabled 123456789101112ASW1(config)#int range e0/0-1ASW1(config-if-range)#spanning-tree bpduguard enable ASW2(config)#int range e0/0-1ASW2(config-if-range)#spanning-tree bpduguard enable //设定自动恢复的时间ASW1(config)#errdisable recovery cause bpduguard ASW1(config)#errdisable recovery interval 30ASW2(config)#errdisable recovery cause bpduguard ASW2(config)#errdisable recovery interval 30 6、完成必要的配置，实现各PC间可以互相访问且都能访问R1 将DSW1连接R1的端口设置成三层端口，配置IP地址 1234567DSW1(config)#int e1/0DSW1(config-if)#no switchport DSW1(config-if)#ip address 10.10.10.1 255.255.255.0R1(config)#int e0/0R1(config-if)#ip address 10.10.10.2 255.255.255.0R1(config-if)#no shutdown 在DSW1和R1上启用OSPF 1234567891011DSW1(config)#router ospf 1DSW1(config-router)#router-id 1.1.1.1DSW1(config-router)#network 192.168.10.0 0.0.0.255 a 0DSW1(config-router)#network 192.168.20.0 0.0.0.255 a 0DSW1(config-router)#network 192.168.30.0 0.0.0.255 a 0DSW1(config-router)#network 192.168.40.0 0.0.0.255 a 0DSW1(config-router)#network 10.10.10.0 0.0.0.255 a 0R1(config)#router ospf 1R1(config-router)#router-id 2.2.2.2R1(config-router)#network 10.10.10.0 0.0.0.255 a 0 此时PC能够访问R1 7、随着网络规模的扩大，该园区网将来可能需要配置更多的VLAN，大量的VLAN实例会影响交换机的性能，要求将该客户网络迁移到MST中，具体MST需求如下： 创建两个MST实例，MST1和MST2，其中MST1用于VLAN 10到VLAN 25，MST2用于VLAN 26到VLAN 50，其他VLAN属于CIST 使用MST区域名”SWITCH”，修订号”1” 将DSW1配置为MST1及CIST的主根，为MST2的次根 将DSW2配置为MST2的主根，为MST1及CIST的次根 指定生成树类型为MST，将相应的VLAN加入到实例中，并指定主次根 12345678910111213141516171819202122232425262728293031DSW1(config)#spanning-tree mode mstDSW1(config)#spanning-tree mst configuration DSW1(config-mst)#name SWITCHDSW1(config-mst)#revision 1DSW1(config-mst)#instance 1 vlan 10-25DSW1(config-mst)#instance 2 vlan 26-50DSW1(config)#spanning-tree mst 0-1 root primary DSW1(config)#spanning-tree mst 2 root secondary DSW2(config)#spanning-tree mode mst DSW2(config)#spanning-tree mst configuration DSW2(config-mst)#name SWITCH DSW2(config-mst)#revision 1DSW2(config-mst)#instance 1 vlan 10-25DSW2(config-mst)#instance 2 vlan 26-50DSW2(config)#spanning-tree mst 0-1 root secondary DSW2(config)#spanning-tree mst 2 root primary ASW1(config)#spanning-tree mode mst ASW1(config)#spanning-tree mst configuration ASW1(config-mst)#name SWITCHASW1(config-mst)#revision 1ASW1(config-mst)#instance 1 vlan 10-25ASW1(config-mst)#instance 2 vlan 26-50ASW2(config)#spanning-tree mode mst ASW2(config)#spanning-tree mst configuration ASW2(config-mst)#name SWITCHASW2(config-mst)#revision 1ASW2(config-mst)#instance 1 vlan 10-25ASW2(config-mst)#instance 2 vlan 26-50 8、该客户网络进行了升级，购买了两台新的多层交换机，升级之后的网络拓扑如下，其中客户所属的VLAN角色及地址段信息保持不变，要求完成如下网络配置 配置DSW1和DSW2以执行VLAN间路由。将DSW1用作与交换机ASW1连接的PC1和PC2的默认网关。连接DSW2的客户端使用DSW2作为默认网关，所有PC都保留网络升级改造之前的IP地址和默认网关 R1与两多层交换机链路的IP地址，以及园区外部的ISP和Web_SRV地址自行规划 在园区网络内启用OSPF，并且将园区网络划分到区域0中 将ASW1和DSW1之间的链路捆绑到一个基于标准的EtherChannel中 完成其他必要配置，实现各VLAN间的用户可以互相通信，并且实现园区网络内的用户可以访问ISP上的Web_SRV 配置DSW1作为PC1、PC2的网关；DSW2作为PC3、PC4的网关 123456789101112131415161718DSW1(config)#vlan 10,20,30DSW1(config)#int vlan 10DSW1(config-if)#no shutdownDSW1(config-if)#ip address 192.168.10.254 255.255.255.0DSW1(config)#int vlan 20DSW1(config-if)#no shutdownDSW1(config-if)#ip address 192.168.20.254 255.255.255.0DSW1(config)#int vlan 30DSW1(config-if)#ip address 192.168.30.253 255.255.255.0DSW1(config-if)#no shutdown DSW2(config)#vlan 30,40DSW2(config)#int vlan 30DSW2(config-if)#ip address 192.168.30.254 255.255.255.0DSW2(config-if)#no shutdownDSW2(config)#int vlan 40DSW2(config-if)#ip address 192.168.40.254 255.255.255.0DSW2(config-if)#no shutdown IP地址规划如下 1234567891011121314151617181920212223242526272829R1(config)#int e0/0R1(config-if)#ip address 172.16.10.1 255.255.255.0R1(config-if)#no shutdown R1(config)#int e0/1R1(config-if)#ip address 172.16.20.1 255.255.255.0R1(config-if)#no shutdown R1(config)#int s1/0R1(config-if)#ip address 12.12.12.1 255.255.255.0R1(config-if)#no shutdown ISP(config)#int s1/0ISP(config-if)#ip address 12.12.12.2 255.255.255.0ISP(config-if)#no shutdown ISP(config)#int e0/0ISP(config-if)#ip address 23.23.23.2 255.255.255.0ISP(config-if)#no shutdown Web_SRV(config)#int e0/0Web_SRV(config-if)#ip address 23.23.23.3 255.255.255.0Web_SRV(config-if)#no shutdown Web_SRV(config)#ip default-gateway 23.23.23.2DSW1(config)#int e0/1DSW1(config-if)#no switchport DSW1(config-if)#ip address 172.16.10.2 255.255.255.0DSW2(config)#int e0/1DSW2(config-if)#no switchport DSW2(config-if)#ip address 172.16.20.2 255.255.255.0 启用OSPF 1234567891011121314151617DSW1(config)#router ospf 1DSW1(config-router)#router-id 1.1.1.1 DSW1(config-router)#network 192.168.10.0 0.0.0.255 a 0DSW1(config-router)#network 192.168.20.0 0.0.0.255 a 0DSW1(config-router)#network 192.168.30.0 0.0.0.255 a 0DSW1(config-router)#network 172.16.10.0 0.0.0.255 a 0DSW2(config)#router ospf 1DSW2(config-router)#router-id 2.2.2.2DSW2(config-router)#network 192.168.30.0 0.0.0.255 a 0DSW2(config-router)#network 192.168.40.0 0.0.0.255 a 0DSW2(config-router)#network 172.16.20.0 0.0.0.255 a 0R1(config)#router ospf 1R1(config-router)#router-id 3.3.3.3R1(config-router)#network 172.16.10.0 0.0.0.255 a 0R1(config-router)#network 172.16.20.0 0.0.0.255 a 0 在ASW1和DSW1上配置EtherChannel 12345DSW1(config)#int range e0/2-3DSW1(config-if-range)#channel-group 1 mode active ASW1(config)#int range e0/2-3ASW1(config-if-range)#channel-group 1 mode active 在R1上配置PAT 1234567891011121314//在R1配置默认路由，使得R1可以访问Web_SRVR1(config)#ip route 0.0.0.0 0.0.0.0 s1/0//在OSPF进程下发默认路由R1(config)#router ospf 1R1(config-router)#default-information originate //ACL匹配PC所在网段R1(config)#access-list 1 permit 192.168.0.0 /16//PATR1(config)#ip nat inside source list 1 interface s1/0 overload //指定内外部接口R1(config)#int range e0/0-1R1(config-if-range)#ip nat inside R1(config)#int s1/0R1(config-if)#ip nat outside 此时PC可以访问Web_SRV 查看地址转换表","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"},{"name":"RSTP","slug":"RSTP","permalink":"http://shain.top/tags/RSTP/"},{"name":"MST","slug":"MST","permalink":"http://shain.top/tags/MST/"}]},{"title":"IPv6概述","slug":"IPv6概述","date":"2020-09-20T15:30:40.000Z","updated":"2020-09-30T15:56:08.960Z","comments":true,"path":"2020/09/20/IPv6概述/","link":"","permalink":"http://shain.top/2020/09/20/IPv6%E6%A6%82%E8%BF%B0/","excerpt":"","text":"1、一个IPv6地址的长度是多少？ IPv6地址的长度是128位 2、怎样表示一个IPv6地址？ IPv6地址可以表示为通过冒号分开的8个以十六进制表示的分段 3、用来压缩和简化IP地址表示的两条规则是什么？ 任何一个16位分段的前导0都可以省略 由全0构成的一个或多个16位分段的任何单个连续的字符串都可以表示为一个双冒号 4、为什么在一个IPv6地址里使用多个双冒号是不允许的？ 使用多个双冒号会使地址变得含混不清，这样不能准确地确定每一个含0字符串的长度 5、IPv6地址::/0和::/128有什么不同之处？ 两个地址都是全0。::/0表示一个缺省地址；::/128表示一个未指定的地址 6、在单播IPv6地址中，用来指定主机的部分是什么？它的长度是多少 单播IPv6地址的主机部分是接口ID，长度通常是64位 7、一个单播IPv6地址的子网ID部分的长度是多少？ 单播IPv6地址的子网ID部分的长度为16位 8、假设一个IPv6地址的起始10位是FE80::/10，那么它是什么类型的地址？ 是链路本地地址 9、3FFE:204:100:90::1是什么地址类型？ 全球单播地址，开始3位以001标识 10、什么是任意播地址？ 任意播地址是表示一个服务的地址而不是表示一台设备的地址，因此它可以代表多台设备 11、什么是多播地址？ 多播地址表示一组设备的地址，不是表示单台设备的地址 12、一个IPv6报头的长度是多少？ IPv6报头的长度为40字节 13、在IPv6报头中设置流标签字段的目的是什么？ 流标记字段通过在报头中标记各自不同的流（具有相同的源地址与目的地址和相同的源于目的端口的数据包），允许高颗粒度的负载分担，而不用因为检查数据包的负荷而降低性能。 14、在IPv4报头中，什么字段和IPv6的下一报头字段相对应？ IPv6下一报头字段相当于IPv4中的协议号字段。命名之所以不同，是因为这个字段的值指定的可能是随后的协议报头，也可能是一个IPv6扩展报头 15、在IPv4报头中，什么字段和IPv6的跳数限制字段相对应？ 跳数限制字段对应于IPv4中的生存时间（TTL）字段。命名改变是因为路由器从来没有根据传送时间来递减这个字段的值，而是在每经过一台传送的路由器时将该字段递减1，实际上就是用跳数替代了传送时间 16、在IPv6的下一报头字段中，有哪些方面像IPv4的协议号字段？又有那些地方不同？ IPv6下一报头字段和IPv4中的协议号字段一样，也是一个8位字段；如果下一报头是上层协议报头，那么它指的就是协议号。但是它也可以指定为与协议号字段不同的字段；如果下一报头是一个IPv6扩展报头，那么它指的就是报头的类型号。 17、怎样扩展报头以便使IPv6的数据包更加富有效率？ 扩展报头使IPv6报头显得更具有效率，它可以专门指定专用功能，并只在这个专用功能使用的时候才包含 18、ICMPv6中下一跳报头的值是什么？ ICMPv6（对应于协议号）的下一报头值是58 19、IPv4的分段和IPv6的分段有哪些重要的不同之处？ 除了分段扩展报头外，IPv6分段与IPv4分段的重要不同是，IPv6路由器不对数据包进行分段。它会告诉始发主机要么对数据包进行分段，要么确保不发起太大的数据包 20、用于邻居发现协议的5种ICMPv6消息是什么？ NDP使用的5个ICMPv6消息是路由器请求（RS）、路由器通告（RA）、邻居请求（NS）、邻居通告（NA）和重定向 21、在一个路由器通告消息中，M标记和O标记的用途是什么？ 设置M标记是告诉主机使用DHCPv6配置它的地址。O标记告诉主机使用DHCPv6去查找其他链路参数。 22、在一个路由器通告消息中，可达时间字段的用途是什么？ 可达时间字段用于实现NDP协议中邻居不可达性检测。当一个节点确认它的邻居是可达的后，可达时间会指定一个时间值，在该时间内，这个节点假定它的邻居是可达的，以毫秒为单位 23、在一个路由器通告消息中，重传计时字段的用途是什么？ 重传计时器字段指定了连续传送的邻居请求之间节点应该等待的时间，以毫秒为单位 24、在一个路由器通告消息中，如果它的路由器生存时间字段被设置为0代表什么意思？ 表示始发路由器不应该增加到一台主机的缺省路由器列表中 25、在一个邻居通告消息中，S标记的用途和作用是什么？ 设置了S标记，表示NA是用来响应某个NS的。只有在NA用来响应一个请求时，才能表示双向可达已经确认，并且在邻居缓存中将邻居地址更改为可达状态；如果收到的是清除了S位的NA，则表示它是未被请求的，并不在邻居缓存中改变它的状态 26、有状态地址自动配置和无状态地址自动配置有什么不同？ 有状态地址自动配置依靠DHCPv6给主机分配地址。无状态地址自动配置使用RA确定一个比链路本地更大范围的前缀，加上MAC-to-EUI64转换来确定主机地址。 27、MAC到EUI64转换使用哪两个步骤可以导出一个接口ID？ MAC-to-EUI64转换在MAC地址中间插入一个值oxFFEE，接着反转U/L位为1，从而通过一个48位的MAC地址创建了一个64位接口ID 28、在一台设备获取一个单播IPv6地址时，它必须执行地址冲突检测操作，但是有一个例外情况，这个例外情况是什么？ 对于任意播地址从来不需要执行地址冲突检测 29、前缀FF02:0:0:0:0:1:FF00::/104表示什么意思？ 用作被请求节点的多播地址。它加在被请求的地址的最后24位之前 30、在IPv6中，使用什么代替ARP和ARP缓存？ IPv6使用NDP的邻居地址解析功能代替了ARP，同时邻居缓存也代替了ARP缓存 31、什么是私有地址？ 私有地址是随机生成的接口ID，并在某些正常的周期或主机获取一个新的前缀时改变。它用来和一个自动配置的公共地址连在一起，确保主机的匿名性。公共地址用于可达性，而私有地址用于某台主机始发的所有数据包的源地址 32、在一个邻居缓存中，Incomplete状态的条目表示什么意思？ 不完全状态表示该条目的邻居地址解析正在处理 33、在一个邻居缓存中，Probe状态的条目表示什么意思？ Probe状态表示已经发送了一个NS去校验某个Stale状态的条目的双向可达性，但响应的NA还没有收到 34、邻居不可达性检测使用哪两种方法来确认一个邻居双向的可达性？ 邻居不可达性检测校验了一个邻居的双向可达性，要么通过来自收到发送消息的确认的上层协议的”提示”；要么通过主动探测带有NS的邻居","categories":[{"name":"复习题","slug":"复习题","permalink":"http://shain.top/categories/%E5%A4%8D%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"IPv6","slug":"IPv6","permalink":"http://shain.top/tags/IPv6/"}]},{"title":"TCP/IP回顾","slug":"TCP-IP回顾","date":"2020-09-19T13:49:30.000Z","updated":"2020-09-19T16:01:39.789Z","comments":true,"path":"2020/09/19/TCP-IP回顾/","link":"","permalink":"http://shain.top/2020/09/19/TCP-IP%E5%9B%9E%E9%A1%BE/","excerpt":"","text":"1、TCP/IP协议簇的5个层次是什么？每一层的目的是什么？ 物理层——包含关于物理介质的协议 数据链路层——包含了如何控制物理层的一些协议：介质是怎样存取和共享的，介质上的设备是怎样标识的，数据在介质上传播之前是怎样成帧的 IP层——包含一些将数据链路逻辑分组到一个网络以及跨网络进行通信的协议 主机到主机层——包含一些定义并控制中逻辑的、端到端的路径的协议 应用层——对应于OSI中的会话层、表示层和应用层 2、目前最常用的IP版本是什么？ 现在使用最普遍的IP版本为版本4 3、什么是分段？IP报头的什么字段用于分段？ 当数据包的长度超过它所要去的那个数据链路的MTU时，路由器要将它分段。数据包中的数据将被分成小段，每一段被封装在独立的数据包中。接收端使用标识符、标记域中的MF位以及片偏移来进行重组。 4、IP报头中的TTL字段的用途是什么？TTL过程是如何工作的？ TTL用于防止数据包在IP网络中无休止地传播。该字段包含一个8位整数，这个数字由产生数据包的主机设定。数据包每经过一台路由器，TTL值将被减1。如果一台路由器将TTL减至0，它将丢弃该数据包并发送一个ICMP超时消息给数据包的源地址。 5、什么是首个八位组字节规则？ A类：第一个八位组字节的第1位是0 B类：第一个八位组字节的前2位是10 C类：第一个八位组字节的前3位是110 D类：第一个八位组字节的前4位是1110 E类：第一个八位组字节的前4位是1111 ６、怎样识别点分十进制表示的Ａ类、Ｂ类和Ｃ类地址？怎样识别二进制表示的地址？ 类 第一个八位组字节 二进制范围 第一个八位组字节 十进制范围 A 0000 0001~0111 1110 1~126 B 1000 0000~1011 1111 128~191 C 1100 0000~1101 1111 192~223 7、什么是地址掩码？它是如何工作的？ IP地址掩码标识了IP地址的网络部分。32位掩码中的1标识了IP地址中相应的网络位，0标识了主机位。将IP地址和掩码进行布尔与运算，结果是，IP地址中对应于掩码网络部分的那一段不变，而对应于主机部分的全变成0。 8、什么是子网？在IP环境中为什么使用子网？ 子网化是对A、B、C类地址进行子分组。如果没有子网化，A、B、C类的主IP地址的网络部分将只能标识一个数据链路。子网化使用主IP地址中的一些主机位作为网络位，允许一个单独的主地址被划分为多个网络地址。 9、为什么在有类别路由选择环境中子网位不能全部为0或1？ 有类别路由选择协议不能区分全0子网和主IP地址，也不能区分全1子网和主IP地址的全主机、全子网广播地址 10、什么是ARP？ ARP（地址解析协议）的作用是将数据链路上接口的IP地址映射到相应的MAC地址 11、什么是代理ARP？ 代理ARP是IP路由器的功能之一。如果路由器收到一个ARP请求，并且：目标网络或子网在路由器的路由表中；路由表指出目标可以通过某一个接口可达，该接口不同于接受到ARP请求的那个接口，则路由器将用自己的MAC地址对该ARP请求进行回应。 12、什么是重定向？ 重定向是IP路由器的功能之一。如果一台设备发送一个数据包给路由器，该路由器必须将数据包转发至同一数据链路上的下一跳路由器，那么该路由器将向原设备发送一条其可以直接到达下一跳路由器的重定向消息。 13、TCP和UDP的本质区别是什么？ TCP在无连接的IP层之上提供了面向连接的服务。UDP则提供了无连接的服务。 14、TCP提供面向连接服务的机制是什么？ 序列号确保了准确的排序；校验、确认、计时器以及重传机制确保了可靠性；滑动窗口机制确保了流量控制 15、为了替代ARP，Novell NetWare用设备的MAC地址作为网络地址中的主机部分。为什么IP不能这样做？ MAC地址是固定长度的二进制整数。如果用MAC地址作为IP地址的主机部分，那么子网化将不能实现。因为不可能灵活地使用一些主机位作为网络位 16、UDP通过在无连接服务之上提供无连接服务的目的是什么？ UDP报头的唯一目的是增加源端口及目的端口号","categories":[{"name":"复习题","slug":"复习题","permalink":"http://shain.top/categories/%E5%A4%8D%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://shain.top/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"http://shain.top/tags/IP/"}]},{"title":"FHRP","slug":"FHRP","date":"2020-09-18T10:38:30.000Z","updated":"2020-09-30T15:30:53.491Z","comments":true,"path":"2020/09/18/FHRP/","link":"","permalink":"http://shain.top/2020/09/18/FHRP/","excerpt":"第一跳冗余协议（FHRP）是一种用来保护默认网关的网络协议，其原理是允许两台（或多台）路由器或3层交换机共同提供一个冗余的网关地址。默认情况下，如果第一跳设备故障，备用路由器将在数秒内接管网关地址。HSRP、VRRP、GLBP是三种常见的第一跳冗余协议。","text":"第一跳冗余协议（FHRP）是一种用来保护默认网关的网络协议，其原理是允许两台（或多台）路由器或3层交换机共同提供一个冗余的网关地址。默认情况下，如果第一跳设备故障，备用路由器将在数秒内接管网关地址。HSRP、VRRP、GLBP是三种常见的第一跳冗余协议。 1、HSRP 在HSRP中，特定IP子网中工作站的默认网关将是协议生成的一个虚拟IP地址。当工作站发送数据包至默认网关时，工作站会首先使用ARP协议解析默认网关IP地址的对应MAC地址，而ARP解析会返回一个虚拟路由器的MAC地址。随后，发送给路由器虚拟MAC地址的数据包将会由虚拟路由器组中的活动路由器进行处理。 HSRP活动及备用路由器使用组播地址224.0.0.2（版本1，针对所有路由器）或224.0.0.102（版本2）的UDP1985端口发送Hello消息。Hello消息用于HSRP组内路由器的相互通信。 HSRP组内的路由器角色： 虚拟路由器：终端设备上作为默认网关配置的一组IP地址和MAC地址，不用于处理真实的物理流量。活动路由器负责处理所有发送到虚拟路由器地址的数据包和数据帧。每个HSRP组内只有一台虚拟路由器。 活动路由器：用于转发所有发送到虚拟路由器MAC地址的数据包。每个HSRP组内，只有一台活动路由器。 备用路由器：监听周期性的Hello消息。当活动路由器发生故障时，其他的HSRP路由器将接收不到活动路由器发送的Hello消息，此时备用路由器接管活动路由器的角色。每个HSRP组内只有一台备用路由器。 其他路由器：一个HSRP组内可能有多台路由器，但只能有一台活动路由器和一台备用路由器，其他的路由器处于初始（Initial）状态。当活动路由器和备用路由器全部发生故障之后，组内的其他路由器才会竞争活动路由器和备用路由器的角色。 HSRP状态： Initial：初始状态，表示路由器还未运行HSRP。当配置修改或接口刚变成up时，将会进入Initial状态 Listen：学习到虚拟IP地址，侦听活动及备用路由器发送的Hello消息 Speak：发送周期性的Hello消息，主动参加到活动或备用路由器的选举中。只有学习到虚拟IP地址才能进入Speak状态 Standby：成为活动路由器的候选角色，发送周期性的Hello消息 Active：周期性地发送Hello消息，负责转发所有发送至虚拟MAC地址的数据包 使用如下拓扑进行HSRP的配置 首先按拓扑所示配置各设备上的IP地址 在R1和R2上配置HSRP Standby IP地址192.168.1.1作为虚拟IP地址，并开启抢占功能，修改R1上HSRP组1的优先级为110 12345678910R1(config)#int e0/0R1(config-if)#standby 1 ip 192.168.1.1R1(config-if)#standby 1 preempt //修改HSRP组1的优先级为110，默认为100。取值范围是0~255。//带有最高优先级的设备将会选举为活动路由器，若组内设备的优先级相同，则继续比较IP地址，带有最高IP地址的设备选举为活动路由器R1(config-if)#standby 1 priority 110R2(config)#int e0/0R2(config-if)#standby 1 ip 192.168.1.1R2(config-if)#standby 1 preempt 查看R1和R2上的HSRP状态信息 R1当前为活动路由器，R2为备用路由器 在R1上检查ARP表项 由下图可知，HSRP组内活动路由器的ARP表中维护着虚拟路由器的IP地址以及对应的MAC地址。HSRP MAC地址的格式为：0000.0c07.acXX，其中”XX”为组编号。客户端使用此MAC地址来转发数据 在PC4上持续pingR3上的回环口地址3.3.3.3，然后将R1的e0/0端口shutdown R1上的活动路由器角色很快切换到R2，对于PC来说基本是无缝的 此时R2成为活动路由器，R1的状态为Init，表示R1和R2未找到HSRP peer，因为路由器在LAN接口上的连通性已经丢失 重新打开R1上的e0/0端口，由于开启了抢占特性，R1再次成为活动路由器 使用如下拓扑进行HSRP负载均衡配置 配置DSW1为VLAN 10的根桥，为VLAN 20的次根桥；配置DSW2为VLAN 20的根桥，为VLAN 10的次根桥 12345DSW1(config)#spanning-tree vlan 10 root primary DSW1(config)#spanning-tree vlan 20 root secondary DSW2(config)#spanning-tree vlan 10 root secondary DSW2(config)#spanning-tree vlan 20 root primary 在DSW1和DSW2上配置两个HSRP组 1234567891011121314151617181920212223DSW1(config)#int vlan 10DSW1(config-if)#ip address 192.168.10.253 255.255.255.0DSW1(config-if)#no shutdown DSW1(config-if)#standby 10 ip 192.168.10.254DSW1(config-if)#standby 10 priority 110 //修改优先级使DSW1成为组10的活动路由器DSW1(config-if)#standby 10 preempt DSW1(config)#int vlan 20DSW1(config-if)#ip address 192.168.20.252 255.255.255.0DSW1(config-if)#no shutdown DSW1(config-if)#standby 20 ip 192.168.20.254 DSW1(config-if)#standby 20 preempt DSW2(config)#int vlan 10DSW2(config-if)#ip address 192.168.10.252 255.255.255.0DSW2(config-if)#no shutdown DSW2(config-if)#standby 10 ip 192.168.10.254DSW2(config-if)#standby 10 preempt DSW2(config)#int vlan 20DSW2(config-if)#ip address 192.168.20.253 255.255.255.0DSW2(config-if)#no shutdown DSW2(config-if)#standby 20 ip 192.168.20.254DSW2(config-if)#standby 20 priority 110 //修改优先级使DSW2成为组20的活动路由器DSW2(config-if)#standby 20 preempt 进行其他必要配置使得PC1和PC2可以访问Internet，并在PC1和PC2上跟踪路径 将DSW1的VLAN 10接口shutdown，观察PC1访问Internet所经过的路径，由下图可知此时PC1通过DSW2访问Internet 以下进行HSRP跟踪配置 将DSW1的e0/2接口shutdown，观察PC1访问Internet所经过的路径 由于DSW1的上行链路未启用HSRP，因此其故障不会影响到HSRP。DSW1仍然作为活动路由器，所有从PC1去往Internet的流量都会先经过DSW1，然后再路由给DSW2并转发至Internet，此时产生了一个低效率的流量路径 采用接口跟踪技术，在DSW1上跟踪e0/2接口的状态，当e0/2接口的2层协议变为down状态，将HSRP组10的优先级降低 123DSW1(config)#track 10 interface e0/2 line-protocol //跟踪接口e0/2的2层协议DSW1(config)#int vlan 10DSW1(config-if)#standby 10 track 10 decrement 20 将DSW1的e0/2接口shutdown 1234//日志消息提醒*Sep 21 15:47:41.079: %TRACK-6-STATE: 10 interface Et0/2 line-protocol Up -&gt; Down*Sep 21 15:47:42.136: %HSRP-5-STATECHANGE: Vlan10 Grp 10 state Active -&gt; Speak*Sep 21 15:47:52.999: %HSRP-5-STATECHANGE: Vlan10 Grp 10 state Speak -&gt; Standby 在PC1上traceroute，由下图可知此时PC1直接通过DSW2访问Internet 若Internet上的e0/0接口出现故障，则DSW1无法感知，这时就需要使用对象跟踪 12345678//定义一个IP SLA的连通性测试DSW1(config)#ip sla 10DSW1(config-ip-sla)#icmp-echo 12.12.12.2 //使用icmp-echo ping来跟踪下一跳路由器的连通性DSW1(config-ip-sla-echo)#frequency 5 //指定执行测试的频率DSW1(config)#ip sla schedule 10 life forever start-time now //指定测试周期和测试开始时间DSW1(config)#track 100 ip sla 10 //创建一个对象并跟踪IP SLA实例DSW1(config)#int vlan 10DSW1(config-if)#standby 10 track 100 decrement 20 //当测试失败时降低相应HSRP组的优先级 此时将Internet上的e0/0接口shutdown，使用traceroute跟踪PC1访问Internet所经过的路径，此时直接通过DSW2进行访问 1234//日志消息提醒*Sep 21 16:27:27.862: %TRACK-6-STATE: 100 ip sla 10 state Up -&gt; Down*Sep 21 16:27:28.406: %HSRP-5-STATECHANGE: Vlan10 Grp 10 state Active -&gt; Speak*Sep 21 16:27:40.104: %HSRP-5-STATECHANGE: Vlan10 Grp 10 state Speak -&gt; Standby 2、VRRP VRRP是一种类似HSRP的开放标准技术。VRRP中的master设备相当于HSRP中的活动路由器，backup设备相当于HSRP中的备用路由器。VRRP组由一台master设备和一台或多台backup设备组成。组内带有最高优先级的设备将选举为master。优先级值为0的特殊含义：表示当前的master设备不参与VRRP的选举进程。该设置用于触发backup设备快速切换至master状态，而无需等待当前的master设备超时。当VRRP组内成员的IP地址与虚拟IP地址相同时，该成员设备具有最高优先级255，成为该VRRP组的master。VRRP中默认开启抢占特性。 VRRP中，只有master设备才会发送通告消息，使用的是组播地址224.0.0.18，端口112。默认每秒发送一次，保持时间为3秒。 HSRP与VRRP比较 HSRP VRRP Cisco私有 公有 1台active设备，1台standby设备，多台候选设备 1台master设备，多台backup设备 虚拟IP地址与组内设备的IP地址不能相同 虚拟IP地址可以与组内成员的真实IP地址相同 使用224.0.0.2发送Hello包 使用224.0.0.18发送通告消息 可以跟踪接口或对象 只能跟踪对象 默认计时器：Hello–3s；保持时间–10s 默认计时器：Hello–1s；保持时间–3s 支持认证功能 RFC中不再支持认证功能，但Cisco IOS支持 以下进行VRRP的配置，拓扑图如下所示 123456R1(config)#int e0/0R1(config-if)#vrrp 10 ip 192.168.1.1 //配置虚拟IP地址为192.168.1.1R1(config-if)#vrrp 10 priority 110 //设置优先级为110R2(config)#int e0/0R2(config-if)#vrrp 10 ip 192.168.1.1 由于在R1上配置了更高的优先级，所以R1成为Master 在R1上跟踪接口e0/1的状态，若此接口发生故障，则将其优先级降低20 123R1(config)#track 1 int e0/1 line-protocol R1(config)#int e0/0R1(config-if)#vrrp 10 track 1 decrement 20 此时将R1上的e0/1接口shutdown，日志提示信息如下 12*Sep 29 11:37:14.436: %TRACK-6-STATE: 1 interface Et0/1 line-protocol Up -&gt; Down*Sep 29 11:37:17.367: %VRRP-6-STATECHANGE: Et0/0 Grp 10 state Master -&gt; Backup R1上检测到e0/1发生故障，将VRRP优先级降低20 此时R2成为VRRP组10的Master 在PC4上使用traceroute命令跟踪访问3.3.3.3所经过的路径，可知此时PC4通过R2进行访问 在R1上配置IP SLA测试，监控上行链路是否出现故障 1234567R1(config)#ip sla 100 R1(config-ip-sla)#icmp-echo 192.168.2.2 //跟踪192.168.2.2的可达性R1(config-ip-sla-echo)#frequency 5R1(config)#ip sla schedule 100 life forever start-time now R1(config)#track 2 ip sla 100R1(config)#int e0/0R1(config-if)#vrrp 10 track 2 decrement 50 将R3的e0/0接口shutdown，则此时R2成为Master 此时在PC4上使用traceroute命令跟踪访问3.3.3.3所经过的路径，右下图可知通过R2进行访问 3、GLBP 网关负载均衡协议（GLBP）可以为LAN上配有相同默认网关的IP主机提供自动的网关备份功能。LAN上的多台第一跳路由器对外提供了一个虚拟的第一跳IP地址，并同时提供了IP包的负载均衡能力。GLBP与HSRP/VRRP最大的区别在于多台GLBP路由器默认情况下都会转发流量。 GLBP中存在两种角色：网关（gateway）和转发者（forwarder） GLBP AVG（活动虚拟网关）：每个GLBP组内会选举一台网关设备作为本组的AVG，而其他组成员则扮演着备份AVG的角色并处于Standby状态。AVG会为组GLBP组内的每个成员分配一个虚拟的MAC地址。AVG会侦听来自终端主机对于默认网关的ARP请求，并回复GLBP组内成员的某个MAC地址，以此在所有组成员上实现流量的负载分担。 GLBP AVF（活动虚拟转发者）：AVG为网关分配虚拟MAC地址之后，每台分配了虚拟MAC地址的网关将负责转发发送到此虚拟MAC地址的数据包。这些负责转发的网关叫做AVF。一个GLBP组内最多可以存在4个AVF（AVG同时也可以是AVF）。所有其他的设备将选举为第二转发者，用于备份当前的AVF角色。 GLBP与HSRP的比较 HSRP GLBP Cisco私有 Cisco私有 1台Active设备，1台Standby设备，多台候选设备 AVG：1台Active设备，1台Standby设备，多台候选设备AVF：多台Active设备，多台候选设备 虚拟IP地址与真实IP地址不同 虚拟IP地址与真实IP地址不同 使用224.0.0.2或224.0.0.102，UDP端口1985发送Hello包 使用224.0.0.12，UDP端口3222发送Hello包 可以跟踪接口或对象 只能跟踪对象 默认计时器：Hello–3s；保持时间–10s 默认计时器：Hello–3s；保持时间–10s 支持认证功能 支持认证功能 以下进行GLBP配置，拓扑如下所示 在DSW1、DSW2、DSW3上完成GLBP的配置 123456789101112131415161718DSW1(config)#int vlan 10DSW1(config-if)#ip address 192.168.10.253 255.255.255.0DSW1(config-if)#no shutdownDSW1(config-if)#glbp 10 ip 192.168.10.254 //配置GLBP虚拟IP地址为192.168.10.254DSW1(config-if)#glbp 10 priority 120 //将GLBP的优先级设为120DSW1(config-if)#glbp 10 preempt //开启抢占功能DSW2(config)#int vlan 10DSW2(config-if)#ip address 192.168.10.252 255.255.255.0DSW2(config-if)#no shutdownDSW2(config-if)#glbp 10 ip 192.168.10.254DSW2(config-if)#glbp 10 priority 110DSW2(config-if)#glbp 10 preempt DSW3(config)#int vlan 10DSW3(config-if)#ip address 192.168.10.251 255.255.255.0DSW3(config-if)#no shutdownDSW3(config-if)#glbp 10 preempt 由于DSW1上配置了更高的优先级，所以DSW1成为该GLBP组的AVG，状态为Active；DSW2成为备份AVG，状态为Standby；DSW3也作为AVG的备份，状态为Listen。则当DSW1失效时，DSW2首先接管成为GLBP组中新的AVG角色 GLBP的虚拟MAC地址格式为0007.b4XX.XXYY 其中，XXXX是一个16比特值，包含6比特连续的0以及10比特的GLBP组号码；YY为8比特值，代表VF的编号 在各PC上执行ping操作，测试各PC与其网关的连通性，并查看各PC的ARP表 由下列各图可知，PC1的ARP表中与网关IP地址绑定的MAC地址是DSW1所得到的虚拟MAC地址，即DSW1是转发者1，PC1通过DSW1访问外部网络；同理，PC2通过DSW2访问外部网络；PC3通过DSW3访问外部网络；由于默认使用的负载均衡方式是轮询，所以PC4会通过DSW1访问外部网络。 此时在DSW1上将VLAN 10接口shutdown 123456DSW1(config)#int vlan 10DSW1(config-if)#shutdown *Sep 30 12:09:28.728: %GLBP-6-FWDSTATECHANGE: Vlan10 Grp 10 Fwd 1 state Active -&gt; Init*Sep 30 12:09:28.728: %GLBP-6-STATECHANGE: Vlan10 Grp 10 state Active -&gt; Init*Sep 30 12:09:30.736: %LINK-5-CHANGED: Interface Vlan10, changed state to administratively down*Sep 30 12:09:31.739: %LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan10, changed state to down DSW1变为Init状态；DSW2成为AVG，并且成为AVF1和AVF2，除了转发自己的流量外，还需负责转发原本DSW1转发的流量；DSW3成为备份AVG，状态为Standby PC1的MAC绑定表未改变，但此时则是通过DSW2访问网关 虽然此时DSW2带有两个不同的虚拟MAC地址，同时充当两个AVF的角色，不过这种现象不会持续很长时间。因为AVG会维护两个不同的计时器。重定向计时器用来决定何时AVG在ARP回复中停止使用旧的虚拟MAC地址。当超时计时器到期后，所有GLBP成员都会将虚拟转发者的旧MAC地址冲刷掉。使用旧MAC地址的客户端也必须刷新其ARP表项来获取新的MAC地址。 默认情况下，重定向计时器为10分钟，超时计时器为4小时。 权重值的变化影响着AVF的选举，以及负载均衡算法。权重值可以与对象跟踪技术协同工作。分配给每台路由器的权重值决定了路由器能够转发数据包的多少，即权重值决定了LAN中某台AVF负责转发主机流量的比例。（默认权重值为100）。当某个GLBP组内的某台路由器的权重低于某个门限值（lower threshold）时，将会关闭该AVF的转发功能。而当权重值上升达到另一门限值（upper threshold）后，又会自动开启该AVF的转发功能。 在DSW1上配置权重并跟踪接口e0/1的状态 1234DSW1(config)#track 10 int e0/1 line-protocol DSW1(config)#int vlan 10DSW1(config-if)#glbp 10 weighting 110 lower 70 upper 90 //设置权重为110，当低于70时关闭AVF的转发功能DSW1(config-if)#glbp 10 weighting track 10 decrement 50 在DSW1上查看GLBP状态 将DSW1上的e0/1接口shutdown，查看GLBP状态信息 1234567DSW1(config)#int e0/1DSW1(config-if)#shutdown *Sep 30 14:51:01.704: %TRACK-6-STATE: 10 interface Et0/1 line-protocol Up -&gt; Down*Sep 30 14:51:03.702: %LINK-5-CHANGED: Interface Ethernet0/1, changed state to administratively down*Sep 30 14:51:04.705: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to down//默认情况下，GLBP虚拟转发者的抢占延迟为30s*Sep 30 14:51:33.377: %GLBP-6-FWDSTATECHANGE: Vlan10 Grp 10 Fwd 1 state Active -&gt; Listen 由于检测到了e0/1接口发生故障，此时DSW1的权重值会降低50 DSW1仍然为AVG，但由于权重值降到了低门限值之下，此时已不再是AVF DSW2等待30s后抢占成为AVF，同时成为AVF1和AVF2 4、总结 HSRP的运作模式是一台路由器充当Active路由器，一台充当Standby路由器。一个HSRP组只能使用一个虚拟IP地址，如果Active路由器发生故障，Standby路由器将接管成为Active路由器，负责底层PC的数据包转发。可以为路由器配置抢占特性，当带有更高优先级的HSRP成员进入网络时，会主动抢占成为Active路由器。VRRP为公有协议。一个VRRP组内只能有一台Master路由器，一台或多台Backup路由器。并且，VRRP的抢占特性默认开启。GLBP通过使用单个虚拟IP地址与多个虚拟MAC地址的方式提供了路由冗余以及一定程度的网关负载均衡。GLBP组内通过选举出的一台AVG，为每个转发者分配一个虚拟MAC地址，并使用虚拟MAC地址回复客户端的ARP请求。每个GLBP组内最多只能存在四台AVF设备。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HSRP","slug":"HSRP","permalink":"http://shain.top/tags/HSRP/"},{"name":"VRRP","slug":"VRRP","permalink":"http://shain.top/tags/VRRP/"},{"name":"GLBP","slug":"GLBP","permalink":"http://shain.top/tags/GLBP/"}]},{"title":"生成树特性","slug":"生成树特性","date":"2020-09-16T06:40:55.000Z","updated":"2020-09-16T14:25:23.227Z","comments":true,"path":"2020/09/16/生成树特性/","link":"","permalink":"http://shain.top/2020/09/16/%E7%94%9F%E6%88%90%E6%A0%91%E7%89%B9%E6%80%A7/","excerpt":"为了能够帮助STP实现更快的收敛，也能让协议的操作能够更好地利用现有的网络架构，这时就需要应用一些特性来过滤一些条件下BPDU的发送或接收，并改变网络拓扑变化时网络的响应方式。本文将介绍8种特性，用于优化管理STP。","text":"为了能够帮助STP实现更快的收敛，也能让协议的操作能够更好地利用现有的网络架构，这时就需要应用一些特性来过滤一些条件下BPDU的发送或接收，并改变网络拓扑变化时网络的响应方式。本文将介绍8种特性，用于优化管理STP。 注：无特别说明，本文使用的STP的模式为PVST 1、PortFast 针对pvst、rstp、mst都有效 （1）对象：连接终端设备的端口 （2）功能：可以使得接入端口（access）直接过渡到转发状态；当交换机PortFast端口up或down时，不会发送TCN BPDU （3）配置 1234567//不同镜像命令可能不同接口下:SW3(config-if)#spanning-tree portfast全局下: //(针对access端口才生效)SW3(config)#spanning-tree portfast default //查看portfast当前状态SW3#show spanning-tree interface e0/2 portfast 12345678910111213141516171819202122//未开启PortFast，则Et0/2需经历30s时间才过渡到转发状态SW3#debug spanning-tree events Spanning Tree event debugging is onSW3(config)#int e0/2SW3(config-if)#no shutdown*Aug 6 13:41:02.355: set portid: VLAN0001 Et0/2: new port id 8003 //80表示端口优先级为128，03表示端口号为0/2*Aug 6 13:41:02.355: STP: VLAN0001 Et0/2 -&gt; listening*Aug 6 13:41:17.362: STP: VLAN0001 Et0/2 -&gt; learning*Aug 6 13:41:32.369: STP[1]: Generating TC trap for port Ethernet0/2*Aug 6 13:41:32.369: STP: VLAN0001 sent Topology Change Notice on Et0/0*Aug 6 13:41:32.369: STP: VLAN0001 Et0/2 -&gt; forwarding//在接口下开启PortFast特性SW3(config)#int e0/2SW3(config-if)#spanning-tree portfast edge//开启debug，观察收敛情况，可知此时过渡到转发状态所需时间&lt;1sSW3#debug spanning-tree events Spanning Tree event debugging is onSW3(config)#int e0/2SW3(config-if)#no shutdown*Aug 6 13:48:52.275: set portid: VLAN0001 Et0/2: new port id 8003*Aug 6 13:48:52.275: STP: VLAN0001 Et0/2 -&gt;jump to forwarding from blocking 再次强调，只能在连接终端设备（PC或服务器）的端口上配置PortFast特性。否则，可能会产生环路并导致网络瘫痪。 RSTP中配置PortFast特性的方法与STP相同。在RSTP中，连接单个主机的端口称作边缘端口（edge port）。在RSTP中启用PortFast，可以减少STP重计算的数量，因为在网络中若终端设备数量过多，且同时up或down的话，会导致过多的STP重计算。 2、BPDU Guard（1）对象：针对开启PortFast的端口 （2）功能：用于保护PortFast端口的完整性。为了防止接入端口存在错误性连接，把交换机接到开启PortFast的端口可能导致环路，所以提出BPDU Guard，负责监听BPDU，如果发现有监听到BPDU，可以认为当前存在误接，则直接把端口shutdown，状态置为err-disabled。 建议在所有启用PortFast特性的端口上使用BPDU保护技术！ （3）配置 12345678910111213141516//前提：配置BPDU保护的端口启用了PortFast特性接口下：SW3(config-if)#spanning-tree bpduguard enable全局下：SW3(config)#spanning-tree portfast bpduguard default //在交换机的所有PortFast端口上配置BPDU保护SW3#show spanning-tree suammary totals //查看BPDU保护配置//恢复被置为err-diabled的端口：（1）端口下操作SW3(config)#int e0/2SW3(config-if)#shutdownSW3(config-if)#no shutdown（2）设定自动恢复的时间SW3(config)#errdisable recovery cause bpduguard //原因；开启倒计时的开关SW3(config)#errdisable recovery interval 30 //设定倒计时的时间；默认为300s 12345678//由于在e0/2端口开启了BPDU Guard，但是该端口连接了交换机，从该端口收到了BPDU，则会将此端口的状态置为err-disable，并shutdownSW3#debug spanning-tree events Spanning Tree event debugging is on*Aug 6 14:30:38.295: set portid: VLAN0001 Et0/2: new port id 8003*Aug 6 14:30:38.295: STP: VLAN0001 Et0/2 -&gt;jump to forwarding from blocking*Aug 6 14:30:38.402: %SPANTREE-2-BLOCK_BPDUGUARD: Received BPDU on port Et0/2 with BPDU Guard enabled. Disabling port.*Aug 6 14:30:38.402: %PM-4-ERR_DISABLE: bpduguard error detected on Et0/2, putting Et0/2 in err-disable state*Aug 6 14:30:40.297: %LINK-3-UPDOWN: Interface Ethernet0/2, changed state to down 查看端口信息可知状态为err-disabled 以下进行端口恢复（应先将误接的设备&lt;SW4&gt;移除） 方法一：将该接口关闭再打开 123SW3(config)#int e0/2SW3(config-if)#shutdown SW3(config-if)#no shutdown 方法二：设定自动恢复的时间 12SW3(config)#errdisable recovery cause bpduguardSW3(config)#errdisable recovery interval 30 需要注意的是，BPDU保护技术并不能预防所有环路的产生。例如集线器（hub）和傻瓜交换机是不会发送BPDU的；因此，BPDU保护也就无法检测到这些设备。如果hub或非网管交换机同时连接到了网络中的两个位置，那么就有可能导致网络环路的产生。 3、BPDU Filter——慎用（1）对象：针对接入端口配置 （2）背景：如果连接的是接入端口，则不必要向对方发送BPDU，就提出BPDU Filter，过滤BPDU （3）功能：如果在端口上启用，则代表禁用掉该端口的STP 功能；如果是在全局上启用，则代表仅仅过滤掉发出的BPDU （4）配置 12345678//在特定端口上启用BPDU过滤SW3(config-if)#spanning-tree bpdufilter enable//在交换机的所有PortFast端口上启用BPDU过滤SW3(config)#spanning-tree portfast bpdufilter default //查看特定端口上的BPDU过滤配置SW3#show spanning-tree interface e0/2 detail //验证全局的BPDU过滤配置SW3#show spanning-tree summary totals 注意：如果一台交换机同时配置了BPDU保护和BPDU过滤特性，只有BPDU过滤能够生效。因此，不要在同一端口上同时部署BPDU保护和BPDU过滤这两种机制。 4、UplinkFast——只对PVST生效（1）对象：在有阻塞端口的设备上配置才有效果 （2）功能：如果发现活跃端口失效，则可以立即启用阻塞端口，直接过渡到转发状态，节省30s （3）配置 12345//UplinkFast只能基于整台交换机开启或关闭，无法为单个VLAN启用UplinkFast//启用UplinkFast特性SW3(config)#spanning-tree uplinkfast//检查UplinkFast配置SW3#show spanning-tree uplinkfast 在SW3上开启UplinkFast后，将e0/0端口shutdown，则e0/1端口立刻变为转发状态 注：RSTP协议中内置了UplinkFast机制，无需手动开启 5、BackboneFast——只对PVST生效（1）对象：监听上行链路的备份 （2）功能：如果有设备链路出现故障，则认为自己是根桥，会发送次级BPDU给所有直连交换机。这时候有开启BackboneFast的设备会直接去询问根是否还存活，根回复还活着，则会为发送次级BPDU的设备提供新的链路，阻塞端口直接跳过20s进入到监听状态，差不多30s完成收敛，节省20ｓ。 （3）配置 1234//必须在每一台设备上都开启SW3(config)#spanning-tree backbonefast//检查STP BackboneFast的当前状态SW3#show spanning-tree backbonefast 将SW2的e0/0端口shutdown，观察SW3的e0/2端口过渡到转发状态所需的时间 123456789101112131415161718192021222324252627282930313233343536373839//未开启backbonefast特性当SW2的e0/0端口被关闭后，SW2无法接收到根桥发送的BPDU，会认为自己就是根桥，从e0/1端口发送BPDU，SW3接收到SW2发送的次级BPDU（因为会从e0/0端口接收到根桥发送的更优的BPDU）不会进行受理，20s之后SW3从端口e0/1仍未收到根桥发送的BPDU，则会从端口e0/0发送RLQ(根链路查询)，询问根是否还存活着，收到根桥的回复后，SW3受理从e0/1端口收到的次级BPDU，告知SW2它不是根桥，进入listen、learning、forwarding，需要大约50s时间SW3#debug spanning-tree events Spanning Tree event debugging is on*Aug 7 05:58:51.042: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:58:52.887: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:58:54.890: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:58:56.889: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:58:58.890: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:59:00.899: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:59:02.904: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:59:04.913: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:59:06.919: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:59:08.927: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 05:59:09.047: STP: VLAN0001 Et0/1 -&gt; listening*Aug 7 05:59:10.103: STP: VLAN0001 Topology Change rcvd on Et0/1*Aug 7 05:59:10.103: STP: VLAN0001 sent Topology Change Notice on Et0/0*Aug 7 05:59:24.051: STP: VLAN0001 Et0/1 -&gt; learning*Aug 7 05:59:39.057: STP[1]: Generating TC trap for port Ethernet0/1*Aug 7 05:59:39.057: STP: VLAN0001 sent Topology Change Notice on Et0/0*Aug 7 05:59:39.057: STP: VLAN0001 Et0/1 -&gt; forwarding//开启backbonefast当监听到次级BPDU后，直接询问根桥，根桥仍然存活着，则受理BPDU，直接进入listening状态，节省20s时间SW3#debug spanning-tree events Spanning Tree event debugging is on*Aug 7 06:16:15.879: STP: VLAN0001 heard root 32769-aabb.cc00.2000 on Et0/1*Aug 7 06:16:15.880: STP: VLAN0001 Et0/1 -&gt; listening*Aug 7 06:16:16.781: STP: VLAN0001 Topology Change rcvd on Et0/1*Aug 7 06:16:16.781: STP: VLAN0001 sent Topology Change Notice on Et0/0*Aug 7 06:16:30.887: STP: VLAN0001 Et0/1 -&gt; learning*Aug 7 06:16:45.895: STP[1]: Generating TC trap for port Ethernet0/1*Aug 7 06:16:45.895: STP: VLAN0001 sent Topology Change Notice on Et0/0*Aug 7 06:16:45.895: STP: VLAN0001 Et0/1 -&gt; forwarding 注：当前，RSTP协议内置了BackboneFast机制。不过RSTP与BackboneFast的实现方式略有不同。BackboneFast依赖RLQ信息来检测根桥是否可用，而RSTP则依赖缓存信息来实现。 6、Root Guard（1）作用：巩固根桥的地位 （2）功能：开启根保护特性可以强制将某个端口变成指定端口，来防止周围的交换机选举为根交换机。如果交换机在根保护端口上收到了更优的BPDU，那么端口将会进入”不一致根”（root-inconsistent）的STP状态（等同于listening状态），并且交换机也不会从该端口转发流量。当不再监听到更优的BPDU，则自行修复。 （3）配置 12//接口下开启跟保护特性sw1(config-if)spanning-tree guard root 123456789101112131415161718192021222324252627//在SW1的e0/0和e0/1端口开启Root Gardsw1(config)#int range e0/0-1sw1(config-if-range)#spanning-tree guard rootsw1(config-if-range)#*Aug 7 06:36:01.091: %SPANTREE-2-ROOTGUARD_CONFIG_CHANGE: Root guard enabled on port Ethernet0/0.*Aug 7 06:36:01.091: STP: VLAN0001 we are the spanning tree root*Aug 7 06:36:01.091: %SPANTREE-2-ROOTGUARD_CONFIG_CHANGE: Root guard enabled on port Ethernet0/1.*Aug 7 06:36:01.091: STP: VLAN0001 we are the spanning tree root//将SW3的优先级更改为4096SW3(config)#spanning-tree vlan 1 priority 4096sw1#debug spanning-tree events Spanning Tree event debugging is on*Aug 7 06:39:33.050: STP: VLAN0001 heard root 4097-aabb.cc00.3000 on Et0/1*Aug 7 06:39:33.050: supersedes 32769-aabb.cc00.1000*Aug 7 06:39:33.050: %SPANTREE-2-ROOTGUARD_BLOCK: Root guard blocking port Ethernet0/1 on VLAN0001.*Aug 7 06:39:33.050: STP[1]: Generating TC trap for port Ethernet0/1*Aug 7 06:39:33.050: STP: VLAN0001 Et0/1 -&gt; blocking*Aug 7 06:39:33.050: STP: VLAN0001 heard root 4097-aabb.cc00.3000 on Et0/0*Aug 7 06:39:33.050: supersedes 32769-aabb.cc00.1000*Aug 7 06:39:33.050: STP[1]: Generating TC trap for port Ethernet0/0*Aug 7 06:39:33.050: STP: VLAN0001 Et0/0 -&gt; blocking*Aug 7 06:39:35.054: STP: VLAN0001 heard root 4097-aabb.cc00.3000 on Et0/0*Aug 7 06:39:35.054: supersedes 32769-aabb.cc00.1000*Aug 7 06:39:35.055: STP: VLAN0001 heard root 4097-aabb.cc00.3000 on Et0/1*Aug 7 06:39:35.055: supersedes 32769-aabb.cc00.1000 根不一致状态 12345//将SW3的优先级更改为原来的优先级，则SW1自动恢复为根桥SW3(config)#spanning-tree vlan 1 priority 32768//SW1上提示RootGuard不再阻塞*Aug 7 06:52:51.986: %SPANTREE-2-ROOTGUARD_UNBLOCK: Root guard unblocking port Ethernet0/1 on VLAN0001. 7、Loop Guard（1）对象：针对单向链路故障配置；存在端口不能正常发送或接收BPDU的情况 （2）功能：开启Loop Guard的端口，监听BPDU，如果没有监听到，则会进入到环路不一致状态，相当于阻塞端口（不会是转发状态）；只有当重新监听到BPDU，该端口会自动恢复 （3）配置 12//在接口下启用环路保护特性SW3(config-if)#spanning-tree guard loop 如上图所示，SW1为根桥。由于SW2和SW3之间的单向链路故障，导致SW3接收不到SW2转发的BPDU。在未启用环路保护特性时，SW3上的Blocking端口会在最大超时时间（20s）到期后过渡到STP Listening状态，并且会在两倍转发延迟（30s）之后进入Forwarding状态并产生环路。若启用了环路保护特性，SW3上的Blocking端口会在接收不到BPDU的20s后过渡到STP loop-inconsistent状态。处于loop-inconsistent状态的端口则不会发送流量，阻止了环路的产生。 进行必要配置使上图所示的交换机的所有端口都处于转发状态，则会产生环路。在SW3的e0/1端口开启环路防护 1234SW3(config)#int e0/1SW3(config-if)#spanning-tree guard loop*Aug 7 07:17:15.156: %SPANTREE-2-LOOPGUARD_BLOCK: Loop guard blocking port Ethernet0/1 on VLAN0001. 端口状态为环路不一致状态 8、UDLD 在双向链路中，流量可以同时在两个方向上传输。如果链路发生故障，导致流量只能单向传递时，这种链路叫做单向链路。单向链路将导致邻居之间的链路上只有一侧流量传输，这种情况有可能导致生成树拓扑成环。单向链路故障检测（UDLD）可帮助设备检测出自身的单向链路，并将问题端口关闭。 在启用了UDLD的情况下，交换机会周期性地向邻居发送UDLD包，若收到了对端回应的echo包，则判定链路工作正常（双向）；若在指定时间内邻居并未回应echo包，链路则被认为是单向链路，端口将进入err-disabled状态。链路两端的设备必须同时支持UDLD协议，才能正确地识别和关闭单向链路。 在UDLD检测到了单向链路之后，根据配置的以下两种模式，可执行两种不同的操作。 普通模式（Normal mode）：端口保持原有状态继续工作。UDLD仅会将此端口标记为”不确定”状态，并生成一条syslog消息 激进模式（Aggressive mode）：交换机会每秒发送一次UDLD包尝试重新建立连接，8s过后，如果仍未收到echo包，会将端口置于err-disabled状态 配置 12345678//在全局启用UDLD，对于普通模式，使用enable关键字，而激进模式则使用aggressive关键字SW3(config)#udld &#123; enable | aggressive &#125; //基于端口启用UDLDSW3(config-if)#udld port [ aggressive ]//查看端口的UDLD状态SW3#show udld //重置所有UDLD关闭的顿口苦SW3#udld reset","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"}]},{"title":"生成树协议","slug":"STP","date":"2020-09-15T00:32:33.000Z","updated":"2020-10-11T11:38:31.398Z","comments":true,"path":"2020/09/15/STP/","link":"","permalink":"http://shain.top/2020/09/15/STP/","excerpt":"","text":"1、生成树协议概述 冗余的网络拓扑可以消除单点故障所导致的网络障碍。但从另一个角度看，冗余的网络拓扑也会带来其他的问题，如2层环路。使用STP技术可以在冗余的环境中消除潜在的2层环路问题。 1.1、STP概述 如下图所示的冗余环境中，使用STP可以阻塞环路上的某个特定的端口，保证每个网段上只存在一条活动路径。 在冗余的网络拓扑环境中，若未启用STP，则会导致以下问题： 广播风暴——冗余网络上的每台交换机会不断地泛洪广播帧 多帧复制——目的站点可能会收到同一单播数据帧的多份拷贝，这可能会导致接收协议的一些问题 MAC数据库不稳定——当一台交换机的不同端口收到了相同的帧拷贝时，这种现象称为MAC地址漂移。MAC地址表会将帧的源MAC地址和接收到此帧的入站端口对应到一条表项中。若存在环路，同一个MAC地址可能会从多个端口上接收到，这就造成了MAC地址表的不稳定。 STP技术可以在支持物理路径冗余的同时，消除网络环路造成的影响。通过STP的选举机制，将多余链路进行阻塞，只保留一条活跃链路用于对数据流量的处理，被阻塞掉的链路同时也作为备用链路。当去往某个网段的连通性出现了问题，STP会自动启用之前的阻塞路径，并重新建立连通性。STP所使用桥协议数据单元（BPDU）来交换STP信息，并使用BPDU确定网络拓扑信息，以及对拓扑中设备添加、删除或修改的动作做出响应。交换机默认每2s向所有端口发送一次BPDU。 1.2、STP标准 1.3、STP选举机制 根桥——拥有最小桥ID的交换机被选为根桥 每台交换机拥有唯一的BID，包含桥优先级（默认为32768）和MAC地址 根端口——非根交换机上去往根桥路径最优的端口，用于接收BPDU 最小根路径开销 最小发送者桥ID 最小发送者的端口ID 指定端口——用于发送或转发配置BPDU 最小根路径开销 最小发送者桥ID 最小发送者的端口ID 非指定端口——既不转发数据帧，也不会将在该网段接收到的数据包源MAC地址填入MAC地址表中 上述端口选举完后，剩下的既不是根端口也不是指定端口的端口成为非指定端口 1.4、BPDU STP使用桥协议数据单元（BPDU）来交换STP信息，包括根桥的选举以及环路的识别等。默认情况下，交换机每2秒发送一次BPDU。BPDU一般分为以下两种类型： 配置BPDU——用于计算STP TCN BPDU——用于通告网络拓扑变化 BPDU帧结构以及各字段含义 协议ID：标识STP 版本号：标识当前的协议版本 消息类型：标识BPDU类型（配置BPDU或TCN BPDU） 标志：用来响应TCN BPDU 根桥ID：标识根桥的桥ID（BID） 根路径开销：标识发送交换机到根桥之间的路径开销 发送方网桥ID：标识发送交换机的BID 端口ID：标识发送端口 消息期限：标识当前BPDU的生存时间 最大期限：标识BPDU的最大超时时间 Hello时间：标识根桥生成配置BPDU的间隔时间 转发延迟：标识交换机端口必须等待侦听（listening）及学习（learning）状态的时间 1.5、STP端口状态 Blocking（阻塞状态）：此时，二层端口为非指定端口，也不会参与数据帧的转发。该端口通过接收BPDU来判断根交换机的位置和根ID，以及在STP拓扑收敛结束之后，各交换机端口应该处于什么状态（是根端口、指定端口还是非指定端口）。在默认情况下，端口会在这种状态下停留20秒钟的时间（最大周期） Listening（侦听状态）：生成树此时已经根据交换机所接收到的BPDU而判断出了这个端口应该参与数据帧的转发。于是，交换机端口就不再满足于接收BPDU，而同时也开始发送其自己的BPDU，并以此通告邻接的交换机该端口会在活动拓扑中参与转发数据帧的工作。在默认情况下，端口会在这种状态下停留15秒钟的时间（转发延迟） Learning（学习状态）：这个二层端口准备参与数据帧的转发，并开始填写CAM表。在默认情况下，端口会在这种状态下停留15秒钟的时间（转发延迟） Forwarding（转发状态）：这个二层端口已经成为了活动拓扑的一个组成部分；它会转发数据帧，并同时收发BPDU Disabled（禁用状态）：这个二层端口不会参与生成树，也不会转发数据帧 1.6、STP拓扑变更 当交换机的某个端口变成了转发状态或阻塞状态时，意味着STP拓扑发生了变更。交换机通过向根端口发送TCN BPDU的方法来通告拓扑变更。这一BPDU不包括实际的变更内容，仅用来通知网络中其他交换机拓扑发生变更这一现象。 拓扑变更处理流程： 当交换机检测到拓扑发生变更时，会沿着根桥的方向发送TCN 上游的交换机接收到TCN以后，首先会回复一个TCA，然后继续沿着根桥的方向发送TCN，直到最后根桥收到TCN 根桥收到TCN后，会回复一个拓扑变更确认（TCA）和一个设置了TC标志位的BPDU给所有的下游交换机，同时将本地的MAC地址表的老化时间从300s缩短至15s——为了实现MAC地址表刷新 下游的交换机收到TC置位的BPDU的时候，也会将本地的MAC地址表老化时间从300s缩短至15s，同时也会继续转发TC置位的BPDU给下游交换机——将TC置位的信息在整个交换网络中泛洪 1.7、PVST+ 增强的每个VLAN生成树是Cisco的一种生成树实现技术。PVST+可为网络中配置的每个VLAN提供一个单独的生成树实例。 与CST不同的是，PVST+可以为每个VLAN运行一个生成树实例，这就意味着在配置有不同VLAN的冗余链路上可以基于不同的VLAN来负载分担流量。 拓扑结构如下所示，进行主次根的配置 指定SW1为VLAN 10的根桥，为VLAN 20的次根桥 12SW1(config)#spanning-tree vlan 10 root primary SW1(config)#spanning-tree vlan 20 root secondary 指定SW2为VLAN 10的次根桥，为VLAN 20的根桥 12SW2(config)#spanning-tree vlan 10 root secondary SW2(config)#spanning-tree vlan 20 root primary 桥优先级默认为32768，对于SW1而言： 设置为root primary后，优先级降低2个4096，加上vlan-id后，优先级变成24586 设置为root secondary后，优先级降低1个4096，加上vlan-id后，优先级变成28692 SW2成为VLAN 20的根桥 关于收敛时间的验证 将SW3的e0/0接口shutdown，观察e0/1端口过渡到forwarding状态所需时间 12345678910111213SW3#debug spanning-tree events Spanning Tree event debugging is onSW3(config)#int e0/0SW3(config-if)#shutdown SW3#*Sep 15 08:37:02.367: STP: VLAN0020 new root port Et0/1, cost 200 //e0/0端口被禁用，则e0/1端口成为根端口*Sep 15 08:37:02.367: STP: VLAN0020 Et0/1 -&gt; listening //直接进入侦听状态*Sep 15 08:37:02.367: STP[20]: Generating TC trap for port Ethernet0/0*Sep 15 08:37:04.372: STP: VLAN0020 sent Topology Change Notice on Et0/1 //通告拓扑变更*Sep 15 08:37:17.367: STP: VLAN0020 Et0/1 -&gt; learning //经过15s，进入学习状态*Sep 15 08:37:32.373: STP[20]: Generating TC trap for port Ethernet0/1*Sep 15 08:37:32.373: STP: VLAN0020 sent Topology Change Notice on Et0/1*Sep 15 08:37:32.373: STP: VLAN0020 Et0/1 -&gt; forwarding //经过30s，进入转发状态 2、快速生成树协议（RSTP） 快速生成树协议（IEEE802.1w，也称为RSTP）在网络拓扑变更时，能够显著地提升生成树重新计算的速度。RSTP会选择一台交换机作为活动生成树拓扑的根，并为交换机上的每个端口分配端口角色，所分配的角色取决于端口是否是STP活动拓扑的一部分。通过在交换机之间使用明确的握手协议，新的根端口和指定端口会立刻过渡到forwarding状态。 2.1、RSTP端口角色根端口（root）：根端口是每台非根网桥上选择出来与根网桥相连的端口。每台交换机上只能有一个根端口。根端口在稳定工作状态的拓扑中处于转发状态 指定端口（designated）：在每个网段中至少会有一个交换机端口作为该网段的指定端口。在拓扑的稳定工作状态下，有指定端口的交换机会在这个网段中接收去往根网桥的数据帧。每个网段只能有一个指定端口。而这个指定端口会处于转发状态。所有与某个特定网段相连的交换机都会侦听所有的BPDU；并判断自己是否要在这个网段中充当指定交换机 替代端口（alternate）：替代端口是用来提供去往根网桥替代路径的端口。替代端口在稳定工作状态的拓扑中处于丢弃状态。替代端口出现在非指定交换机上，并且会在当前的指定端口出现故障时过渡为指定端口。（对根端口进行备份） 备份端口（backup）：备份端口是指定交换机上的一个额外的交换机端口，它的作用是为指定交换机提供一条备份链路。备份端口的端口ID高于指定交换机指定端口的端口ID。在稳定工作状态的拓扑中，备份端口处于丢弃状态。（存在Hub的时候才会出现，对链路进行备份） 禁用端口（disabled）：在生成树工作的过程中，禁用端口不担当任何角色 2.2、RSTP端口状态 RSTP中只存在3种端口状态，它们分别对应于端口可能的3种工作状态：丢弃状态、学习状态和转发状态。RSTP 802.1w丢弃状态代表了802.1D STP的禁用、阻塞和监听状态之和(可以节省20s时间)。 2.3、拓扑变更 RSTP中的TC（拓扑变更）通告是一步到位的。交换机使用向所有非边缘端口发送带有TC位BPDU的方式宣告拓扑变更，这意味着每台交换机都可以直接重新计算生成树。需要借助提议/同意机制，提议该端口为某个角色，如果没问题就同意。通过这种方式，所有的邻居交换机都会得知拓扑变更，因此会各自更新自己的CAM表，无需等待根桥发送TC BPDU。这种方法会导致更多潜在的临时泛洪，不过，可以很快地将拓扑变更通知扩散到整个网络，从而实现快速收敛。 2.4、关于RSTP收敛时间的验证 如下图所示，修改STP的模式为RSTP 将SW3的e0/0端口shutdown，观察e0/1端口过渡到转发状态所需时间 1234567SW3#debug spanning-tree events Spanning Tree event debugging is onSW3(config)#int e0/0SW3(config-if)#shutdown*Sep 15 12:09:40.772: RSTP(20): updt roles, root port Et0/0 going down*Sep 15 12:09:40.772: RSTP(20): Et0/1 is now root port //成为根端口，时间小于1s*Sep 15 12:09:40.777: STP[20]: Generating TC trap for port Ethernet0/1 注意： 如果该端口角色确定为RP，则直接过渡到转发状态 如果该端口角色确定为DP，只能是慢慢过渡 3、多生成树协议（MSTP） 多生成树（MST）将IEEE 802.1w RSTP算法扩展到了多棵生成树中。MST的主要目的是减少网络拓扑中生成树实例的总数量，从而降低交换机的CPU开销。 优势——在实现负载均衡的同时，降低维护生成树实例的个数 实现——将多个vlan加入相同的实例中 MST注意点： name 域名，同一个实例区域中域名要保持一致 revision 修订号，同一个实例区域中修订号要保持一致 vlan的关联表，将多个vlan关联起来，放入同一个实例中 没有划分的vlan会自动划分进MST0中（CIST） 123456789101112131415161718192021222324SW1(config)#spanning-tree mode mstSW1(config)#spanning-tree mst configuration SW1(config-mst)#name jiaohuan //设置域名称SW1(config-mst)#revision 10 //设置修订号SW1(config-mst)#instance 1 vlan 10,20,30 //划分vlan到此关联表SW1(config-mst)#instance 2 vlan 40,50,60SW1(config)#spanning-tree mst 1 root primary //设置SW1为mst1的根桥SW1(config)#spanning-tree mst 2 root secondary //设置SW1为mst2的次根桥SW2(config)#spanning-tree mode mstSW2(config)#spanning-tree mst configuration SW2(config-mst)#name jiaohuanSW2(config-mst)#revision 10SW2(config-mst)#instance 1 vlan 10,20,30SW2(config-mst)#instance 2 vlan 40,50,60SW2(config)#spanning-tree mst 1 root primary //设置SW2为mst1的次根桥SW2(config)#spanning-tree mst 2 root secondary //设置SW2为mst2的根桥SW3(config)#spanning-tree mode mstSW3(config)#spanning-tree mst configuration SW3(config-mst)#name jiaohuanSW3(config-mst)#revision 10SW3(config-mst)#instance 1 vlan 10,20,30SW3(config-mst)#instance 2 vlan 40,50,60 查看MST配置 查看MST摘要信息 查看MST实例映射消息","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"}]},{"title":"关于交换的基础测试","slug":"关于交换的基础测试","date":"2020-09-14T14:31:58.000Z","updated":"2020-09-30T15:53:09.785Z","comments":true,"path":"2020/09/14/关于交换的基础测试/","link":"","permalink":"http://shain.top/2020/09/14/%E5%85%B3%E4%BA%8E%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/","excerpt":"1、实验目的1）掌握VLAN、TRUNK、VTP的作用和配置2）掌握DTP的作用和配置3）掌握DHCP及DHCP中继的作用和配置4）掌握以太网通道技术的作用和配置","text":"1、实验目的1）掌握VLAN、TRUNK、VTP的作用和配置2）掌握DTP的作用和配置3）掌握DHCP及DHCP中继的作用和配置4）掌握以太网通道技术的作用和配置 2、拓扑结构 3、实验步骤（1）在该园区网络中有4个VLAN，分别为VLAN10、VLAN20、VLAN30和VLAN40，其中DHCP_SRV和PC1在VLAN10中，PC2、PC3分别在VLAN20、VLAN30和VLAN30中，FTP_SRV和PC4在VLAN40中，其中VLAN10的地址段为192.168.10.0/24，VLAN20的地址段为192.168.20.0/24，VLAN30的地址段为192.168.30.0/24，VLAN40的地址段为192.168.40.0/24，各VLAN主机的网关都设置为其网段中可用的最后一个主机地址，并且设置DHCP服务器的IP地址为192.168.10.100/24，其他主机通过DHCP方式获取IP地址、园区网络外部的地址自己规划 在SW1和SW2上创建VLAN，并将端口划分进相应的VLAN 123456789101112131415SW1(config)#vlan 10,20SW1(config)#int range e0/0,e0/2SW1(config-if-range)#switchport mode access SW1(config-if-range)#switchport access vlan 10SW1(config)#int e0/1SW1(config-if)#switchport mode access SW1(config-if)#switchport access vlan 20SW2(config)#vlan 30,40SW2(config)#int e0/0 SW2(config-if)#switchport mode access SW2(config-if)#switchport access vlan 30SW2(config)#int range e0/1-2SW2(config-if-range)#switchport mode access SW2(config-if-range)#switchport access vlan 40 配置IP地址 12345678910111213141516171819202122232425262728293031323334353637DHCP_SRV(config)#int e0/0DHCP_SRV(config-if)#ip address 192.168.10.100 255.255.255.0DHCP_SRV(config-if)#no shutdown R1(config)#int e0/0R1(config-if)#ip address 10.10.10.1 255.255.255.0R1(config-if)#no shutdown R1(config)#int s1/0R1(config-if)#ip address 202.101.100.1 255.255.255.0R1(config-if)#no shutdown ISP(config)#int s1/0ISP(config-if)#ip address 202.101.100.2 255.255.255.0ISP(config-if)#no shutdown ISP(config)#int e0/0ISP(config-if)#ip address 200.100.100.1 255.255.255.0ISP(config-if)#no shutdownWeb_SRV(config)#int e0/0Web_SRV(config-if)#ip address 200.100.100.2 255.255.255.0Web_SRV(config-if)#no shutdown SW1(config)#int e0/3 SW1(config-if)#ip address 10.10.10.2 255.255.255.0SW1(config-if)#no shutdown SW1(config)#int vlan 10SW1(config-if)#ip address 192.168.10.254 255.255.255.0 SW1(config-if)#no shutdown SW1(config)#int vlan 20SW1(config-if)#ip address 192.168.20.254 255.255.255.0SW1(config-if)#no shutdown SW1(config)#int vlan 30SW1(config-if)#ip address 192.168.30.254 255.255.255.0SW1(config-if)#no shutdownSW1(config)#int vlan 40SW1(config-if)#ip address 192.168.40.254 255.255.255.0SW1(config-if)#no shutdown （2）采用合适的方式完成交换机链路间的TRUNK配置，并采用标准的封装模式 在SW1和SW2之间的链路封装802.1Q，并关闭DTP协商，更改native vlan为999 1234567891011SW1(config)#int range e1/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW1(config-if-range)#switchport nonegotiateSW1(config-if-range)#switchport trunk native vlan 999SW2(config)#int range e1/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk SW2(config-if-range)#switchport nonegotiate SW2(config-if-range)#switchport trunk native vlan 999 （3）设置SW1的VTP模式为Server，SW2的VTP模式为Client，并且设置VTP域名为shain，密码为CCIEPASS，实现该园区网络的VLAN信息同步 123456SW1(config)#vtp domain shainSW1(config)#vtp password CCIEPASSSW1(config)#vtp mode server SW2(config)#vtp password CCIEPASSSW2(config)#vtp mode client 在SW1和SW2上查看VTP的状态信息 此时SW2通过VTP方式学习到SW1上的VLAN （4）使用802.3ad标准构建两交换机间的以太通道链路，要求交换机将EtherChannel的负载均衡设置为src-dst-ip 使用LACP进行交换机之间的链路捆绑 1234567SW1(config)#int range e1/0-1SW1(config-if-range)#channel-group 1 mode active Creating a port-channel interface Port-channel 1SW2(config)#int range e1/0-1SW2(config-if-range)#channel-group 1 mode active Creating a port-channel interface Port-channel 1 查看EtherChannel摘要信息，捆绑成功 将EtherChannel的负载均衡方式设置为src-dst-ip（默认的负载均衡方式即为src-dst-ip） 12SW1(config)#port-channel load-balance src-dst-ipSW2(config)#port-channel load-balance src-dst-ip 在SW1上查看EtherChannel的负载均衡方式 （5）根据需求在DHCP_SRV上建立相应的地址池，并且在各个地址池中排除范围从10到20之间的IP地址空间，同时要求无论FTP_SRV何时接入交换网络都会获取到192.168.40.100/24的地址，完成必要的配置，实现各主机和FTP_SRV可以获取相应的IP地址 在DHCP_SRV上创建地址池并按要求排除IP地址空间 12345678910111213141516171819202122232425262728//创建地址池DHCP_SRV(config)#ip dhcp pool vlan_10DHCP_SRV(dhcp-config)#network 192.168.10.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.10.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8DHCP_SRV(config)#ip dhcp pool vlan_20DHCP_SRV(dhcp-config)#network 192.168.20.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.20.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8DHCP_SRV(config)#ip dhcp pool vlan_30DHCP_SRV(dhcp-config)#network 192.168.30.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.30.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8DHCP_SRV(config)#ip dhcp pool vlan_40DHCP_SRV(dhcp-config)#network 192.168.40.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.40.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8//排除要求的IP地址，并将已使用的IP地址也排除掉DHCP_SRV(config)#ip dhcp excluded-address 192.168.10.10 192.168.10.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.20.10 192.168.20.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.30.10 192.168.30.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.40.10 192.168.40.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.10.100DHCP_SRV(config)#ip dhcp excluded-address 192.168.10.254 DHCP_SRV(config)#ip dhcp excluded-address 192.168.20.254DHCP_SRV(config)#ip dhcp excluded-address 192.168.30.254DHCP_SRV(config)#ip dhcp excluded-address 192.168.40.254DHCP_SRV(config)#ip dhcp excluded-address 192.168.40.100 在DHCP_SRC和SW1上启用OSPF协议 12345678910DHCP_SRV(config)#router ospf 1DHCP_SRV(config-router)#router-id 3.3.3.3DHCP_SRV(config-router)#network 192.168.10.0 0.0.0.255 area 0SW1(config)#router ospf 1SW1(config-router)#router-id 1.1.1.1SW1(config-router)#network 192.168.10.0 0.0.0.255 area 0SW1(config-router)#network 192.168.20.0 0.0.0.255 area 0SW1(config-router)#network 192.168.30.0 0.0.0.255 area 0SW1(config-router)#network 192.168.40.0 0.0.0.255 area 0 在SW1的各VLAN的SVI接口中配置中继地址 由于DHCP_SRV在VLAN10中，所以无需在VLAN10的SVI端口配置中继地址 123456SW1(config)#int vlan 20SW1(config-if)#ip helper-address 192.168.10.100SW1(config)#int vlan 30SW1(config-if)#ip helper-address 192.168.10.100SW1(config)#int vlan 40SW1(config-if)#ip helper-address 192.168.10.100 各主机自动获取IP地址 让FTP_SRV自动获取地址 123FTP_SRV(config)#int e0/0FTP_SRV(config-if)#no shutdown FTP_SRV(config-if)#ip address dhcp 如下图所示，此时通过DHCP方式获取到的IP地址为192.168.40.2，并不符合要求的192.168.40.100 查看DHCP_SRV的DHCP绑定表，可以得到FTP_SRV的电路ID 在DHCP_SRV上清空FTP_SRV的地址绑定信息 1DHCP_SRV#clear ip dhcp binding 192.168.40.2 在DHCP_SRV上创建FTP_SRV专用的地址池，与FTP_SRV的电路ID进行绑定 1234DHCP_SRV(config)#ip dhcp pool FTP_SRVDHCP_SRV(dhcp-config)#host 192.168.40.100 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.40.254DHCP_SRV(dhcp-config)#client-identifier 0063.6973.636f.2d61.6162.622e.6363.3030.2e35.3030.302d.4574.302f.30 在FTP_SRV上使用DHCP方式获取IP地址，此时获取到的IP地址为192.168.40.100，符合要求 （6）完成必要配置，实现各主机可以访问ISP上的Web_SRV 在R1和SW1上运行OSPF协议，实现内网的可达性 123456R1(config)#router ospf 1R1(config-router)#router-id 2.2.2.2R1(config-router)#network 10.10.10.0 0.0.0.255 area 0SW1(config)#router ospf 1SW1(config-router)#network 10.10.10.0 0.0.0.255 area 0 此时PC3可以访问R1 在R1上配置默认路由，指定出接口为s1/0，并在OSPF进程下发默认路由 123R1(config)#ip route 0.0.0.0 0.0.0.0 s1/0R1(config)#router ospf 1R1(config-router)#default-information originate 指定Web_SRV的网关为ISP的e0/0接口的地址200.100.100.1 1Web_SRV(config)#ip default-gateway 200.100.100.1 此时实现了R1可以访问Web_SRV 在R1上配置PAT，实现内网主机可以访问Web_SRV 123456R1(config)#access-list 1 permit 192.168.0.0 /16 //ACL用于匹配内网主机R1(config)#ip nat inside source list 1 interface s1/0 overload R1(config)#int e0/0R1(config-if)#ip nat inside R1(config)#int s1/0R1(config-if)#ip nat outside 在R1上查看地址转换表，可知在R1上进行了地址转换","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"DHCP","slug":"DHCP","permalink":"http://shain.top/tags/DHCP/"},{"name":"VTP","slug":"VTP","permalink":"http://shain.top/tags/VTP/"},{"name":"EtherChannel","slug":"EtherChannel","permalink":"http://shain.top/tags/EtherChannel/"}]},{"title":"SVI回顾","slug":"SVI回顾","date":"2020-09-10T16:14:48.000Z","updated":"2020-09-12T15:21:16.552Z","comments":true,"path":"2020/09/11/SVI回顾/","link":"","permalink":"http://shain.top/2020/09/11/SVI%E5%9B%9E%E9%A1%BE/","excerpt":"SVI，即交换虚拟接口，是在多层交换机上配置的一种虚拟接口，如下图所示。管理员可以为任何交换机上配置的VLAN创建SVI接口。每个VLAN只能关联一个SVI接口。SVI并不是真实存在的物理接口，但此接口可以与路由器接口执行同样的VLAN操作功能，为所有出入其VLAN端口的数据包提供3层转发功能。","text":"SVI，即交换虚拟接口，是在多层交换机上配置的一种虚拟接口，如下图所示。管理员可以为任何交换机上配置的VLAN创建SVI接口。每个VLAN只能关联一个SVI接口。SVI并不是真实存在的物理接口，但此接口可以与路由器接口执行同样的VLAN操作功能，为所有出入其VLAN端口的数据包提供3层转发功能。 默认情况下，交换机会为默认VLAN（VLAN 1）创建一个SVI接口，以允许远程管理交换机。除此之外的SVI都需要管理员手动添加。当用户首次进入VLAN接口配置模式时，就会创建一个SVI。值得注意的是，此处使用的VLAN编号应与802.1Q封装Trunk链路上数据帧携带的VLAN标签，或access端口上配置的VLAN ID一致。管理员要为每个VLAN的SVI分配一个IP地址，用于对应VLAN流量的路由选择。创建SVI时，首先应确保VLAN数据库中存在该VLAN，对于数据库中的VLAN，可以通过手动配置或通过VTP进行学习。 关于SVI的配置，应注意以下三点 存在该VLAN 有端口放行该VLAN SVI端口需要激活（no shutdown） 以下进行SVI配置，拓扑图如下所示 为各PC配置IP地址和网关 12345678910111213141516171819PC_A1(config)#int e0/0PC_A1(config-if)#ip address 192.168.10.1 255.255.255.0PC_A1(config-if)#no shutdownPC_A1(config)#ip default-gateway 192.168.10.254 PC_B1(config)#int e0/0PC_B1(config-if)#ip address 192.168.20.1 255.255.255.0PC_B1(config-if)#no shutdown PC_B1(config)#ip default-gateway 192.168.20.254 PC_A2(config)#int e0/0PC_A2(config-if)#ip address 192.168.10.2 255.255.255.0PC_A2(config-if)#no shutdown PC_A2(config)#ip default-gateway 192.168.10.254PC_B2(config)#int e0/0PC_B2(config-if)#ip address 192.168.20.2 255.255.255.0PC_B2(config-if)#no shutdown PC_B2(config)#ip default-gateway 192.168.20.254 在DSW1和DSW2上创建VLAN，并将连接PC的端口配置成access，划分到相应的VLAN 1234567891011121314151617DSW1(config)#vlan 10DSW1(config)#vlan 20DSW1(config)#int e0/0DSW1(config-if)#switchport mode access DSW1(config-if)#switchport access vlan 10DSW1(config)#int e0/1DSW1(config-if)#switchport mode access DSW1(config-if)#switchport access vlan 20DSW2(config)#vlan 10DSW2(config)#vlan 20DSW2(config)#int e0/0DSW2(config-if)#switchport mode access DSW2(config-if)#switchport access vlan 10DSW2(config)#int e0/1DSW2(config-if)#switchport mode access DSW2(config-if)#switchport access vlan 20 在DSW1和DSW2相连的端口上配置trunk 1234567DSW1(config)#int e0/2DSW1(config-if)#switchport trunk encapsulation dot1q DSW1(config-if)#switchport mode trunk DSW2(config)#int e0/2DSW2(config-if)#switchport trunk encapsulation dot1q DSW2(config-if)#switchport mode trunk 在DSW1和DSW2上开启路由功能（思科默认开启） 123DSW1(config)#ip routingDSW2(config)#ip routing 在DSW1为VLAN 10和VLAN 20的SVI配置IP地址，作为PC的网关 123456DSW1(config)#int vlan 10DSW1(config-if)#ip address 192.168.10.254 255.255.255.0DSW1(config-if)#no shutdown DSW1(config)#int vlan 20DSW1(config-if)#ip address 192.168.20.254 255.255.255.0DSW1(config-if)#no shutdown 此时PC_A1可以ping通PC_B1 PC_A1发起的流量经过DSW1上的VLAN 10的SVI，继而会被路由至VLAN 20的SVI接口，随后发送给PC_B1 PC_A1也可以ping通PC_B2 使用SVI实现VLAN间路由的优势 速度远远快于单臂路由器，因为流量的路由和交换处理都是通过硬件完成的 无需使用交换机到路由器的外部链路进行路由 没有单条链路的限制。可以在交换机之间使用2层EtherChannel来增加带宽 因为数据的处理无需离开交换机，因此延迟更低 使用SVI实现VLAN间路由的劣势 需要3层交换机来执行VLAN的路由，而使用3层交换机所需成本更高","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SVI","slug":"SVI","permalink":"http://shain.top/tags/SVI/"},{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"}]},{"title":"在交换网络中部署EtherChannel技术","slug":"在交换网络中部署EtherChannel技术","date":"2020-09-05T08:09:30.000Z","updated":"2020-09-09T05:22:34.556Z","comments":true,"path":"2020/09/05/在交换网络中部署EtherChannel技术/","link":"","permalink":"http://shain.top/2020/09/05/%E5%9C%A8%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%83%A8%E7%BD%B2EtherChannel%E6%8A%80%E6%9C%AF/","excerpt":"在有些网络环境中，用户与资源之间的距离也许非常远，交换机与交换机之间或交换机与服务器之间的链路可能会变得非常阻塞。虽然通过线路改造可以增加这些链路的带宽，但并不是所有的链路都具备带宽升级的条件。因此，在以最大化节省现有投资为目的的前提下，EtherChannel技术应运而生。EtherChannel技术可以将多条物理链路捆绑成一条逻辑链路来解决流量拥塞的问题，在提升带宽的同时，也实现了冗余性。","text":"在有些网络环境中，用户与资源之间的距离也许非常远，交换机与交换机之间或交换机与服务器之间的链路可能会变得非常阻塞。虽然通过线路改造可以增加这些链路的带宽，但并不是所有的链路都具备带宽升级的条件。因此，在以最大化节省现有投资为目的的前提下，EtherChannel技术应运而生。EtherChannel技术可以将多条物理链路捆绑成一条逻辑链路来解决流量拥塞的问题，在提升带宽的同时，也实现了冗余性。 1、EtherChannel技术背景 EtherChannel技术最初是由Cisco开发的一种LAN交换机之间的链路技术，用来将多个百兆或千兆以太网端口放入一个逻辑的通道中。EtherChannel拥有以下多种优势： 利用已有交换机端口。无需升级交换机互联链路，从而节省投资成本。 大多数的配置都可以在EtherChannel接口下完成，而不需要分别在每个端口进行配置，这可以保证交换机之间端口配置的一致性。 EtherChannel技术支持多条链路的负载均衡。根据硬件平台的不同，可以在多条物理链路之间部署多种方式的负载均衡，如基于源MAC和目的MAC，或是基于源IP和目的IP。 除了交换机，其他网络设备也广泛地支持EtherChannel技术。在任何情况下，EtherChannel创建的都是一对一的逻辑链路。EtherChannel链路可以部署在两台交换机之间，也可以部署在启用了EtherChannel服务的服务器和交换机之间，但是，同一条EtherChannel不能向两台不同的交换机发送流量。一条EtherChannel链路的两端始终只连接着两台设备，而且这两台设备上EtherChannel组成员的端口配置也必须相同。 EtherChannel创建的汇聚链路会被看做是一条逻辑链路。当两台交换机之间存在多条EtherChannel链路时，生成树可能会阻塞其中的一条来防止出现环路。当生成树阻断了某条冗余链路时，也就阻断了一条EtherChannel链路，这条EtherChannel链路中的所有端口也都会被阻塞。如果仅有一条EtherChannel链路，捆绑中所有物理端口都会处于Active状态。因为对于生成树算法来说，多条物理链路捆绑后的EtherChannel链路是一条逻辑链路。如果EtherChannel中的某条物理链路出现了故障，EtherChannel会自动更新其捆绑带宽，对应的STP开销也会重新计算。 注：在三层交换机上，可以将设备的交换端口转化成路由端口。转换后的三层端口同样可以配置EtherChannel链路。在使用了例如VSS（虚拟交换系统）或vPC（虚拟端口通道）技术后，可以在一台接入层交换机和两台不同的汇聚层交换机之间创建EtherChannel链路。 2、EtherChannel协商协议 可以使用以下三种机制之一来创建EtherChannel LACP： IEEE标准协商协议 PAgP： Cisco私有协商协议 静态配置： 无协商协议 LACP 链路汇聚控制协议（LACP）是一种由IEEE定义的标准（802.3ad），允许将多个 物理端口捆绑到一起形成一个逻辑通道。LACP允许交换机发送LACP数据包来与对端自动协商捆绑通道。由于LACP属于IEEE制定的业界标准，因此可以在不同厂商设备的环境中协商EtherChannel链路。LACP会检查两台交换机的配置一致性以及链路状态，用来确保EtherChannel创建时，所有端口配置有相同的端口速率、双工模式、VLAN信息等。在通道建立之后，任一端口的配置修改都会影响通道另一端的端口状态。 LACP数据包会在启用了EtherChannel功能的端口上进行交换。接收方会将对端的端口属性与自身的端口属性进行比较。LACP会为EtherChannel端口分配角色。带有最低的系统优先级的交换机将决定哪些活动端口可以加入EtherChannel。端口根据其优先级选举出Active端口。数值越低表示越优先。一般来说，一个EtherChannel最大支持16条链路。同一时间只能有8条处于Active（活动）状态。其余8条非Active端口将处于Standby（备用）状态。如果某条Active链路发生故障，Standby端口将接管成为Active端口。 两台交换机之间建立EtherChannel的最大Active链路数量是可变的 LACP操作模式如下 ①Active：使端口进入主动协商状态，发送LACP数据包主动与其他接口进行协商 ②Passive：使端口进入被动协商状态，对LACP数据包做出响应 ③On：强制端口形成EtherChannel，不需要使用LACP或PAgP进行协商 PAgP 端口聚合协议（PAgP）提供了与LACP类似的协商优点。PAgP是Cisco私有协议，因此只能运行在Cisco设备上。PAgP数据包会在启用了EtherChannel功能的端口上进行交换，每30s发送过一次。接收方会将对端的端口属性与自身的端口属性进行比较，具有相同属性的端口将被捆绑进同一个EtherChannel中。PAgP只能在配置有相同VLAN或Trunk属性的端口上形成EtherChannel。如果捆绑中的端口修改了配置，那么PAgP也会重新协商EtherChannel的参数。例如，捆绑中的某个端口的速率、双工模式或VLAN信息做了配置修改，PAgP将会重新考虑捆绑中其他端口的参数。PAgP与LACP协议之间不能兼容。 PAgP操作模式如下： ①Desirable：使端口进入主动协商的状态，发送PAgP数据包 ②Auto：使端口进入被动协商的状态，对PAgP数据包做出响应 ③On：强制端口不使用PAgP而形成EtherChannel，不会交换PAgP数据包 3、EtherChannel配置实例 LACP验证 ①首先将交换机之间的端口配置成Trunk 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ②在SW1上配置EtherChannel，创建端口组1，模式为Active 123SW1(config)#int range e0/0-1SW1(config-if-range)#channel-group 1 mode active Creating a port-channel interface Port-channel 1 ③在SW2上配置EtherChannel，创建端口组1，模式为Passive 123SW2(config)#int range e0/0-1SW2(config-if-range)#channel-group 1 mode passive Creating a port-channel interface Port-channel 1 配置后，两个端口将被捆绑到channel-group 1中。由于使用了active关键字，因此将使用LACP协议进行协商。SW1配置了LACP的active模式，SW2配置了LACP的passive模式，因此EtherChannel可以协商成功。 ④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式 123456SW1(config)#int port-channel 1SW1(config-if)#switchport trunk encapsulation dot1q SW1(config-if)#switchport mode trunk SW2(config)#int port-channel 1SW2(config-if)#switchport trunk encapsulation dot1q SW2(config-if)#switchport mode trunk ⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息 如下图所示，port-channel 1是一个正在使用的2层EtherChannel（SU标志）。协商协议使用的是LACP，捆绑成功的端口包括Ethernet 0/0和Ethernet 0/1（P标志） ⑥在SW1上查看Ethernet 0/0和port-channel 1的信息，可知带宽变为原来的两倍 PAgP验证 ①将交换机之间的端口配置成Trunk 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ②在SW1上配置EtherChannel，创建端口组1，模式为Desirable 123SW1(config)#int range e0/0-1SW1(config-if-range)#channel-group 1 mode desirable Creating a port-channel interface Port-channel 1 ③在SW2上配置EtherChannel，创建端口组2，模式为auto 123SW2(config)#int range e0/0-1SW2(config-if-range)#channel-group 2 mode auto Creating a port-channel interface Port-channel 2 ④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式 123456SW1(config)#int port-channel 1SW1(config-if)#switchport trunk encapsulation dot1q SW1(config-if)#switchport mode trunk SW2(config)#int port-channel 2SW2(config-if)#switchport trunk encapsulation dot1q SW2(config-if)#switchport mode trunk ⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息 ⑥在SW2上查看Ethernet 0/0和port-channel 2的信息，可知带宽变为原来的两倍 On验证 ①将交换机之间的端口配置成Trunk 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ②在SW1和SW2上配置EtherChannel，创建端口组1，模式为On 12345SW1(config)#int range e0/0-1SW1(config-if-range)#channel-group 1 mode onSW2(config)#int range e0/0-1SW2(config-if-range)#channel-group 1 mode on Creating a port-channel interface Port-channel 1 ④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息 ⑥在SW2上查看Ethernet 0/0和port-channel 2的信息，可知带宽变为原来的两倍 4、EtherChannel负载均衡方式 EtherChannel中的流量可以分担到捆绑中的每条链路上。不过，流量并不是严格平均分布到每条链路上的。数据帧选择EtherChannel链路上哪条链路转发取决于哈希算法的结果，不同的设备平台使用的哈希计算算法也不尽相同。 在同一个EtherChannel的多个端口成员之间实现负载分担是配置EtherChannel的一个重要因素。管理员可以把负载分担选项当作一个规则，从而极大程度上丰富配置的多样性。举例来说，如果某条通道上的流量只去往单一的MAC地址，那么管理员既可以根据目的MAC地址进行配置，使其总是选择通道中的相同链路;也可以根据源地址进行配置，这样做可以实现更好的负载分担。 负载分担会在全局应用于交换机上的所有EtherChannel，可以使用命令port-channel load-balance来实现这项技术。负载分担可以基于以下变量实现： src-mac：源MAC地址 dst-mac：目的MAC地址 src-dst-mac：源和目的MAC地址 src-ip：源IP地址 dst-ip：目的IP地址 src-dst-ip：源和目的IP地址（默认） src-port：源TCP/UDP（用户数据报协议）端口 dst-port：目的TCP/UDP端口 src-dst-port：源和目的TCP/UDP端口 例如，源MAC地址转发是指当数据包被发送给EtherChannel，设备会根据入站数据包的源MAC地址来判断应该将数据包从通道的哪个端口转发出去。于是，来自不同主机的数据包就会从通道的不同端口中转发出去，而来自同一台主机的数据包会从通道的同一端口中转发出去，这就是实现了负载分担。 SW1和SW2之间使用LACP协商建立EtherChannel链路，如下图所示 输入show etherchannel load-balance命令来查看EtherChannel使用的负载均衡信息 此前并未在交换机上配置负载均衡，可见该交换机上默认的负载均衡方式为src-dst-ip，即基于源和目的IP地址进行负载分担 为了测试上图所示的拓扑中每条链路上分布的流量，在SW1上输入clear counters命令清空计数器，即可准确地测试出每条链路分布的流量 12SW1#clear counters Clear &quot;show interface&quot; counters on all interfaces [confirm] 使用扩展ping命令，从PC1上 ping PC3 在SW1上查看两个端口的计数器 可见大多数流量都分布在了E0/0接口上，通过E0/0端口承载 将SW1的负载均衡方式修改为dst-ip 1SW1(config)#port-channel load-balance dst-ip 查看修改后的负载均衡方式","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"EtherChannel","slug":"EtherChannel","permalink":"http://shain.top/tags/EtherChannel/"}]},{"title":"VTP协议","slug":"VTP协议","date":"2020-09-03T15:27:59.000Z","updated":"2020-09-05T07:57:14.244Z","comments":true,"path":"2020/09/03/VTP协议/","link":"","permalink":"http://shain.top/2020/09/03/VTP%E5%8D%8F%E8%AE%AE/","excerpt":"VTP（VLAN Trunking Protocol）用来在整个交换网络中分发和同步VLAN数据库，可以将配置错误和配置不一致等问题导致障碍的几率降至最低。这些问题包括重复的VLAN名称、不正确的VLAN类型，以及安全性违规等。","text":"VTP（VLAN Trunking Protocol）用来在整个交换网络中分发和同步VLAN数据库，可以将配置错误和配置不一致等问题导致障碍的几率降至最低。这些问题包括重复的VLAN名称、不正确的VLAN类型，以及安全性违规等。 1、VTP概述 VTP是一种通过添加、删除、修改VLAN等管理操作，来维护网络内VLAN配置一致性的2层协议。 交换机只能通过802.1Q或ISL Trunk传输VTP消息。Cisco交换机会通过管理VLAN（默认为VLAN 1），使用2层组播数据帧每5分钟传输一次VTP汇总通告。在单台VTP服务器上的VLAN配置会通过Trunk链路宣告给网络中的所有互联交换机。例如，当管理者添加了一个新的VLAN，那么VTP会将VLAN信息宣告给VTP域内的所有交换机，每台交换机会同步VLAN信息，再将这些信息合并成新的VLAN数据库。 VTP域是由一台或多台共享相同VTP配置的互联的交换机组成的，每台交换机只能处于一个VTP域中。默认情况下，Cisco Catalyst交换机处于”no-management-domain”状态（null状态），直到通过Trunk链路收到了带有域名的VTP通告，或手动配置了VTP域名。配置应在VTP服务器上执行，随后会通过Trunk链路宣告给网络中的所有互联交换机。当VTP域名及VTP密码匹配之后，配置信息将会同步。 VTP是Cisco私有的协议。 2、VTP模式 VTP可以工作在3种模式下：服务器（server）模式、客户端（client）模式、透明（transparent）模式。VTP服务器模式是默认的模式，不过在未配置或未学习到 VTP域名时，VLAN信息是不会宣告到网络中的。需要注意的是，VTP消息仅会在Trunk链路上传播。VTP客户端模式与服务器模式相似，在Trunk链路上发送和接收VTP更新。处于VTP客户端模式的交换机无法创建、删除或修改VLAN，其学习到的VLAN都是由域内的VTP服务器模式的交换机所创建的。处于VTP透明模式的交换机对VLAN进行操作时，配置仅会影响到本地交换机，VLAN的修改信息并不会宣告给VTP域中的其他交换机，但是在该模式下的交换机可以将收到的VTP宣告转发出去。三种模式总结如下所示： 服务器模式 可以创建、删除、修改VLAN 可以发送及转发VTP通告 同步VLAN的配置 客户端模式 不能创建、删除、修改VLAN 可以发送及转发VTP通告 同步VLAN的配置 透明模式 可以创建、删除、修改本地VLAN 可以转发VTP通告 不同步VLAN配置 3、VTP版本 Ｃisco Catalyst交换机支持三种不同版本的VTP：版本1、版本2、版本3。不同版本的VTP之间无法通信，因此管理者必须确定使用哪个版本的VTP。此外，出于稳定性方面的考虑，Cisco建议只使用一种版本的VTP。 Ｃisco交换机上默认启用的VTP版本是版本1。相比于旧版本的VTP，新版本的VTP支持以下特性： 与版本无关的透明模式：在VTP版本1中，VTP透明模式的网络设备会检查VTP消息中的域名和版本信息，而且只有当域名和版本号相匹配时才会转发此消息。由于Cisco IOS软件中只支持一个VTP域，因此在VTP版本2中会直接转发VTP消息，而不会检查其版本号。 一致性检查：在VTP版本2中，会对VLAN名称及VLAN编号进行VLAN一致性检查。不过，只有通过命令行界面（CLI）或简单网络管理协议（SNMP）输入的信息才会触发一致性检查，如果新信息是通过VTP消息或NVRAM中读取的，则不会执行一致性检查。如果接收到的VTP消息MD5比对正确，VTP版本2会直接接收此消息，而不会执行一致性检查。 支持令牌环：VTP版本2支持令牌环交换和令牌环VLAN。 支持未识别TLV（Type-Length-Value）：在VTP版本1中，未被识别的VTP消息会被直接丢弃，而VTP版本2会将未识别的消息转发出去并将其保存在NVRAM中。 支持扩展VLAN：VTP版本3可支持VLAN10254094的消息通告（VLAN编号10061024以及4095~4096被保留）。 域名不自动学习：在VTP版本2中，交换机会从接收的VTP信息中自动学习到新的VTP域名。由于这种行为比较危险，因此在VTP版本3中，此功能需要手动强制开启。 更优的安全性：VTP域密码以一种安全的方式传输并存储在交换机数据库中。 更优的数据库宣告机制：只有主用服务器允许更新其他设备，而且每个VTP域内一台主用服务器。 支持多生成树（MST）：VTP版本3加入了对MST进程通告的支持。 4、VTP修剪 VTP修剪（pruning）技术使用VLAN通告消息来判断Trunk连接何时正在泛洪不必要的流量。默认情况下，Trunk连接会承受VTP管理域中所有的VLAN流量，但一般情况下，企业网络中的多数交换机并没有为每个VLAN都配置本地端口。 VTP修剪技术可以将可泛洪的流量限制在合适的范围内，仅允许必要的VLAN流量通过Trunk链路，从而提高链路的可用带宽。如下图所示的交换网络启用了VTP的修剪功能，从Red VLAN中的主机或工作站发出的广播流量不会转发给交换机3、5和6，因为Red VLAN已经在交换机2、4的链路上被修剪掉了。 无论是否使用了VTP修剪功能，Catalyst交换机都会为每个VLAN运行一个STP实例，即使VLAN中没有活动端口，或VTP修剪已经将VLAN从接口上移除了出去。因此，VTP修剪能够防止将流量泛洪传播给没有特定VLAN成员的交换机。不过，VTP修剪不会将已被修剪的VLAN信息从交换机上删除。 5、VTP认证 管理员可以使用VTP密码特性来增强VTP域的安全性。必须要保证VTP域内的所有交换机使用了相同的密码及域名；否则，交换机无法成为VTP域的成员。Cisco交换机使用MD5算法将密码编码成16字节的密码。这些密码会在VTP汇总通告中进行传播。在VTP中，密码是区分大小写的，长度为8~64个字符。建议在所有VTP域中使用VTP认证特性。 6、VTP通告 VTP通告会在整个管理域中泛洪。交换机默认每隔5分钟发送过一次VTP通告，当VLAN的配置发生变化时会触发发送VTP通告。VTP通告使用组播帧在native VLAN（默认为VLAN 1）中以不打标签的方式传播。每个VTP通告中都包含了一个配置修订号。配置修订号越高，表示VLAN信息越新。配置修订号（configuration revision number）是VTP中非常重要的参数。每次VTP服务器在对VLAN进行操作（增加、删除、修改VLAN信息）时，都会将配置修订号加1。随后VTP服务器发送的VTP通告将带有新的配置修订号。如果VTP域内的其他交换机收到了带有更高配置修订号的VTP通告，将会使用新收到的VLAN信息更新自身的VLAN配置。由于VTP透明模式的交换机不会与域内的其他交换机同步VLAN的信息，所以其配置修订号或VLAN数据库将不会改变（始终为0）。 注意：根据VTP的更新规则，如果一台删除了所有VLAN并带有更高的配置修订号的VTP服务器加入到VTP域中，那么域内所有设备上的VLAN都会被覆盖删除 设备在接收到VTP通告后，需要对一些参数进行检查，之后才会合并其中的VLAN信息。首先就是管理域名和密码必须与本地交换机配置的一致。其次，如果配置修订号比当前交换机的高时，交换机才会合并这条VLAN通告信息。在许多Cisco Catalyst交换机上，可以通过修改VTP域名称的方式重置配置修订号；还可以将其模式修改成透明模式，再改回先前的服务器或客户端模式。这两种方法都可以让配置修订号归零。 7、VTP消息类型 汇总通告（Summary Advertisement） 默认情况下，Catalyst交换机会每5分钟发送一次汇总通告消息。汇总通告消息会通知邻接Catalyst交换机当前的VTP域名及配置修订号。当交换机接收到汇总通告数据包时，会将数据包中的域名与本地配置的VTP域名相比较。如果名称不同，交换机就会忽略这个数据包。如果域名相同，交换机会继续比较配置修订号，如果自身的配置修订号高于或等于接收数据包的修订号，数据包也会被忽略。如果本地的配置修订号比收到的低，交换机则会发送一个请求通告消息。 子集通告（Subnet Advertisement） 当管理员在Catalyst交换机上添加、删除或修改VLAN时，配置修订号会相应地增加，并且会发送一条汇总通告消息。随后，还会发送一条或多条子集通告消息。每条自己通告包含一个VLAN信息列表。如果VLAN的数量很多，就会以多条子集通告的形式通告所有VLAN。 请求通告（Request Advertisement） 当交换机重启、VTP域名被修改或当交换机收到了一个配置修订号高于自身的VTP汇总通告时，交换机会发送VTP请求通告消息。在收到了一个请求通告后，VTP设备会发送一条汇总通告消息，随后再发送一条或多条子集通告消息。 8、VTP配置实例 VTP配置所使用的拓扑如下图所示，其中SW1配置成了VTP服务器模式；SW2配置成了VTP客户端模式；SW3配置成了透明模式 在进行VTP配置前，应注意将三台交换机之间的链路配置成Trunk链路，因为VTP消息仅会在Trunk链路上传播 在所有交换机上配置VTP，SW1配置成服务器模式，SW2配置成客户端模式，SW3配置成透明模式 默认状态下的交换机运行的是VTP版本1 1234567891011121314SW1(config)#vtp password ciscoSW1(config)#vtp mode serverSW1(config)#vtp domain shainSW1(config)#vtp version 1SW2(config)#vtp password ciscoSW2(config)#vtp mode client SW2(config)#vtp domain shainSW2(config)#vtp version 1SW3(config)#vtp password ciscoSW3(config)#vtp mode transparent SW3(config)#vtp domain shainSW3(config)#vtp version 1 在SW2上输入命令show vtp status查看本交换机的VTP状态信息 能看到SW2配置成了VTP客户端模式（client），处于VTP域shain内 当前交换机上只有5个默认的VLAN：VLAN1和VLAN1002~1005。VTP配置修订号为0。此值为0以为着这台交换机的VLAN数据库未做任何修改。每次对VLAN进行操作（增加、删除、修改），配置修订号都会加1。 在SW1上输入命令show vtp status 可以看到SW1配置成了VTP服务器模式（server） 与SW2一样，当前设备上只有默认VLAN。VTP配置修订号为0，VTP域名为shain。 在SW3输入命令show vtp status SW3配置成了VTP透明模式（transparent） 和SW1、SW2一样，当前设备上只有默认VLAN。VTP配置修订号为0，VTP域名为shain 在SW1上创建VLAN 10 1SW1(config)#vlan 10 注意：在VTP客户端模式下是无法添加VLAN的。若在SW2上尝试添加VLAN 5，SW2则会提示如下信息： SW2(config)#vlan 5VTP VLAN configuration not allowed when device is in CLIENT mode. 在SW1上检查VLAN数据库及VTP状态 使用命令show vlan和命令show vtp status VLAN 10此时已经出现在了SW1的数据库中 SW1上的配置修订号也增加到了1 检查SW2上的VLAN数据库和VTP状态 使用命令show vlan和命令show vtp status 由于SW2为VTP客户端模式，因此从SW1学习到了VLAN 10 SW2当前的配置修订号与SW1相同，代表两台交换机拥有相同的VLAN数据库 检查SW3上的VLAN数据库和VTP状态 使用命令show vlan和命令show vtp status 由于SW3处于VTP透明模式，因此永远不会和其他处于任何VTP模式的交换机同步自身的VLAN数据库 从某种程度上讲，启用VTP透明模式就等同于关闭了VTP功能 注意此时SW3上并没有VLAN 10 VTP透明模式的交换机配置修订号始终为0 在SW3上创建VLAN 20 1SW3(config)#vlan 20 在三台交换机上检查VLAN 20是否存在 从以下显示结果中可以看出VTP透明模式的交换机可以创建、删除本地VLAN，但是不会将本地VLAN的信息通告给其他交换机 VLAN 20仅存在与SW3上 9、VTP配置覆盖（VTP常见问题） VTP的一个常见问题就是由于管理员的粗心大意，错误地将整个网络中的VLAN数据库配置删除。因此，当向网络中添加一台交换机时，一定不能将错误的信息注入到现网中。如下图所示，SW1是一台VTP服务器，SW2和SW3是VTP客户端。所有交换机同步后的配置修订号均为12，并带有VLAN 10、20、30和40。每台交换机上有多个用户连接到不同的VLAN。 查看SW1上的VTP状态和VLAN数据库信息 SW2和SW3有着与SW1同样的配置修订号及VLAN信息，这是因为VTP已经完全同步 现在假定SW2发生了故障，从配线间取出了另外一台交换机来替代SW2 backup交换机配置了与其他两台交换机相同的VTP域名，VTP的配置修订号为29，比现网中的VTP修订号要高 backup交换机的VLAN信息和VTP信息如下图所示 默认情况下，Cisco IOS VTP服务器和客户端会将VLAN信息保存在flash下的vlan.dat文件中，其中包括了VLAN表以及配置修订号。删除vlan.dat文件并重启交换机可以将VTP和VLAN信息彻底删除，其删除方式根据具体交换机型号而定。 处于VTP透明模式的交换机可以使用show running-config命令查看VLAN和VTP配置，这是由于配置是存放在配置文本文件中的，而不是vlan.dat。因此在VTP透明模式的交换机上执行erase startup-config命令的话，所有的VLAN信息都会被删除。 由于backup交换机带有更高的配置修订号，因此SW1和SW3都会与其同步。分别在SW1和SW3上查看VLAN和VTP状态 VLAN20、30、40将从SW1和SW3上删除，连接到这些VLAN的终端用户也会失去其连通性 查看SW1的VLAN信息和VTP状态 查看SW3上的VLAN信息和VTP状态 因此，当一台带有更高配置修订号的交换机加入到VTP域中时，很有可能会导致重大的网络故障。当VTP客户端交换机加入到网络时，会发送一个自身数据库的汇总通告。也就是说，带有更高配置修订号的交换机，无论是服务器模式还是客户端模式，都会导致现网交换机的VTP配置覆盖（VLAN重新学习）。 10、VTP部署的推荐做法 VTP一般使用在新建网络中，用来减轻VLAN的配置工作。不过，随着网络规模数日渐增大，伴随而来的也有一些风险。如果VTP域内的某台VTP服务器意外地删除了一个VLAN，那么VTP域所在网络都会删除这个VLAN。已经预先配置过VLAN的交换机加入到了网络中，那么VTP域所在网络中的所有交换机的VLAN数据库都可能被覆盖。因此，部署VTP时建议先将所有交换机配置成VTP透明模式，并手动按需添加VLAN，尤其是在大型园区网环境中。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"VTP","slug":"VTP","permalink":"http://shain.top/tags/VTP/"}]},{"title":"NAT和PPP的应用","slug":"NAT和PPP的应用","date":"2020-09-02T15:27:30.000Z","updated":"2020-09-03T01:35:21.332Z","comments":true,"path":"2020/09/02/NAT和PPP的应用/","link":"","permalink":"http://shain.top/2020/09/02/NAT%E5%92%8CPPP%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"1、实验目的1）理解NAT的作用2）理解不同NAT的特点及配置3）理解不同NAT的使用场合4）掌握PPP的PAP和CHAP验证5）理解辅助地址的作用6）掌握NAT的验证和查看命令","text":"1、实验目的1）理解NAT的作用2）理解不同NAT的特点及配置3）理解不同NAT的使用场合4）掌握PPP的PAP和CHAP验证5）理解辅助地址的作用6）掌握NAT的验证和查看命令 2、拓扑结构 3、实验步骤（1）公司COM1和COM2内部网段都为192.168.1.0/24，其中COM1的SRV地址为192.168.1.100/24，COM2的user地址为192.168.1.10/24，COM1内部的其他主机地址自己规划；ISP上的Web_Server地址为211.1.1.1/24，ISP与COM2之间的地址段为202.101.12.0/24，ISP与COM1之间的地址段为202.101.23.0/24，其中COM2连接ISP的接口地址为202.101.12.1/24，COM1连接ISP的接口地址为202.101.23.3/24 IP地址规划如拓扑图所示 （2）要求COM1与ISP之间的PPP链路采用CHAP验证，用户名为20164120，密码为123456 在ISP的s2/0封装PPP，并指定PPP的认证方式为CHAP，指定对方的IP地址为202.101.23.3 在全局下设置用户名和密码，用于chap验证 在COM1上s2/0接口封装PPP，指定IP地址为通过协商获取，填写用户名和密码，并让ISP下发默认路由 查看COM1上的IP地址，可知s2/0接口的IP地址为通过IPCP方式获得 查看COM1的路由表中的静态路由条目，可知存在一条默认路由 （3）在COM1上使用静态NAT实现SRV可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试 在COM1上启用一个loopback接口，用于静态nat的一对一映射 配置静态nat，将SRV的IP地址192.168.1.100映射到COM1上的loopback接口的地址 在ISP上配置静态路由，实现ISP可以访问COM1上的loopback接口 在COM1上配置内部接口和外部接口 此时SRV可以访问ISP上的Web_Server 在COM1上查看nat转换表，可知将192.168.1.100转换成200.100.1.1 由于采用静态NAT，所以此时Web_Server也可以通过200.100.1.1访问SRV 在Web_Server上使用telnet命令远程登录到200.100.1.1，由下图可知此时登录到的设备为SRV （4）在COM1上使用复用地址池的方式实现COM1内的所有用户可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试 在COM1上配置地址池，范围为202.101.23.10~202.101.23.12，掩码为/24 配置ACL，匹配192.168.1.0/24网段的流量 配置复用地址池NAT 此时各PC可以访问Web_Server 在COM1上查看nat转换表，地址在COM1上执行了地址转换 使用debug ip nat命令查看地址转换信息 （5）在COM1和COM2上使用PAT方式实现COM1和COM2内部的用户都可以访问ISP上的Web_Server 由于COM1上已存在ACL 1匹配192.168.1.0/24网段的流量，所以此时可以直接在COM1上配置端口复用NAT 测试COM1内部的用户与Web_Server的连通性 查看地址转换表 在COM2上配置默认路由，下一跳指向ISP的e0/0接口的地址202.101.12.2，确保COM2可以访问Web_Server 在COM2上使用命名的标准ACL匹配192.168.1.0/24网段的流量 配置PAT 指定内外部接口 测试COM2内部用户与Web_Server的连通性 在COM2上查看nat转换表，可知内部用户192.168.1.10在访问外部网络时将地址转换成了202.101.12.1 （6）实现COM2内部的COM2_USER可以远程登录到SRV 在COM1上配置静态nat，将SRV的地址192.168.1.100的tcp23号端口静态映射成200.100.1.1的5656号端口 在COM2_USER上使用telnet命令远程登录到SRV，此时应注意加上端口号","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"NAT","slug":"NAT","permalink":"http://shain.top/tags/NAT/"},{"name":"PPP","slug":"PPP","permalink":"http://shain.top/tags/PPP/"}]},{"title":"ACL的运用","slug":"ACL的运用","date":"2020-09-01T13:46:13.000Z","updated":"2020-09-01T15:58:45.883Z","comments":true,"path":"2020/09/01/ACL的运用/","link":"","permalink":"http://shain.top/2020/09/01/ACL%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"1、实验目的1）掌握ACL的作用2）理解标准和扩展ACL的区别3）熟悉标准和扩展ACL的配置4）掌握ACL的验证和查看命令5）理解命名的ACL的作用与配置","text":"1、实验目的1）掌握ACL的作用2）理解标准和扩展ACL的区别3）熟悉标准和扩展ACL的配置4）掌握ACL的验证和查看命令5）理解命名的ACL的作用与配置 2、拓扑结构 3、实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划 两台PC及三台路由器的IP地址配置如拓扑图所示，此处不再将图贴出 （2）在R2上添加两个loopback接口，loopback1和loopback2，其中loopback1地址为2.2.2.2/24，loopback2地址为22.22.22.22/24 （3）完成必要的配置实现全网可达 在路由器上运行路由协议，实现全网可达 （4）使用标准ACL实现PC1不能访问PC2，并使用ping命令验证结果 标准ACL建议在离目标近的设备上配置，在R3上配置ACL拒绝来自主机172.16.1.1的流量，并在进接口方向调用，此时实现PC1不能访问PC2 （5）使用标准ACL实现只允许PC2远程登录到路由器R2，并使用telnet命令验证结果 在R2上配置ACL，允许主机172.16.3.1的流量，默认隐含一条拒绝所有，即拒绝除PC2之外的流量。在vty中允许其他设备使用telnet远程登录，并在in方向调用ACL 在PC1和PC2上进行测试，此时实现了只允许PC2远程登录到R2 （6）使用标准ACL实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制 在R1上配置ACL，允许loopback1网段，拒绝loopback2网段，然后在e0/1接口的in方向调用 此时实现了R2上的loopback1网段可以访问PC1，而loopback2网段不能 （7）使用命名ACL完整上述标准ACL的需求 实现PC1不能访问PC2 实现只允许PC2远程登录到路由器R2 实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制 （8）使用扩展ACL实现禁止PC1远程登录到R2，对其他访问不做限制 （9）使用扩展ACL实现PC2可以telnet到路由器R1，但不能ping通路由器R1，分别使用ping和telnet验证结果 （10）使用扩展ACL实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果 ICMP echo request –echo的请求包 echo reply –echo的响应包 只有以上两种报文是正常的，那么此时的ping才是能通的 PC1 ping PC2 正常 PC1 给 PC2 发送的echo request是正常的（源是PC1，目标是PC2） PC2给PC1发送的echo reply也是正常的（源是PC2，目标是PC1） PC2 ping PC1 不正常 PC2不能给PC1发送 echo request（源是PC2，目的是PC1） PC2不能接收到来自PC1的echo reply（源是PC1，目的是PC2） （11）使用命名ACL完成上述扩展ACL的需求 实现禁止PC1远程登录到R2，对其他访问不做限制 实现PC2可以telnet到路由器R1，但不能ping路由器R1，分别使用ping和telnet验证结果 实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果 方法一：拒绝PC2向PC1发送icmp的echo-request报文 方法二：拒绝PC1向PC2发送icmp的echo-reply报文","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"ACL","slug":"ACL","permalink":"http://shain.top/tags/ACL/"}]},{"title":"DMVPN验证","slug":"DMVPN验证","date":"2020-09-01T08:14:49.000Z","updated":"2020-09-01T12:07:55.749Z","comments":true,"path":"2020/09/01/DMVPN验证/","link":"","permalink":"http://shain.top/2020/09/01/DMVPN%E9%AA%8C%E8%AF%81/","excerpt":"DMVPN三个阶段 阶段一：中心到节点的设计（Hub-to-Spoke Design） 阶段二：节点到节点的设计（Spoke-to-Spoke Design） 阶段三：分层（基于树的）设计（Hierachical [Tree-Based] Design） 本文将从三个阶段对DMVPN进行验证","text":"DMVPN三个阶段 阶段一：中心到节点的设计（Hub-to-Spoke Design） 阶段二：节点到节点的设计（Spoke-to-Spoke Design） 阶段三：分层（基于树的）设计（Hierachical [Tree-Based] Design） 本文将从三个阶段对DMVPN进行验证 1、拓扑结构 在进行验证之前，确保R1、R3、R4存在默认路由，使得三台路由器之间可以相互ping通 2、phase-1验证 hub端是mGRE，分支端是常规的GRE，分支之间的流量必须经过hub，可以采取关闭水平分割来实现分支之间的路由互相学习，可以在hub端进行手工的路由汇总，来优化分支的路由条目 hub配置 12345678R1(config)#int tunnel 1R1(config-if)#ip address 10.1.1.1 255.255.255.0 //隧道地址R1(config-if)#tunnel source 202.101.12.1 //指定隧道源地址(隧道目的地址可通过nhrp解析)R1(config-if)#tunnel mode gre multipoin //R1为hub，所以指定gre隧道模式为multipointR1(config-if)#tunnel key 100000 //指定隧道的key，可用于隧道的身份验证R1(config-if)#ip nhrp network-id 12345 //指定nhrp的标识，hub和spoke之间的network-id必须一致R1(config-if)#ip nhrp authentication cisco123 //nhrp身份验证R1(config-if)#ip nhrp map multicast dynamic //开启组播映射功能 spoke(R3)配置 12345678910R3(config)#int tunnel 1R3(config-if)#ip address 10.1.1.3 255.255.255.0R3(config-if)#tunnel source 202.101.23.3R3(config-if)#tunnel destination 202.101.12.1R3(config-if)#tunnel key 100000R3(config-if)#ip nhrp network-id 12345R3(config-if)#ip nhrp authentication cisco123 R3(config-if)#ip nhrp map 10.1.1.1 202.101.12.1 //映射hub的逻辑地址到物理地址R3(config-if)#ip nhrp map multicast 202.101.12.1 //映射组播信息到hub地址R3(config-if)#ip nhrp nhs 10.1.1.1 //指定next-hop-server为10.1.1.1 R1和R3的隧道地址可以相互ping通 在R1上查看地址的映射关系——10.1.1.3映射到的公网地址为202.101.23.3 spoke(R4)配置 12345678910R4(config)#int tunnel 1R4(config-if)#ip address 10.1.1.4 255.255.255.0R4(config-if)#ip nhrp network-id 12345R4(config-if)#ip nhrp authentication cisco123R4(config-if)#ip nhrp nhs 10.1.1.1R4(config-if)#ip nhrp map 10.1.1.1 202.101.12.1R4(config-if)#ip nhrp map multicast 202.101.12.1R4(config-if)#tunnel source 202.101.24.4R4(config-if)#tunnel destination 202.101.12.1R4(config-if)#tunnel key 100000 无需再在R1上配置，即可ping通R4的隧道地址，并且也记录了R4的逻辑地址和物理地址的映射关系 分别在R1、R3、R4上各启用一个loopback接口，地址设置如下所示 123456R1(config)#int loopback 1R1(config-if)#ip add 172.16.1.1 255.255.255.0R3(config)#int loopback 1R3(config-if)#ip address 172.16.3.1 255.255.255.0R4(config)#int loopback 1R4(config-if)#ip add 172.16.4.1 255.255.255.0 启用EIGRP协议 1234567891011121314R1(config)#router eigrp 110R1(config-router)#no auto-summary R1(config-router)#network 172.16.1.0 0.0.0.255R1(config-router)#network 10.1.1.0 0.0.0.255R3(config)#router eigrp 110R3(config-router)#no auto-summary R3(config-router)#network 172.16.3.0 0.0.0.255R3(config-router)#network 10.1.1.0 0.0.0.255R4(config)#router eigrp 110R4(config-router)#no auto-summary R4(config-router)#network 172.16.4.0 0.0.0.255R4(config-router)#network 10.1.1.0 0.0.0.255 在R1上查看EIGRP邻居表，可知R1通过1个隧道接口建立了两个邻居关系 在R1的e0/0接口抓包，报文如下图所示，但是此时的报文都为明文显示，需要进行加密 在R1、R3和R4上配置IPSec，保护隧道上的数据 12345678910111213R1(config)#crypto isakmp policy 10R1(config-isakmp)#authentication pre-shareR1(config-isakmp)#exit R1(config)#crypto isakmp key cisco123 address 0.0.0.0R1(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac R1(cfg-crypto-trans)#mode transport R1(cfg-crypto-trans)#exitR1(config)#crypto ipsec profile dprofileR1(ipsec-profile)#set transform-set dmvpnR1(ipsec-profile)#exitR1(config)#int tunnel 1R1(config-if)#tunnel protection ipsec profile dprofile*Aug 31 02:59:34.650: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON 1234567891011121314R3(config)#crypto isakmp policy 10R3(config-isakmp)#authentication pre-share R3(config-isakmp)#exitR3(config)#crypto isakmp key cisco123 address 0.0.0.0R3(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac R3(cfg-crypto-trans)#mode transport R3(cfg-crypto-trans)#exitR3(config)#crypto ipsec profile dprofileR3(ipsec-profile)#set transform-set dmvpnR3(ipsec-profile)#exitR3(config)#int tunnel 1R3(config-if)#tunnel protection ipsec profile dprofile*Aug 31 03:02:49.557: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON 12345678910111213R4(config)#crypto isakmp policy 10R4(config-isakmp)#authentication pre-share R4(config-isakmp)#exit R4(config)#crypto isakmp key cisco123 address 0.0.0.0R4(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac R4(cfg-crypto-trans)#mode transport R4(cfg-crypto-trans)#exitR4(config)#crypto ipsec profile dprofileR4(ipsec-profile)#set transform-set dmvpnR4(ipsec-profile)#exitR4(config)#int tunnel 1R4(config-if)#tunnel protection ipsec profile dprofile*Aug 31 03:06:36.128: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON 验证是否进行了加密 此时R3上的路由表并没有172.16.4.0的路由条目，因为存在水平分割问题 在R1的隧道接口中关闭水平分割 12R1(config)#int tunnel 1R1(config-if)#no ip split-horizon eigrp 110 再次查看R3的路由表 ，此时学习到了172.16.4.0的路由条目 跟踪路由，可知分支之间的流量必须经过hub 可通过在hub上进行路由汇总的方式来优化分支的路由条目，为了便于观察结果，在R3和R4上分别再开启一个回环口，并在EIGRP中通告 123456789R3(config)#int loopback 2R3(config-if)#ip address 172.16.33.1 255.255.255.0R3(config)#router eigrp 110R3(config-router)#network 172.16.33.0 0.0.0.255R4(config)#int loopback 2R4(config-if)#ip add 172.16.44.1 255.255.255.0R4(config)#router eigrp 110R4(config-router)#network 172.16.44.0 0.0.0.255 查看R3和R4的路由表，都学习到了相应的路由条目 在R1的tunnel接口进行路由汇总 12R1(config)#int tunnel 1R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16 再次查看R3和R4的路由表，此时学习到的是经过R1汇总的路由 3、phase-2验证 所有站点都采用mGRE，分支的流量可以无需经过hub，不能在hub端对路由进行汇总；eigrp环境，需要关闭下一跳规则——no ip next-hop-self eigrp，缺点所有的分支都需要维护整个网络的所有路由信息。 在phase1的基础上，将R3、R4的隧道模式改为multipoint 1234567R3(config)#int tunnel 1R3(config-if)#no tunnel destination 202.101.12.1R3(config-if)#tunnel mode gre multipoint R4(config)#int tunnel 1R4(config-if)#no tunnel destination 202.101.12.1R4(config-if)#tunnel mode gre multipoint 在R3上使用traceroute跟踪路由，可知去往172.16.4.1仍然要经过hub 查看R3的路由表，可知去往172.16.4.0/24网段的路由的下一跳为hub 【注】此时并未在R1的隧道接口汇总路由 出现上述问题的原因在于EIGRP路由在传递的时候会将下一跳改为自己，将R1的tunnel接口将该属性关闭 12R1(config)#int tunnel 1R1(config-if)#no ip next-hop-self eigrp 110 此时查看R3的路由表可知去往172.16.4.0/24网段的路由的下一跳变为R4 在R3上再次跟踪路由，如下图所示，可知此时R3直接通过R4访问172.16.4.1，无需再经过hub 4、phase-3验证 在阶段三引入了shortcut（短路）和redirect（重定向） 在R1上开启redirect，在R3和R4上开启shortcut 12345678R1(config)#int tunnel 1R1(config-if)#ip nhrp redirect R3(config)#int tunnel 1R3(config-if)#ip nhrp shortcut R4(config)#int tunnel 1R4(config-if)#ip nhrp shortcut 在R1上将下一跳属性和水平分割恢复 123R1(config)#int tunnel 1R1(config-if)#ip next-hop-self eigrp 110R1(config-if)#ip split-horizon eigrp 110 此时R3和R4的路由表还是无法学习到其他站点的路由条目 为了验证实验结果，此时在R3启用多个回环口，并在eigrp中通告 1234567891011R3(config)#int loopback 3R3(config-if)#ip add 192.168.3.1 255.255.255.0R3(config)#int loopback 4R3(config-if)#ip add 192.168.4.1 255.255.255.0R3(config)#int loopback 5R3(config-if)#ip add 192.168.5.1 255.255.255.0R3(config)#router eigrp 110R3(config-router)#network 192.168.3.0R3(config-router)#network 192.168.4.0R3(config-router)#network 192.168.5.0 在R1上进行路由汇总 123R1(config)#int tunnel 1R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16R1(config-if)#ip summary-address eigrp 110 192.168.0.0/16 再次查看R3和R4的路由表，此时学习到的为经过R1汇总的条目，并且下一跳都指向R1 在R4上跟踪到达172.16.3.1所经过的路径，可知需经过R1 查看R4的路由表，此时出现了”H”的路由条目 此时再次使用traceroute跟踪172.16.3.1，则无需再经过R1 再次进行验证，使用traceroute命令跟踪到达192.168.3.1所经过的路径，首次traceroute需要经过R1 查看R4的路由表，此时通过NHRP学习到了更详细的路由去往192.168.3.0/24网段，下一跳为10.1.1.3 再次使用traceroute跟踪路径，则无需再经过R1 5、总结","categories":[],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://shain.top/tags/VPN/"}]},{"title":"STP的运用","slug":"STP的运用","date":"2020-08-31T14:57:13.000Z","updated":"2020-08-31T16:00:08.291Z","comments":true,"path":"2020/08/31/STP的运用/","link":"","permalink":"http://shain.top/2020/08/31/STP%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"1、实验目的1）理解STP的作用2）熟悉STP的工作原理3）掌握STP的查看命令","text":"1、实验目的1）理解STP的作用2）熟悉STP的工作原理3）掌握STP的查看命令 2、拓扑结构 3、实验步骤（1）在相应的交换机上创建vlan10，并将连接PC1和PC2的交换端口都划分进该vlan中 （2）为主机设置合适的IP地址，IP地址自定，完成必要的配置实现主机间的通信 为两台PC配置IP地址（注意关闭路由功能，因为实验中的PC使用的是路由器的镜像） 将交换机之间的端口封装802.1Q，并配置成trunk 测试PC的连通性 由于PC1和PC2属于同一vlan，所以通过上述配置即可相互ping通 （3）查看各交换机的STP信息 （4）将SW1设置为vlan10的根桥，使用相关命令验证和查看各交换机上根桥的变化 设置SW1为vlan10的根桥 使用show spanning-tree命令查看交换机状态 由于设置SW1为vlan10的根桥，由下图可知，优先级默认降低2*4096，即为24576，加上vlan-id的10，所以优先级为24586 （5）测试正常链路出现故障对主机通信的影响 将SW2的e0/1接口shutdown PC1仍然可以ping通PC2 （6）先断开PC1与交换机的连接，然后恢复PC1与交换机的连接，观察主机重新接入交换机要经历多久才能够进行数据转发 由下图可知，PC1重新接入交换机需要经历30s（由于关闭的是SW2上的端口，可以直接进入listening状态（无需经历20s的blocking状态），再经历15s进入learning状态，最后经历15s进入forwarding状态）","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"},{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"}]},{"title":"单臂路由运用","slug":"单臂路由运用","date":"2020-08-30T15:03:42.000Z","updated":"2020-09-05T08:11:17.808Z","comments":true,"path":"2020/08/30/单臂路由运用/","link":"","permalink":"http://shain.top/2020/08/30/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E8%BF%90%E7%94%A8/","excerpt":"1、实验目的1）掌握交换机上VLAN的创建和划分2）掌握trunk的作用3）掌握VTP的作用与配置4）掌握单臂路由原理与配置5）理解trunk链路上的802.1Q标记的作用","text":"1、实验目的1）掌握交换机上VLAN的创建和划分2）掌握trunk的作用3）掌握VTP的作用与配置4）掌握单臂路由原理与配置5）理解trunk链路上的802.1Q标记的作用 2、拓扑结构 3、实验步骤（1）在SW1上创建两个vlan，vlan10和vlan20，并将vlan10命名为sales，将vlan20命名为engineers （2）完成必要的配置，实现两交换机的vlan数据库同步，并使用相关命令验证和查看vlan数据库的信息 要实现两交换机的vlan数据库同步，需要进行vtp的配置 将两交换机相连的端口设置为trunk 指定vtp的域和密码，并指定SW1的vtp模式为server，SW2的vtp模式为client 在SW2上查看vlna信息，此前并未在SW2上创建vlan，由此可知两交换机之间实现了vlan数据库的同步 尝试在SW2上创建一个vlan，日志提示在vtp的模式为client的条件下不允许创建vlan 在SW1上查看vtp的状态信息，从下图可知SW1的vtp模式为server（默认），已存在的vlan数量为7，修订版本号为8 （3）将连接PC1和PC3的交换端口划分进vlan10，将连接PC2的交换端口划分进vlan20中，并为各PC配置合适的IP地址和网关 依题意将交换机上的端口划分进对应的vlan 由于各PC为使用路由器镜像模拟，需在PC上关闭路由功能。按下图所示为各PC配置IP地址和网关 （4）使用show vlan brief查看各交换机的vlan信息 （5）测试各主机之间的连通性 PC1和PC3之间可以相互ping通（两PC属于同一vlan，无需经过三层设备） PC1和PC2之间无法通信（两PC属于不同vlan，需要经过三层设备，此时还未在路由器上进行相应的配置） （6）在交换机和路由器上完成必要的配置，实现各主机间可以互相通信 将SW1上连路由器的端口配置成trunk 、 在R1上进行单臂路由的配置 单臂路由是指在路由器的一个接口上通过配置子接口(或”逻辑接口”，并不真实存在)的方式，实现原来相互隔离的不同vlan之间的互联互通 值得注意的是这些逻辑子接口不能被单独的开启或关闭，即当物理接口被开启或关闭时，所有的该物理接口的子接口也将对应的被开启或关闭 由于单臂路由存在瓶颈和单点故障的问题，因此必须限制主机/vlan的数量。此时可以通过SVI实现不同vlan间的通信（后续会进行介绍） 测试各主机之间的连通性，如下图所示，三台PC之间可以互相ping通","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"单臂路由","slug":"单臂路由","permalink":"http://shain.top/tags/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/"},{"name":"vtp","slug":"vtp","permalink":"http://shain.top/tags/vtp/"}]},{"title":"单区域OSPF的实现","slug":"单区域OSPF的实现","date":"2020-08-29T14:56:59.000Z","updated":"2020-09-05T08:11:40.073Z","comments":true,"path":"2020/08/29/单区域OSPF的实现/","link":"","permalink":"http://shain.top/2020/08/29/%E5%8D%95%E5%8C%BA%E5%9F%9FOSPF%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"1、实验目的1）掌握OSPF的基本配置2）掌握OSPF的邻居表、拓扑表及路由表的含义3）掌握OSPF的DR和BDR的作用4）掌握OSPF的DR和BDR的选举5）查看和调试OSPF路由协议的相关信息6）熟悉OSPF中hello报文的作用和格式","text":"1、实验目的1）掌握OSPF的基本配置2）掌握OSPF的邻居表、拓扑表及路由表的含义3）掌握OSPF的DR和BDR的作用4）掌握OSPF的DR和BDR的选举5）查看和调试OSPF路由协议的相关信息6）熟悉OSPF中hello报文的作用和格式 2、拓扑结构 3、实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划 各接口地址如拓扑图标记所示进行配置 （2）全网启用OSPF，并划分如区域0 距离矢量为通告 链路状态为使能 network表示的是划分一个范围，路由器上属于此范围的对应接口加入OSPF的相应进程的相应区域 如network 192.168.12.0 0.0.0.255 area 0 表示的是划分一个范围为192.168.12.0，看此路由器上的哪个接口在这个范围内，则这个接口就会被加入OSPF的区域0中 （3）观察各路由器的邻居表、拓扑表及路由表，观察哪些链路上有进行DR/BDR的选举，并测试主机之间的连通性 优先级用于选举DR/BDR——以太网链路存在DR/BDR的选举，串行链路则没有 选举规则： 先比较优先级，优先级大的优先；默认情况下以太网接口的优先级都为1，串行链路的接口优先级都为0（优先级为0不能参与DR/BDR的选举） 如果优先级都一样，继续比较RID，RID大的优先 DR的选举是非抢占的 Hello报文 作用：用来发现、建立、维持邻居之间的关系 每隔10s往224.0.0.5发送Hello报文，如果在40之后没有收到来自邻居的Hello，则认为该邻居挂了，就切断和该邻居之间的关系（死亡时间通常在30-39之间） -————————————————————————————————————————– Neighbor ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pri &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State &nbsp;&nbsp;&nbsp;Dead Time &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface &nbsp;&nbsp;&nbsp;邻居的ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级 &nbsp;&nbsp;状态 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;死亡时间 &nbsp;&nbsp;&nbsp;&nbsp;邻居的IP地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己用于建立邻居的接口 -————————————————————————————————————————– 邻居表 拓扑表 路由表 连通性测试 （4）指定R2的RID为20.20.20.20，R3的RID为30.30.30.30，使用相关命令观察和验证各路由器RID的变化 【RID的选举】 手工指定：最优先 R2(config)#router ospf 1 R2(config-router)#router-id 20.20.20.20 –手动指定RID Reload or use “clear ip ospf process” command, for this to take effect R2#clear ip ospf process –重置OSPF的进程 Reset ALL OSPF processes? [no]: y 自动选择：在没有手工指定情况下，优先选择回环口中IP地址最大的；若没有回环口，选择物理接口（双UP）中IP地址最大。 查看当前R2和R3的RID，由于没有手工指定，也没有存在回环口，则选择物理接口中IP地址最大的作为RID 指定R2和R3路由器的RID 再次查看R2和R3的RID （5）实现R2为以太网链路网段上的DR 由于R1和R2的优先级默认都为1，并且R2的RID为20.20.20.20，而R1的RID为192.168.12.1，此时需要修改R2的e0/0接口的优先级，使之成为以太网链路上的DR。此处指定R2上e0/0接口的优先级为2即可 由于DR、BDR的选举为非抢占，此时应重置OSPF进程 查看R1和R2的邻居表，可知此时R2成为以太网链路上的DR （6）分别在R2和R3的路由器上添加172.16.2.0/24和172.16.3.0/24的网段，添加必要配置实现这两个网络之间的连通性 由于R3上已存在172.16.3.0/24网段，此时在R2上添加一个回环口（地址为172.16.2.2/24）用作测试 123R2(config)#interface loopback 1R2(config-if)#ip address 172.16.2.2 255.255.255.0R2(config-if)#ip ospf 1 area 0 --把该接口加入到OSPF进程1区域0中 （7）开启debug信息，观察OSPF在以太网链路之间信息交互的过程 （8）开启debug信息，观察OSPF在串行链路之间信息交互的过程，比较以太网链路和串行链路上OSPF的debug信息输出的区别 最主要区别在于以太网链路会进行DR/BDR的选举；串行链路则没有进行DR/BDR的选举 以太网链路中，路由信息会先被发送到组播地址224.0.0.6，即被DR/BDR所接收，再由DR将此信息发送到组播地址224.0.0.5 （9）使用wireshark抓取OSPF的hello报文，理解hello报文各字段的含义 hello报文用于邻居的发现，建立和维持 hello报文中的相关信息包括： Network Mask：发送hello报文的接口所在网络的掩码 Hello Interval（默认为10s）：发送hello报文的时间间隔 Options：可选项 E：允许Flood AS-External-LSAs MC：转发IP组播报文 N/P：处理Type-7 LSAs DC：处理按需链路 Router Priority：优先级，默认为1，如果设置为0，则不参与DR或BDR的选举 Router Dead Interval（默认40s）：失效时间，如果在此时间内未收到邻居发送的hello报文，则认为邻居失效 Designated Router：DR的接口地址 Backup Designated Router：BDR的接口地址 Active Neighbor：活跃的邻居，以RID标识","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"}]},{"title":"EIGRP的简单应用","slug":"EIGRP的简单应用","date":"2020-08-28T15:34:08.000Z","updated":"2020-09-05T08:12:14.315Z","comments":true,"path":"2020/08/28/EIGRP的简单应用/","link":"","permalink":"http://shain.top/2020/08/28/EIGRP%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/","excerpt":"1、实验目的1）掌握EIGRP的基本配置2）理解EIGRP的邻居表、拓扑表以及路由表的含义3）掌握查看EIGRP路由协议的相关信息4）掌握FD、AD、S、FS以及FC的含义5）理解EIGRP的hello报文作用6）理解路由快速收敛的含义7）理解EIGRP的不等价负载均衡","text":"1、实验目的1）掌握EIGRP的基本配置2）理解EIGRP的邻居表、拓扑表以及路由表的含义3）掌握查看EIGRP路由协议的相关信息4）掌握FD、AD、S、FS以及FC的含义5）理解EIGRP的hello报文作用6）理解路由快速收敛的含义7）理解EIGRP的不等价负载均衡 2、实验拓扑 3、实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，要求PC1的IP地址设置为172.16.1.1/24，网关设置为172.16.1.254，PC2的IP地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划 IP地址规划如拓扑图标记所示，此处不再列出 （2）全网启用EIGRP，通告各自的直连网络路由，并关闭自动汇总 1234567//启用EIGRP进程，AS号为90，AS号是邻居建立的前提，邻居要建立AS号必须要一样R3(config)#router eigrp 90 //关闭自动汇总R3(config-router)#no auto-summary //通告网段R3(config-router)#network 192.168.23.0 //通告直连网段R3(config-router)#network 172.16.3.0 0.0.0.255 （3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息 Metric weight K1=1, K2=0, K3=1, K4=0, K5=0 – EIGRP的开销计算与这5个K值有关系 邻居要建立，则五个K值必须相同 K1：带宽；K2：负载；K3：延迟；K4：可靠性；K5：MTU 真正与EIGRP开销计算有关系的，只有带宽和延迟； EIGRP开销=带宽+延迟 （4）查看各路由器的邻居表、拓扑表以及路由表，分别找出FD、AD以及S等重要信息 邻居表各字段含义 H：建立顺序 Address：对端的IP Interface：从哪个接口学习到 Hold：定义了等待没有从邻居那里接收到任何包的最大时间，当接收到新的包以后，Hold复位（在10~15s之间循环） Uptime：建立了多久 SRTT：向邻居发送包以及受到邻居回应ACK的平均回程时间 RTO：重传超时时间，路由器在重新传输包之前等待ACK的时间（应为SRTT的6倍，最大5000，若重传16次还未得到确认，则此邻居被宣布无效） Q：队列计数，表示有多少个可靠报文还没有得到确认，在运行正常的环境下该值应为0（如果值大于0则说明发生了拥塞） Seq：序列号 拓扑表 路由表 （5）测试PC1与PC2之间的连通性 （6）在R2上添加一个loopback1接口，地址为200.200.200.200/24，然后在EIGRP中通告，观察R1和R3是否能马上学习到R2上新增的loopback1网段，并测试各主机与该loopback1之间的联通性 R1和R3能马上学习到R2上新增的loopback1网段 （7）使用wireshark抓取EIGRP的报文，理解EIGRP报文各字段的含义 每隔5s发送一个hello包，保持时间为15s，即超过3个hello时间未收到hello则认为对端Down，断开连接 （8）在R1上添加一个loopback1接口，地址为100.100.100.100/24，然后在EIGRP中通告 （9）断开R1和R3与各主机之间的连接，连接R1与R3之间的以太网接口，完成必要配置，实现200.200.200.200访问100.100.100.100的不等价负载均衡 123//使用源200.200.200.200去访问目标100.100.100.100//若没有跟上source，那么默认情况下就是使用出接口去访问目标R2#ping 100.100.100.100 source 200.200.200.200 由于此时R2的路由表中只存在一条路径到达100.100.100.100，所以此时不存在负载均衡 等价负载均衡：有多条开销相等的路径，此时可以同时从这些开销相等的路径去发送数量相同的数据包。 不等价负载均衡：有多条路径，但是开销不一样，此时会根据一定的比例去发送数据包。 对于EIGRP，默认情况下只支持等价负载均衡，并且默认情况下最多可以同时存在4条的等价负载均衡。 R2(config)#router eigrp 90 R2(config-router)#maximum-paths 8 –将等价负载均衡的条数改为8条 EIGRP还可以支持不等价负载均衡，但是有前提： ①次优路径的AD值要小于最优路径的FD值–称为FC条件，只有满足了该条件，才会存在FS。 ②当存在FS之后，EIGRP拓扑表会存在两个下一跳，但是只会选择最优的添加进路由表。此时如果要保证路由表也有两条路径，必须手动修改V值(variance)，使得满足”最优路径的FD*V值&gt;次优路径的FD值”（默认情况下，v值为1） 此题中，最优路径为R2通过R1到达100.100.100.100，次优路径为经过R3、R1到达100.100.100.100 查看R2的路由表，此时显示的为最优路径，FD=409600 次优路径的AD即为R3到达100.100.100.100的开销（FD），也为409600 此时不满足FC条件，则需更改开销，修改K值，更改R2的e0/0接口的延迟为3000（默认为1000），注意倍数关系 将修改延迟的接口关闭再打开 此时满足FC条件，即次优路径的AD值小于最优路径的FD值，在拓扑表中存在两条路径 此时的FS为R3 但是此时路由表中到达100.100.100.100仍然只存在一条最优路径 若想让次优路径加表，则需满足：最优路径的FD*v值 &gt; 次优路径的FD才能加入到路由表 修改V值为6，此时满足条件，路由表中到达100.100.100.0网段存在两个下一跳 查看该路由的详细信息，可知基本满足1:5的关系 1234567相关命令R2(config)#int e0&#x2F;0R2(config-if)#delay n --修改延迟，但是注意，如果输入的是n，那么延迟会改为10*nR2(config-if)#bandwidth n --修改带宽，如果输入的是n，那么带宽就为nR2#show interfaces e0&#x2F;0 --看接口的详细信息，比如说带宽、延迟R2#show ip route 100.100.100.0 255.255.255.0 --查看该路由的详细信息","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"EIGRP","slug":"EIGRP","permalink":"http://shain.top/tags/EIGRP/"}]},{"title":"RIP的应用","slug":"RIP的应用","date":"2020-08-27T13:39:13.000Z","updated":"2020-09-05T08:12:33.705Z","comments":true,"path":"2020/08/27/RIP的应用/","link":"","permalink":"http://shain.top/2020/08/27/RIP%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"1、 实验目的 掌握RIPv2的基本配置 理解RIPv2路由条目的结构含义 理解自动汇总的含义 理解和观察周期性更新 理解debug ip rip 命令 的作用","text":"1、 实验目的 掌握RIPv2的基本配置 理解RIPv2路由条目的结构含义 理解自动汇总的含义 理解和观察周期性更新 理解debug ip rip 命令 的作用 2、 拓扑结构 3、 实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互 ping 对方， 要求 PC1 的 IP 地址设置为 172.16.1.1/24，网关设置为172.16.1.254， PC2 的 IP 地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划。 （2）在三台路由器上都启用RIPv2协议，通告各自的直连网络路由，并开启自动汇总 1默认开启自动汇总，会在边界处把一个网段汇总成主类 （3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息 路由更新计时器：30s（默认）路由无效时间：180s（默认）抑制计时器：180s（默认）路由刷新计时器：240s（默认） （4）查看各路由器的路由表，观察RIP路由条目的特征 由于没有关闭自动汇总，R1上存在172.16.0.0网段的路由，则不会再学习R2上的172.16.0.0的路由 同理，R2上存在172.16.0.0网段的路由，则不会学习R1上的172.16.0.0的路由 （5）分别在R2和PC2上测试R2与PC1以及PC2与PC1之间的连通性 （6）在R2上使用debug ip rip观察路由的发送情况 RIPv2组播地址：224.0.0.9 由于没有关闭自动汇总，此时发送的报文都为主类路由 （7）在三台路由器上都关闭自动汇总，观察各路由表的变化，并再次测试R2与PC1以及PC2与PC1之间的连通性 （8）再次在R2上使用debug ip rip观察路由的发送情况，比较关闭自动汇总与开启自动汇总debug输出信息的不同 （9）在R2上添加一个loopback1接口，地址自定 （10）添加必要配置，实现PC1和PC2都能够正常访问在R2上的loopback1 （11）在R1上添加一个loopback1接口，地址自定，然后在RIP中通告，观察R2和R3是否能马上学习到R1上新增的loopback1网段 由于rip的路由表的更新时间为30s，故在R2、R3上无法马上学习到在R1上新增的loopback1网段 （12）将R1上的loopback1接口关闭，观察R2和R3上是否还存在关于R1上的loopback1网段的路由条目 由于触发更新，R1上存在失效路由，则会马上发送更新给相邻的路由器，让他们将失效路由删除 （13）使用wireshark抓取RIPv2报文，理解RIPv2报文各字段的含义 RIPv2运行在UDP的520端口上，属于应用层协议","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"RIP","slug":"RIP","permalink":"http://shain.top/tags/RIP/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-26T05:18:32.000Z","updated":"2020-09-14T09:37:22.485Z","comments":true,"path":"2020/08/26/hello-world/","link":"","permalink":"http://shain.top/2020/08/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"http://shain.top/categories/Hello-World/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://shain.top/tags/hello-world/"}]}],"categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","permalink":"http://shain.top/categories/Linux/"},{"name":"复习题","slug":"复习题","permalink":"http://shain.top/categories/%E5%A4%8D%E4%B9%A0%E9%A2%98/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://shain.top/categories/Hello-World/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"},{"name":"DHCP","slug":"DHCP","permalink":"http://shain.top/tags/DHCP/"},{"name":"DHCP中继","slug":"DHCP中继","permalink":"http://shain.top/tags/DHCP%E4%B8%AD%E7%BB%A7/"},{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"http://shain.top/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"重分布","slug":"重分布","permalink":"http://shain.top/tags/%E9%87%8D%E5%88%86%E5%B8%83/"},{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"},{"name":"RSTP","slug":"RSTP","permalink":"http://shain.top/tags/RSTP/"},{"name":"MST","slug":"MST","permalink":"http://shain.top/tags/MST/"},{"name":"IPv6","slug":"IPv6","permalink":"http://shain.top/tags/IPv6/"},{"name":"TCP","slug":"TCP","permalink":"http://shain.top/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"http://shain.top/tags/IP/"},{"name":"HSRP","slug":"HSRP","permalink":"http://shain.top/tags/HSRP/"},{"name":"VRRP","slug":"VRRP","permalink":"http://shain.top/tags/VRRP/"},{"name":"GLBP","slug":"GLBP","permalink":"http://shain.top/tags/GLBP/"},{"name":"VTP","slug":"VTP","permalink":"http://shain.top/tags/VTP/"},{"name":"EtherChannel","slug":"EtherChannel","permalink":"http://shain.top/tags/EtherChannel/"},{"name":"SVI","slug":"SVI","permalink":"http://shain.top/tags/SVI/"},{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"NAT","slug":"NAT","permalink":"http://shain.top/tags/NAT/"},{"name":"PPP","slug":"PPP","permalink":"http://shain.top/tags/PPP/"},{"name":"ACL","slug":"ACL","permalink":"http://shain.top/tags/ACL/"},{"name":"VPN","slug":"VPN","permalink":"http://shain.top/tags/VPN/"},{"name":"单臂路由","slug":"单臂路由","permalink":"http://shain.top/tags/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/"},{"name":"vtp","slug":"vtp","permalink":"http://shain.top/tags/vtp/"},{"name":"EIGRP","slug":"EIGRP","permalink":"http://shain.top/tags/EIGRP/"},{"name":"RIP","slug":"RIP","permalink":"http://shain.top/tags/RIP/"},{"name":"hello world","slug":"hello-world","permalink":"http://shain.top/tags/hello-world/"}]}
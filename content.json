{"meta":{"title":"shain","subtitle":"缘来是你","description":null,"author":"~鑫~","url":"http://shain.top","root":"/"},"pages":[{"title":"","date":"2020-08-26T12:28:37.000Z","updated":"2020-09-14T11:57:59.286Z","comments":true,"path":"about/index.html","permalink":"http://shain.top/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-12T06:01:59.000Z","updated":"2020-08-26T11:26:36.180Z","comments":true,"path":"categories/index.html","permalink":"http://shain.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-12T06:03:03.000Z","updated":"2020-08-26T11:26:46.537Z","comments":true,"path":"tags/index.html","permalink":"http://shain.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"生成树协议","slug":"STP","date":"2020-09-15T00:32:33.000Z","updated":"2020-09-15T15:08:50.566Z","comments":true,"path":"2020/09/15/STP/","link":"","permalink":"http://shain.top/2020/09/15/STP/","excerpt":"","text":"1、生成树协议概述 冗余的网络拓扑可以消除单点故障所导致的网络障碍。但从另一个角度看，冗余的网络拓扑也会带来其他的问题，如2层环路。使用STP技术可以在冗余的环境中消除潜在的2层环路问题。 1.1、STP概述 如下图所示的冗余环境中，使用STP可以阻塞环路上的某个特定的端口，保证每个网段上只存在一条活动路径。 在冗余的网络拓扑环境中，若未启用STP，则会导致以下问题： 广播风暴——冗余网络上的每台交换机会不断地泛洪广播帧 多帧复制——目的站点可能会收到同一单播数据帧的多份拷贝，这可能会导致接收协议的一些问题 MAC数据库不稳定——当一台交换机的不同端口收到了相同的帧拷贝时，这种现象称为MAC地址漂移。MAC地址表会将帧的源MAC地址和接收到此帧的入站端口对应到一条表项中。若存在环路，同一个MAC地址可能会从多个端口上接收到，这就造成了MAC地址表的不稳定。 STP技术可以在支持物理路径冗余的同时，消除网络环路造成的影响。通过STP的选举机制，将多余链路进行阻塞，只保留一条活跃链路用于对数据流量的处理，被阻塞掉的链路同时也作为备用链路。当去往某个网段的连通性出现了问题，STP会自动启用之前的阻塞路径，并重新建立连通性。STP所使用桥协议数据单元（BPDU）来交换STP信息，并使用BPDU确定网络拓扑信息，以及对拓扑中设备添加、删除或修改的动作做出响应。交换机默认每2s向所有端口发送一次BPDU。 1.2、STP标准 1.3、STP选举机制 根桥——拥有最小桥ID的交换机被选为根桥 每台交换机拥有唯一的BID，包含桥优先级（默认为32768）和MAC地址 根端口——非根交换机上去往根桥路径最优的端口，用于接收BPDU 最小根路径开销 最小发送者桥ID 最小发送者的端口ID 指定端口——用于发送或转发配置BPDU 最小根路径开销 最小发送者桥ID 最小发送者的端口ID 非指定端口——既不转发数据帧，也不会将在该网段接收到的数据包源MAC地址填入MAC地址表中 上述端口选举完后，剩下的既不是根端口也不是指定端口的端口成为非指定端口 1.4、BPDU STP使用签协议数据单元（BPDU）来交换STP信息，包括根桥的选举以及环路的识别等。默认情况下，交换机每2秒发送一次BPDU。BPDU一般分为以下两种类型： 配置BPDU——用于计算STP TCN BPDU——用于通告网络拓扑变化 BPDU帧结构以及各字段含义 协议ID：标识STP 版本号：标识当前的协议版本 消息类型：标识BPDU类型（配置BPDU或TCN BPDU） 标志：用来响应TCN BPDU 根桥ID：标识根桥的桥ID（BID） 根路径开销：标识发送交换机到根桥之间的路径开销 发送方网桥ID：标识发送交换机的BID 端口ID：标识发送端口 消息期限：标识当前BPDU的生存时间 最大期限：标识BPDU的最大超时时间 Hello时间：标识根桥生成配置BPDU的间隔时间 转发延迟：标识交换机端口必须等待侦听（listening）及学习（learning）状态的时间 1.5、STP端口状态 Blocking（阻塞状态）：此时，二层端口为非指定端口，也不会参与数据帧的转发。该端口通过接收BPDU来判断根交换机的位置和根ID，以及在STP拓扑收敛结束之后，各交换机端口应该处于什么状态（是根端口、指定端口还是非指定端口）。在默认情况下，端口会在这种状态下停留20秒钟的时间（最大周期） Listening（侦听状态）：生成树此时已经根据交换机所接收到的BPDU而判断出了这个端口应该参与数据帧的转发。于是，交换机端口就不再满足于接收BPDU，而同时也开始发送其自己的BPDU，并以此通告邻接的交换机该端口会在活动拓扑中参与转发数据帧的工作。在默认情况下，端口会在这种状态下停留15秒钟的时间（转发延迟） Learning（学习状态）：这个二层端口准备参与数据帧的转发，并开始填写CAM表。在默认情况下，端口会在这种状态下停留15秒钟的时间（转发延迟） Forwarding（转发状态）：这个二层端口已经成为了活动拓扑的一个组成部分；它会转发数据帧，并同时收发BPDU Disabled（禁用状态）：这个二层端口不会参与生成树，也不会转发数据帧 1.6、STP拓扑变更 当交换机的某个端口变成了转发状态或阻塞状态时，意味着STP拓扑发生了变更。交换机通过向根端口发送TCN BPDU的方法来通告拓扑变更。这一BPDU不包括实际的变更内容，仅用来通知网络中其他交换机拓扑发生变更这一现象。 拓扑变更处理流程： 当交换机检测到拓扑发生变更时，会沿着根桥的方向发送TCN 上游的交换机接收到TCN以后，首先会回复一个TCA，然后继续沿着根桥的方向发送TCN，直到最后根桥收到TCN 根桥收到TCN后，会回复一个拓扑变更确认（TCA）和一个设置了TC标志位的BPDU给所有的下游交换机，同时将本地的MAC地址表的老化时间从300s缩短至15s——为了实现MAC地址表刷新 下游的交换机收到TC置位的BPDU的时候，也会将本地的MAC地址表老化时间从300s缩短至15s，同时也会继续转发TC置位的BPDU给下游交换机——将TC置位的信息在整个交换网络中泛洪 1.7、PVST+ 增强的每个VLAN生成树是Cisco的一种生成树实现技术。PVST+可为网络中配置的每个VLAN提供一个单独的生成树实例。 与CST不同的是，PVST+可以为每个VLAN运行一个生成树实例，这就意味着在配置有不同VLAN的冗余链路上可以基于不同的VLAN来负载分担流量。 拓扑结构如下所示，进行主次根的配置 指定SW1为VLAN 10的根桥，为VLAN 20的次根桥 12SW1(config)#spanning-tree vlan 10 root primary SW1(config)#spanning-tree vlan 20 root secondary 指定SW2为VLAN 10的次根桥，为VLAN 20的根桥 12SW2(config)#spanning-tree vlan 10 root secondary SW2(config)#spanning-tree vlan 20 root primary 桥优先级默认为32768，对于SW1而言： 设置为root primary后，优先级降低2个4096，加上vlan-id后，优先级变成24586 设置为root secondary后，优先级降低1个4096，加上vlan-id后，优先级变成28692 SW2成为VLAN 20的根桥 关于收敛时间的验证 将SW3的e0/0接口shutdown，观察e0/1端口过渡到forwarding状态所需时间 12345678910111213SW3#debug spanning-tree events Spanning Tree event debugging is onSW3(config)#int e0/0SW3(config-if)#shutdown SW3#*Sep 15 08:37:02.367: STP: VLAN0020 new root port Et0/1, cost 200 //e0/0端口被禁用，则e0/1端口成为根端口*Sep 15 08:37:02.367: STP: VLAN0020 Et0/1 -&gt; listening //直接进入侦听状态*Sep 15 08:37:02.367: STP[20]: Generating TC trap for port Ethernet0/0*Sep 15 08:37:04.372: STP: VLAN0020 sent Topology Change Notice on Et0/1 //通告拓扑变更*Sep 15 08:37:17.367: STP: VLAN0020 Et0/1 -&gt; learning //经过15s，进入学习状态*Sep 15 08:37:32.373: STP[20]: Generating TC trap for port Ethernet0/1*Sep 15 08:37:32.373: STP: VLAN0020 sent Topology Change Notice on Et0/1*Sep 15 08:37:32.373: STP: VLAN0020 Et0/1 -&gt; forwarding //经过30s，进入转发状态 2、快速生成树协议（RSTP） 快速生成树协议（IEEE802.1w，也称为RSTP）在网络拓扑变更时，能够显著地提升生成树重新计算的速度。RSTP会选择一台交换机作为活动生成树拓扑的根，并为交换机上的每个端口分配端口角色，所分配的角色取决于端口是否是STP活动拓扑的一部分。通过在交换机之间使用明确的握手协议，新的根端口和指定端口会立刻过渡到forwarding状态。 2.1、RSTP端口角色根端口（root）：根端口是每台非根网桥上选择出来与根网桥相连的端口。每台交换机上只能有一个根端口。根端口在稳定工作状态的拓扑中处于转发状态 指定端口（designated）：在每个网段中至少会有一个交换机端口作为该网段的指定端口。在拓扑的稳定工作状态下，有指定端口的交换机会在这个网段中接收去往根网桥的数据帧。每个网段只能有一个指定端口。而这个指定端口会处于转发状态。所有与某个特定网段相连的交换机都会侦听所有的BPDU；并判断自己是否要在这个网段中充当指定交换机 替代端口（alternate）：替代端口是用来提供去往根网桥替代路径的端口。替代端口在稳定工作状态的拓扑中处于丢弃状态。替代端口出现在非指定交换机上，并且会在当前的指定端口出现故障时过渡为指定端口。（对根端口进行备份） 备份端口（backup）：备份端口是指定交换机上的一个额外的交换机端口，它的作用是为指定交换机提供一条备份链路。备份端口的端口ID高于指定交换机指定端口的端口ID。在稳定工作状态的拓扑中，备份端口处于丢弃状态。（存在Hub的时候才会出现，对链路进行备份） 禁用端口（disabled）：在生成树工作的过程中，禁用端口不担当任何角色 2.2、RSTP端口状态 RSTP中只存在3种端口状态，它们分别对应于端口可能的3中工作状态：丢弃状态、学习状态和转发状态。RSTP 802.1w丢弃状态代表了802.1D STP的禁用、阻塞和监听状态之和(可以节省20s时间)。 2.3、拓扑变更 RSTP中的TC（拓扑变更）通告是一步到位的。交换机使用向所有非边缘端口发送带有TC位BPDU的方式宣告拓扑变更，这意味着每台交换机都可以直接重新计算生成树。需要借助提议/同意机制，提议该端口为某个角色，如果没问题就同意。通过这种方式，所有的邻居交换机都会得知拓扑变更，因此会各自更新自己的CAM表，无需等待根桥发送TC BPDU。这种方法会导致更多潜在的临时泛洪，不过，可以很快地将拓扑变更通知扩散到整个网络，从而实现快速收敛。 2.4、关于RSTP收敛时间的验证 如下图所示，修改STP的模式为RSTP 将SW3的e0/0端口shutdown，观察e0/1端口过渡到转发状态所需时间 1234567SW3#debug spanning-tree events Spanning Tree event debugging is onSW3(config)#int e0/0SW3(config-if)#shutdown*Sep 15 12:09:40.772: RSTP(20): updt roles, root port Et0/0 going down*Sep 15 12:09:40.772: RSTP(20): Et0/1 is now root port //成为根端口，时间小于1s*Sep 15 12:09:40.777: STP[20]: Generating TC trap for port Ethernet0/1 注意： 如果该端口角色确定为RP，则直接过渡到转发状态 如果该端口角色确定为DP，只能是慢慢过渡 3、多生成树协议（MSTP） 多生成树（MST）将IEEE 802.1w RSTP算法扩展到了多棵生成树中。MST的主要目的是减少网络拓扑中生成树实例的总数量，从而降低交换机的CPU开销。 优势——在实现负载均衡的同时，降低维护生成树实例的个数 实现——将多个vlan加入相同的实例中 MST注意点： name 域名，同一个实例区域中域名要保持一致 revision 修订号，同一个实例区域中修订号要保持一致 vlan的关联表，将多个vlan关联起来，放入同一个实例中 没有划分的vlan会自动划分进MST0中（CIST） 123456789101112131415161718192021222324SW1(config)#spanning-tree mode mstSW1(config)#spanning-tree mst configuration SW1(config-mst)#name jiaohuan //设置域名称SW1(config-mst)#revision 10 //设置修订号SW1(config-mst)#instance 1 vlan 10,20,30 //划分vlan到此关联表SW1(config-mst)#instance 2 vlan 40,50,60SW1(config)#spanning-tree mst 1 root primary //设置SW1为mst1的根桥SW1(config)#spanning-tree mst 2 root secondary //设置SW1为mst2的次根桥SW2(config)#spanning-tree mode mstSW2(config)#spanning-tree mst configuration SW2(config-mst)#name jiaohuanSW2(config-mst)#revision 10SW2(config-mst)#instance 1 vlan 10,20,30SW2(config-mst)#instance 2 vlan 40,50,60SW2(config)#spanning-tree mst 1 root primary //设置SW2为mst1的次根桥SW2(config)#spanning-tree mst 2 root secondary //设置SW2为mst2的根桥SW3(config)#spanning-tree mode mstSW3(config)#spanning-tree mst configuration SW3(config-mst)#name jiaohuanSW3(config-mst)#revision 10SW3(config-mst)#instance 1 vlan 10,20,30SW3(config-mst)#instance 2 vlan 40,50,60 查看MST配置 查看MST摘要信息 查看MST实例映射消息","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"}]},{"title":"关于交换的基础测试","slug":"关于交换的基础测试","date":"2020-09-14T14:31:58.000Z","updated":"2020-09-15T01:17:25.983Z","comments":true,"path":"2020/09/14/关于交换的基础测试/","link":"","permalink":"http://shain.top/2020/09/14/%E5%85%B3%E4%BA%8E%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/","excerpt":"1、实验目的1）掌握VLAN、TRUNK、VTP的作用和配置2）掌握DTP的作用和配置3）掌握DHCP及DHCP中继的作用和配置4）掌握以太网通道技术的作用和配置","text":"1、实验目的1）掌握VLAN、TRUNK、VTP的作用和配置2）掌握DTP的作用和配置3）掌握DHCP及DHCP中继的作用和配置4）掌握以太网通道技术的作用和配置 2、拓扑结构 3、实验步骤（1）在该园区网络中有4个VLAN，分别为VLAN10、VLAN20、VLAN30和VLAN40，其中DHCP_SRV和PC1在VLAN10中，PC2、PC3分别在VLAN20、VLAN30和VLAN30中，FTP_SRV和PC4在VLAN40中，其中VLAN10的地址段为192.168.10.0/24，VLAN20的地址段为192.168.20.0/24，VLAN30的地址段为192.168.30.0/24，VLAN40的地址段为192.168.40.0/24，各VLAN主机的网关都设置为其网段中可用的最后一个主机地址，并且设置DHCP服务器的IP地址为192.168.10.100/24，其他主机通过DHCP方式获取IP地址、园区网络外部的地址自己规划 在SW1和SW2上创建VLAN，并将端口划分进相应的VLAN 123456789101112131415SW1(config)#vlan 10,20SW1(config)#int range e0/0,e0/2SW1(config-if-range)#switchport mode access SW1(config-if-range)#switchport access vlan 10SW1(config)#int e0/1SW1(config-if)#switchport mode access SW1(config-if)#switchport access vlan 20SW2(config)#vlan 30,40SW2(config)#int e0/0 SW2(config-if)#switchport mode access SW2(config-if)#switchport access vlan 30SW2(config)#int range e0/1-2SW2(config-if-range)#switchport mode access SW2(config-if-range)#switchport access vlan 40 配置IP地址 12345678910111213141516171819202122232425262728293031323334353637DHCP_SRV(config)#int e0/0DHCP_SRV(config-if)#ip address 192.168.10.100 255.255.255.0DHCP_SRV(config-if)#no shutdown R1(config)#int e0/0R1(config-if)#ip address 10.10.10.1 255.255.255.0R1(config-if)#no shutdown R1(config)#int s1/0R1(config-if)#ip address 202.101.100.1 255.255.255.0R1(config-if)#no shutdown ISP(config)#int s1/0ISP(config-if)#ip address 202.101.100.2 255.255.255.0ISP(config-if)#no shutdown ISP(config)#int e0/0ISP(config-if)#ip address 200.100.100.1 255.255.255.0ISP(config-if)#no shutdownWeb_SRV(config)#int e0/0Web_SRV(config-if)#ip address 200.100.100.2 255.255.255.0Web_SRV(config-if)#no shutdown SW1(config)#int e0/3 SW1(config-if)#ip address 10.10.10.2 255.255.255.0SW1(config-if)#no shutdown SW1(config)#int vlan 10SW1(config-if)#ip address 192.168.10.254 255.255.255.0 SW1(config-if)#no shutdown SW1(config)#int vlan 20SW1(config-if)#ip address 192.168.20.254 255.255.255.0SW1(config-if)#no shutdown SW1(config)#int vlan 30SW1(config-if)#ip address 192.168.30.254 255.255.255.0SW1(config-if)#no shutdownSW1(config)#int vlan 40SW1(config-if)#ip address 192.168.40.254 255.255.255.0SW1(config-if)#no shutdown （2）采用合适的方式完成交换机链路间的TRUNK配置，并采用标准的封装模式 在SW1和SW2之间的链路封装802.1Q，并关闭DTP协商，更改native vlan为999 1234567891011SW1(config)#int range e1/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW1(config-if-range)#switchport nonegotiateSW1(config-if-range)#switchport trunk native vlan 999SW2(config)#int range e1/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk SW2(config-if-range)#switchport nonegotiate SW2(config-if-range)#switchport trunk native vlan 999 （3）设置SW1的VTP模式为Server，SW2的VTP模式为Client，并且设置VTP域名为shain，密码为CCIEPASS，实现该园区网络的VLAN信息同步 123456SW1(config)#vtp domain shainSW1(config)#vtp password CCIEPASSSW1(config)#vtp mode server SW2(config)#vtp password CCIEPASSSW2(config)#vtp mode client 在SW1和SW2上查看VTP的状态信息 此时SW2通过VTP方式学习到SW1上的VLAN （4）使用802.3ad标准构建两交换机间的以太通道链路，要求交换机将EtherChannel的负载均衡设置为src-dst-ip 使用LACP进行交换机之间的链路捆绑 1234567SW1(config)#int range e1/0-1SW1(config-if-range)#channel-group 1 mode active Creating a port-channel interface Port-channel 1SW2(config)#int range e1/0-1SW2(config-if-range)#channel-group 1 mode active Creating a port-channel interface Port-channel 1 查看EtherChannel摘要信息，捆绑成功 将EtherChannel的负载均衡方式设置为src-dst-ip（默认的负载均衡方式即为src-dst-ip） 12SW1(config)#port-channel load-balance src-dst-ipSW2(config)#port-channel load-balance src-dst-ip 在SW1上查看EtherChannel的负载均衡方式 （5）根据需求在DHCP_SRV上建立相应的地址池，并且在各个地址池中排除范围从10到20之间的IP地址空间，同时要求无论FTP_SRV何时接入交换网络都会获取到192.168.40.100/24的地址，完成必要的配置，实现各主机和FTP_SRV可以获取相应的IP地址 在DHCP_SRV上创建地址池并按要求排除IP地址空间 12345678910111213141516171819202122232425262728//创建地址池DHCP_SRV(config)#ip dhcp pool vlan_10DHCP_SRV(dhcp-config)#network 192.168.10.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.10.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8DHCP_SRV(config)#ip dhcp pool vlan_20DHCP_SRV(dhcp-config)#network 192.168.20.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.20.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8DHCP_SRV(config)#ip dhcp pool vlan_30DHCP_SRV(dhcp-config)#network 192.168.30.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.30.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8DHCP_SRV(config)#ip dhcp pool vlan_40DHCP_SRV(dhcp-config)#network 192.168.40.0 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.40.254DHCP_SRV(dhcp-config)#dns-server 8.8.8.8//排除要求的IP地址，并将已使用的IP地址也排除掉DHCP_SRV(config)#ip dhcp excluded-address 192.168.10.10 192.168.10.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.20.10 192.168.20.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.30.10 192.168.30.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.40.10 192.168.40.20DHCP_SRV(config)#ip dhcp excluded-address 192.168.10.100DHCP_SRV(config)#ip dhcp excluded-address 192.168.10.254 DHCP_SRV(config)#ip dhcp excluded-address 192.168.20.254DHCP_SRV(config)#ip dhcp excluded-address 192.168.30.254DHCP_SRV(config)#ip dhcp excluded-address 192.168.40.254DHCP_SRV(config)#ip dhcp excluded-address 192.168.40.100 在DHCP_SRC和SW1上启用OSPF协议 12345678910DHCP_SRV(config)#router ospf 1DHCP_SRV(config-router)#router-id 3.3.3.3DHCP_SRV(config-router)#network 192.168.10.0 0.0.0.255 area 0SW1(config)#router ospf 1SW1(config-router)#router-id 1.1.1.1SW1(config-router)#network 192.168.10.0 0.0.0.255 area 0SW1(config-router)#network 192.168.20.0 0.0.0.255 area 0SW1(config-router)#network 192.168.30.0 0.0.0.255 area 0SW1(config-router)#network 192.168.40.0 0.0.0.255 area 0 在SW1的各VLAN的SVI接口中配置中继地址 由于DHCP_SRV在VLAN10中，所以无需在VLAN10的SVI端口配置中继地址 123456SW1(config)#int vlan 20SW1(config-if)#ip helper-address 192.168.10.100SW1(config)#int vlan 30SW1(config-if)#ip helper-address 192.168.10.100SW1(config)#int vlan 40SW1(config-if)#ip helper-address 192.168.10.100 各主机自动获取IP地址 让FTP_SRV自动获取地址 123FTP_SRV(config)#int e0/0FTP_SRV(config-if)#no shutdown FTP_SRV(config-if)#ip address dhcp 如下图所示，此时通过DHCP方式获取到的IP地址为192.168.40.2，并不符合要求的192.168.40.100 查看DHCP_SRV的DHCP绑定表，可以得到FTP_SRV的电路ID 在DHCP_SRV上清空FTP_SRV的地址绑定信息 1DHCP_SRV#clear ip dhcp binding 192.168.40.2 在DHCP_SRV上创建FTP_SRV专用的地址池，与FTP_SRV的电路ID进行绑定 1234DHCP_SRV(config)#ip dhcp pool FTP_SRVDHCP_SRV(dhcp-config)#host 192.168.40.100 255.255.255.0DHCP_SRV(dhcp-config)#default-router 192.168.40.254DHCP_SRV(dhcp-config)#client-identifier 0063.6973.636f.2d61.6162.622e.6363.3030.2e35.3030.302d.4574.302f.30 在FTP_SRV上使用DHCP方式获取IP地址，此时获取到的IP地址为192.168.40.100，符合要求 （6）完成必要配置，实现各主机可以访问ISP上的Web_SRV 在R1和SW1上运行OSPF协议，实现内网的可达性 123456R1(config)#router ospf 1R1(config-router)#router-id 2.2.2.2R1(config-router)#network 10.10.10.0 0.0.0.255 area 0SW1(config)#router ospf 1SW1(config-router)#network 10.10.10.0 0.0.0.255 area 0 此时PC3可以访问R1 在R1上配置默认路由，指定出接口为s1/0，并在OSPF进程下发默认路由 123R1(config)#ip route 0.0.0.0 0.0.0.0 s1/0R1(config)#router ospf 1R1(config-router)#default-information originate 指定Web_SRV的网关为ISP的e0/0接口的地址200.100.100.1 1Web_SRV(config)#ip default-gateway 200.100.100.1 此时实现了R1可以访问Web_SRV 在R1上配置PAT，实现内网主机可以访问Web_SRV 123456R1(config)#access-list 1 permit 192.168.0.0 /16 //ACL用于匹配内网主机R1(config)#ip nat inside source list 1 interface s1/0 overload R1(config)#int e0/0R1(config-if)#ip nat inside R1(config)#int s1/0R1(config-if)#ip nat outside 在R1上查看地址转换表，可知在R1上进行了地址转换","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"VTP","slug":"VTP","permalink":"http://shain.top/tags/VTP/"},{"name":"DHCP","slug":"DHCP","permalink":"http://shain.top/tags/DHCP/"},{"name":"EtherChannel","slug":"EtherChannel","permalink":"http://shain.top/tags/EtherChannel/"}]},{"title":"SVI回顾","slug":"SVI回顾","date":"2020-09-10T16:14:48.000Z","updated":"2020-09-12T15:21:16.552Z","comments":true,"path":"2020/09/11/SVI回顾/","link":"","permalink":"http://shain.top/2020/09/11/SVI%E5%9B%9E%E9%A1%BE/","excerpt":"SVI，即交换虚拟接口，是在多层交换机上配置的一种虚拟接口，如下图所示。管理员可以为任何交换机上配置的VLAN创建SVI接口。每个VLAN只能关联一个SVI接口。SVI并不是真实存在的物理接口，但此接口可以与路由器接口执行同样的VLAN操作功能，为所有出入其VLAN端口的数据包提供3层转发功能。","text":"SVI，即交换虚拟接口，是在多层交换机上配置的一种虚拟接口，如下图所示。管理员可以为任何交换机上配置的VLAN创建SVI接口。每个VLAN只能关联一个SVI接口。SVI并不是真实存在的物理接口，但此接口可以与路由器接口执行同样的VLAN操作功能，为所有出入其VLAN端口的数据包提供3层转发功能。 默认情况下，交换机会为默认VLAN（VLAN 1）创建一个SVI接口，以允许远程管理交换机。除此之外的SVI都需要管理员手动添加。当用户首次进入VLAN接口配置模式时，就会创建一个SVI。值得注意的是，此处使用的VLAN编号应与802.1Q封装Trunk链路上数据帧携带的VLAN标签，或access端口上配置的VLAN ID一致。管理员要为每个VLAN的SVI分配一个IP地址，用于对应VLAN流量的路由选择。创建SVI时，首先应确保VLAN数据库中存在该VLAN，对于数据库中的VLAN，可以通过手动配置或通过VTP进行学习。 关于SVI的配置，应注意以下三点 存在该VLAN 有端口放行该VLAN SVI端口需要激活（no shutdown） 以下进行SVI配置，拓扑图如下所示 为各PC配置IP地址和网关 12345678910111213141516171819PC_A1(config)#int e0/0PC_A1(config-if)#ip address 192.168.10.1 255.255.255.0PC_A1(config-if)#no shutdownPC_A1(config)#ip default-gateway 192.168.10.254 PC_B1(config)#int e0/0PC_B1(config-if)#ip address 192.168.20.1 255.255.255.0PC_B1(config-if)#no shutdown PC_B1(config)#ip default-gateway 192.168.20.254 PC_A2(config)#int e0/0PC_A2(config-if)#ip address 192.168.10.2 255.255.255.0PC_A2(config-if)#no shutdown PC_A2(config)#ip default-gateway 192.168.10.254PC_B2(config)#int e0/0PC_B2(config-if)#ip address 192.168.20.2 255.255.255.0PC_B2(config-if)#no shutdown PC_B2(config)#ip default-gateway 192.168.20.254 在DSW1和DSW2上创建VLAN，并将连接PC的端口配置成access，划分到相应的VLAN 1234567891011121314151617DSW1(config)#vlan 10DSW1(config)#vlan 20DSW1(config)#int e0/0DSW1(config-if)#switchport mode access DSW1(config-if)#switchport access vlan 10DSW1(config)#int e0/1DSW1(config-if)#switchport mode access DSW1(config-if)#switchport access vlan 20DSW2(config)#vlan 10DSW2(config)#vlan 20DSW2(config)#int e0/0DSW2(config-if)#switchport mode access DSW2(config-if)#switchport access vlan 10DSW2(config)#int e0/1DSW2(config-if)#switchport mode access DSW2(config-if)#switchport access vlan 20 在DSW1和DSW2相连的端口上配置trunk 1234567DSW1(config)#int e0/2DSW1(config-if)#switchport trunk encapsulation dot1q DSW1(config-if)#switchport mode trunk DSW2(config)#int e0/2DSW2(config-if)#switchport trunk encapsulation dot1q DSW2(config-if)#switchport mode trunk 在DSW1和DSW2上开启路由功能（思科默认开启） 123DSW1(config)#ip routingDSW2(config)#ip routing 在DSW1为VLAN 10和VLAN 20的SVI配置IP地址，作为PC的网关 123456DSW1(config)#int vlan 10DSW1(config-if)#ip address 192.168.10.254 255.255.255.0DSW1(config-if)#no shutdown DSW1(config)#int vlan 20DSW1(config-if)#ip address 192.168.20.254 255.255.255.0DSW1(config-if)#no shutdown 此时PC_A1可以ping通PC_B1 PC_A1发起的流量经过DSW1上的VLAN 10的SVI，继而会被路由至VLAN 20的SVI接口，随后发送给PC_B1 PC_A1也可以ping通PC_B2 使用SVI实现VLAN间路由的优势 速度远远快于单臂路由器，因为流量的路由和交换处理都是通过硬件完成的 无需使用交换机到路由器的外部链路进行路由 没有单条链路的限制。可以在交换机之间使用2层EtherChannel来增加带宽 因为数据的处理无需离开交换机，因此延迟更低 使用SVI实现VLAN间路由的劣势 需要3层交换机来执行VLAN的路由，而使用3层交换机所需成本更高","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"SVI","slug":"SVI","permalink":"http://shain.top/tags/SVI/"}]},{"title":"在交换网络中部署EtherChannel技术","slug":"在交换网络中部署EtherChannel技术","date":"2020-09-05T08:09:30.000Z","updated":"2020-09-09T05:22:34.556Z","comments":true,"path":"2020/09/05/在交换网络中部署EtherChannel技术/","link":"","permalink":"http://shain.top/2020/09/05/%E5%9C%A8%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%83%A8%E7%BD%B2EtherChannel%E6%8A%80%E6%9C%AF/","excerpt":"在有些网络环境中，用户与资源之间的距离也许非常远，交换机与交换机之间或交换机与服务器之间的链路可能会变得非常阻塞。虽然通过线路改造可以增加这些链路的带宽，但并不是所有的链路都具备带宽升级的条件。因此，在以最大化节省现有投资为目的的前提下，EtherChannel技术应运而生。EtherChannel技术可以将多条物理链路捆绑成一条逻辑链路来解决流量拥塞的问题，在提升带宽的同时，也实现了冗余性。","text":"在有些网络环境中，用户与资源之间的距离也许非常远，交换机与交换机之间或交换机与服务器之间的链路可能会变得非常阻塞。虽然通过线路改造可以增加这些链路的带宽，但并不是所有的链路都具备带宽升级的条件。因此，在以最大化节省现有投资为目的的前提下，EtherChannel技术应运而生。EtherChannel技术可以将多条物理链路捆绑成一条逻辑链路来解决流量拥塞的问题，在提升带宽的同时，也实现了冗余性。 1、EtherChannel技术背景 EtherChannel技术最初是由Cisco开发的一种LAN交换机之间的链路技术，用来将多个百兆或千兆以太网端口放入一个逻辑的通道中。EtherChannel拥有以下多种优势： 利用已有交换机端口。无需升级交换机互联链路，从而节省投资成本。 大多数的配置都可以在EtherChannel接口下完成，而不需要分别在每个端口进行配置，这可以保证交换机之间端口配置的一致性。 EtherChannel技术支持多条链路的负载均衡。根据硬件平台的不同，可以在多条物理链路之间部署多种方式的负载均衡，如基于源MAC和目的MAC，或是基于源IP和目的IP。 除了交换机，其他网络设备也广泛地支持EtherChannel技术。在任何情况下，EtherChannel创建的都是一对一的逻辑链路。EtherChannel链路可以部署在两台交换机之间，也可以部署在启用了EtherChannel服务的服务器和交换机之间，但是，同一条EtherChannel不能向两台不同的交换机发送流量。一条EtherChannel链路的两端始终只连接着两台设备，而且这两台设备上EtherChannel组成员的端口配置也必须相同。 EtherChannel创建的汇聚链路会被看做是一条逻辑链路。当两台交换机之间存在多条EtherChannel链路时，生成树可能会阻塞其中的一条来防止出现环路。当生成树阻断了某条冗余链路时，也就阻断了一条EtherChannel链路，这条EtherChannel链路中的所有端口也都会被阻塞。如果仅有一条EtherChannel链路，捆绑中所有物理端口都会处于Active状态。因为对于生成树算法来说，多条物理链路捆绑后的EtherChannel链路是一条逻辑链路。如果EtherChannel中的某条物理链路出现了故障，EtherChannel会自动更新其捆绑带宽，对应的STP开销也会重新计算。 注：在三层交换机上，可以将设备的交换端口转化成路由端口。转换后的三层端口同样可以配置EtherChannel链路。在使用了例如VSS（虚拟交换系统）或vPC（虚拟端口通道）技术后，可以在一台接入层交换机和两台不同的汇聚层交换机之间创建EtherChannel链路。 2、EtherChannel协商协议 可以使用以下三种机制之一来创建EtherChannel LACP： IEEE标准协商协议 PAgP： Cisco私有协商协议 静态配置： 无协商协议 LACP 链路汇聚控制协议（LACP）是一种由IEEE定义的标准（802.3ad），允许将多个 物理端口捆绑到一起形成一个逻辑通道。LACP允许交换机发送LACP数据包来与对端自动协商捆绑通道。由于LACP属于IEEE制定的业界标准，因此可以在不同厂商设备的环境中协商EtherChannel链路。LACP会检查两台交换机的配置一致性以及链路状态，用来确保EtherChannel创建时，所有端口配置有相同的端口速率、双工模式、VLAN信息等。在通道建立之后，任一端口的配置修改都会影响通道另一端的端口状态。 LACP数据包会在启用了EtherChannel功能的端口上进行交换。接收方会将对端的端口属性与自身的端口属性进行比较。LACP会为EtherChannel端口分配角色。带有最低的系统优先级的交换机将决定哪些活动端口可以加入EtherChannel。端口根据其优先级选举出Active端口。数值越低表示越优先。一般来说，一个EtherChannel最大支持16条链路。同一时间只能有8条处于Active（活动）状态。其余8条非Active端口将处于Standby（备用）状态。如果某条Active链路发生故障，Standby端口将接管成为Active端口。 两台交换机之间建立EtherChannel的最大Active链路数量是可变的 LACP操作模式如下 ①Active：使端口进入主动协商状态，发送LACP数据包主动与其他接口进行协商 ②Passive：使端口进入被动协商状态，对LACP数据包做出响应 ③On：强制端口形成EtherChannel，不需要使用LACP或PAgP进行协商 PAgP 端口聚合协议（PAgP）提供了与LACP类似的协商优点。PAgP是Cisco私有协议，因此只能运行在Cisco设备上。PAgP数据包会在启用了EtherChannel功能的端口上进行交换，每30s发送过一次。接收方会将对端的端口属性与自身的端口属性进行比较，具有相同属性的端口将被捆绑进同一个EtherChannel中。PAgP只能在配置有相同VLAN或Trunk属性的端口上形成EtherChannel。如果捆绑中的端口修改了配置，那么PAgP也会重新协商EtherChannel的参数。例如，捆绑中的某个端口的速率、双工模式或VLAN信息做了配置修改，PAgP将会重新考虑捆绑中其他端口的参数。PAgP与LACP协议之间不能兼容。 PAgP操作模式如下： ①Desirable：使端口进入主动协商的状态，发送PAgP数据包 ②Auto：使端口进入被动协商的状态，对PAgP数据包做出响应 ③On：强制端口不使用PAgP而形成EtherChannel，不会交换PAgP数据包 3、EtherChannel配置实例 LACP验证 ①首先将交换机之间的端口配置成Trunk 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ②在SW1上配置EtherChannel，创建端口组1，模式为Active 123SW1(config)#int range e0/0-1SW1(config-if-range)#channel-group 1 mode active Creating a port-channel interface Port-channel 1 ③在SW2上配置EtherChannel，创建端口组1，模式为Passive 123SW2(config)#int range e0/0-1SW2(config-if-range)#channel-group 1 mode passive Creating a port-channel interface Port-channel 1 配置后，两个端口将被捆绑到channel-group 1中。由于使用了active关键字，因此将使用LACP协议进行协商。SW1配置了LACP的active模式，SW2配置了LACP的passive模式，因此EtherChannel可以协商成功。 ④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式 123456SW1(config)#int port-channel 1SW1(config-if)#switchport trunk encapsulation dot1q SW1(config-if)#switchport mode trunk SW2(config)#int port-channel 1SW2(config-if)#switchport trunk encapsulation dot1q SW2(config-if)#switchport mode trunk ⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息 如下图所示，port-channel 1是一个正在使用的2层EtherChannel（SU标志）。协商协议使用的是LACP，捆绑成功的端口包括Ethernet 0/0和Ethernet 0/1（P标志） ⑥在SW1上查看Ethernet 0/0和port-channel 1的信息，可知带宽变为原来的两倍 PAgP验证 ①将交换机之间的端口配置成Trunk 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ②在SW1上配置EtherChannel，创建端口组1，模式为Desirable 123SW1(config)#int range e0/0-1SW1(config-if-range)#channel-group 1 mode desirable Creating a port-channel interface Port-channel 1 ③在SW2上配置EtherChannel，创建端口组2，模式为auto 123SW2(config)#int range e0/0-1SW2(config-if-range)#channel-group 2 mode auto Creating a port-channel interface Port-channel 2 ④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式 123456SW1(config)#int port-channel 1SW1(config-if)#switchport trunk encapsulation dot1q SW1(config-if)#switchport mode trunk SW2(config)#int port-channel 2SW2(config-if)#switchport trunk encapsulation dot1q SW2(config-if)#switchport mode trunk ⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息 ⑥在SW2上查看Ethernet 0/0和port-channel 2的信息，可知带宽变为原来的两倍 On验证 ①将交换机之间的端口配置成Trunk 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ②在SW1和SW2上配置EtherChannel，创建端口组1，模式为On 12345SW1(config)#int range e0/0-1SW1(config-if-range)#channel-group 1 mode onSW2(config)#int range e0/0-1SW2(config-if-range)#channel-group 1 mode on Creating a port-channel interface Port-channel 1 ④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式 123456SW1(config)#int range e0/0-1SW1(config-if-range)#switchport trunk encapsulation dot1q SW1(config-if-range)#switchport mode trunk SW2(config)#int range e0/0-1SW2(config-if-range)#switchport trunk encapsulation dot1q SW2(config-if-range)#switchport mode trunk ⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息 ⑥在SW2上查看Ethernet 0/0和port-channel 2的信息，可知带宽变为原来的两倍 4、EtherChannel负载均衡方式 EtherChannel中的流量可以分担到捆绑中的每条链路上。不过，流量并不是严格平均分布到每条链路上的。数据帧选择EtherChannel链路上哪条链路转发取决于哈希算法的结果，不同的设备平台使用的哈希计算算法也不尽相同。 在同一个EtherChannel的多个端口成员之间实现负载分担是配置EtherChannel的一个重要因素。管理员可以把负载分担选项当作一个规则，从而极大程度上丰富配置的多样性。举例来说，如果某条通道上的流量只去往单一的MAC地址，那么管理员既可以根据目的MAC地址进行配置，使其总是选择通道中的相同链路;也可以根据源地址进行配置，这样做可以实现更好的负载分担。 负载分担会在全局应用于交换机上的所有EtherChannel，可以使用命令port-channel load-balance来实现这项技术。负载分担可以基于以下变量实现： src-mac：源MAC地址 dst-mac：目的MAC地址 src-dst-mac：源和目的MAC地址 src-ip：源IP地址 dst-ip：目的IP地址 src-dst-ip：源和目的IP地址（默认） src-port：源TCP/UDP（用户数据报协议）端口 dst-port：目的TCP/UDP端口 src-dst-port：源和目的TCP/UDP端口 例如，源MAC地址转发是指当数据包被发送给EtherChannel，设备会根据入站数据包的源MAC地址来判断应该将数据包从通道的哪个端口转发出去。于是，来自不同主机的数据包就会从通道的不同端口中转发出去，而来自同一台主机的数据包会从通道的同一端口中转发出去，这就是实现了负载分担。 SW1和SW2之间使用LACP协商建立EtherChannel链路，如下图所示 输入show etherchannel load-balance命令来查看EtherChannel使用的负载均衡信息 此前并未在交换机上配置负载均衡，可见该交换机上默认的负载均衡方式为src-dst-ip，即基于源和目的IP地址进行负载分担 为了测试上图所示的拓扑中每条链路上分布的流量，在SW1上输入clear counters命令清空计数器，即可准确地测试出每条链路分布的流量 12SW1#clear counters Clear &quot;show interface&quot; counters on all interfaces [confirm] 使用扩展ping命令，从PC1上 ping PC3 在SW1上查看两个端口的计数器 可见大多数流量都分布在了E0/0接口上，通过E0/0端口承载 将SW1的负载均衡方式修改为dst-ip 1SW1(config)#port-channel load-balance dst-ip 查看修改后的负载均衡方式","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"EtherChannel","slug":"EtherChannel","permalink":"http://shain.top/tags/EtherChannel/"}]},{"title":"VTP协议","slug":"VTP协议","date":"2020-09-03T15:27:59.000Z","updated":"2020-09-05T07:57:14.244Z","comments":true,"path":"2020/09/03/VTP协议/","link":"","permalink":"http://shain.top/2020/09/03/VTP%E5%8D%8F%E8%AE%AE/","excerpt":"VTP（VLAN Trunking Protocol）用来在整个交换网络中分发和同步VLAN数据库，可以将配置错误和配置不一致等问题导致障碍的几率降至最低。这些问题包括重复的VLAN名称、不正确的VLAN类型，以及安全性违规等。","text":"VTP（VLAN Trunking Protocol）用来在整个交换网络中分发和同步VLAN数据库，可以将配置错误和配置不一致等问题导致障碍的几率降至最低。这些问题包括重复的VLAN名称、不正确的VLAN类型，以及安全性违规等。 1、VTP概述 VTP是一种通过添加、删除、修改VLAN等管理操作，来维护网络内VLAN配置一致性的2层协议。 交换机只能通过802.1Q或ISL Trunk传输VTP消息。Cisco交换机会通过管理VLAN（默认为VLAN 1），使用2层组播数据帧每5分钟传输一次VTP汇总通告。在单台VTP服务器上的VLAN配置会通过Trunk链路宣告给网络中的所有互联交换机。例如，当管理者添加了一个新的VLAN，那么VTP会将VLAN信息宣告给VTP域内的所有交换机，每台交换机会同步VLAN信息，再将这些信息合并成新的VLAN数据库。 VTP域是由一台或多台共享相同VTP配置的互联的交换机组成的，每台交换机只能处于一个VTP域中。默认情况下，Cisco Catalyst交换机处于”no-management-domain”状态（null状态），直到通过Trunk链路收到了带有域名的VTP通告，或手动配置了VTP域名。配置应在VTP服务器上执行，随后会通过Trunk链路宣告给网络中的所有互联交换机。当VTP域名及VTP密码匹配之后，配置信息将会同步。 VTP是Cisco私有的协议。 2、VTP模式 VTP可以工作在3种模式下：服务器（server）模式、客户端（client）模式、透明（transparent）模式。VTP服务器模式是默认的模式，不过在未配置或未学习到 VTP域名时，VLAN信息是不会宣告到网络中的。需要注意的是，VTP消息仅会在Trunk链路上传播。VTP客户端模式与服务器模式相似，在Trunk链路上发送和接收VTP更新。处于VTP客户端模式的交换机无法创建、删除或修改VLAN，其学习到的VLAN都是由域内的VTP服务器模式的交换机所创建的。处于VTP透明模式的交换机对VLAN进行操作时，配置仅会影响到本地交换机，VLAN的修改信息并不会宣告给VTP域中的其他交换机，但是在该模式下的交换机可以将收到的VTP宣告转发出去。三种模式总结如下所示： 服务器模式 可以创建、删除、修改VLAN 可以发送及转发VTP通告 同步VLAN的配置 客户端模式 不能创建、删除、修改VLAN 可以发送及转发VTP通告 同步VLAN的配置 透明模式 可以创建、删除、修改本地VLAN 可以转发VTP通告 不同步VLAN配置 3、VTP版本 Ｃisco Catalyst交换机支持三种不同版本的VTP：版本1、版本2、版本3。不同版本的VTP之间无法通信，因此管理者必须确定使用哪个版本的VTP。此外，出于稳定性方面的考虑，Cisco建议只使用一种版本的VTP。 Ｃisco交换机上默认启用的VTP版本是版本1。相比于旧版本的VTP，新版本的VTP支持以下特性： 与版本无关的透明模式：在VTP版本1中，VTP透明模式的网络设备会检查VTP消息中的域名和版本信息，而且只有当域名和版本号相匹配时才会转发此消息。由于Cisco IOS软件中只支持一个VTP域，因此在VTP版本2中会直接转发VTP消息，而不会检查其版本号。 一致性检查：在VTP版本2中，会对VLAN名称及VLAN编号进行VLAN一致性检查。不过，只有通过命令行界面（CLI）或简单网络管理协议（SNMP）输入的信息才会触发一致性检查，如果新信息是通过VTP消息或NVRAM中读取的，则不会执行一致性检查。如果接收到的VTP消息MD5比对正确，VTP版本2会直接接收此消息，而不会执行一致性检查。 支持令牌环：VTP版本2支持令牌环交换和令牌环VLAN。 支持未识别TLV（Type-Length-Value）：在VTP版本1中，未被识别的VTP消息会被直接丢弃，而VTP版本2会将未识别的消息转发出去并将其保存在NVRAM中。 支持扩展VLAN：VTP版本3可支持VLAN10254094的消息通告（VLAN编号10061024以及4095~4096被保留）。 域名不自动学习：在VTP版本2中，交换机会从接收的VTP信息中自动学习到新的VTP域名。由于这种行为比较危险，因此在VTP版本3中，此功能需要手动强制开启。 更优的安全性：VTP域密码以一种安全的方式传输并存储在交换机数据库中。 更优的数据库宣告机制：只有主用服务器允许更新其他设备，而且每个VTP域内一台主用服务器。 支持多生成树（MST）：VTP版本3加入了对MST进程通告的支持。 4、VTP修剪 VTP修剪（pruning）技术使用VLAN通告消息来判断Trunk连接何时正在泛洪不必要的流量。默认情况下，Trunk连接会承受VTP管理域中所有的VLAN流量，但一般情况下，企业网络中的多数交换机并没有为每个VLAN都配置本地端口。 VTP修剪技术可以将可泛洪的流量限制在合适的范围内，仅允许必要的VLAN流量通过Trunk链路，从而提高链路的可用带宽。如下图所示的交换网络启用了VTP的修剪功能，从Red VLAN中的主机或工作站发出的广播流量不会转发给交换机3、5和6，因为Red VLAN已经在交换机2、4的链路上被修剪掉了。 无论是否使用了VTP修剪功能，Catalyst交换机都会为每个VLAN运行一个STP实例，即使VLAN中没有活动端口，或VTP修剪已经将VLAN从接口上移除了出去。因此，VTP修剪能够防止将流量泛洪传播给没有特定VLAN成员的交换机。不过，VTP修剪不会将已被修剪的VLAN信息从交换机上删除。 5、VTP认证 管理员可以使用VTP密码特性来增强VTP域的安全性。必须要保证VTP域内的所有交换机使用了相同的密码及域名；否则，交换机无法成为VTP域的成员。Cisco交换机使用MD5算法将密码编码成16字节的密码。这些密码会在VTP汇总通告中进行传播。在VTP中，密码是区分大小写的，长度为8~64个字符。建议在所有VTP域中使用VTP认证特性。 6、VTP通告 VTP通告会在整个管理域中泛洪。交换机默认每隔5分钟发送过一次VTP通告，当VLAN的配置发生变化时会触发发送VTP通告。VTP通告使用组播帧在native VLAN（默认为VLAN 1）中以不打标签的方式传播。每个VTP通告中都包含了一个配置修订号。配置修订号越高，表示VLAN信息越新。配置修订号（configuration revision number）是VTP中非常重要的参数。每次VTP服务器在对VLAN进行操作（增加、删除、修改VLAN信息）时，都会将配置修订号加1。随后VTP服务器发送的VTP通告将带有新的配置修订号。如果VTP域内的其他交换机收到了带有更高配置修订号的VTP通告，将会使用新收到的VLAN信息更新自身的VLAN配置。由于VTP透明模式的交换机不会与域内的其他交换机同步VLAN的信息，所以其配置修订号或VLAN数据库将不会改变（始终为0）。 注意：根据VTP的更新规则，如果一台删除了所有VLAN并带有更高的配置修订号的VTP服务器加入到VTP域中，那么域内所有设备上的VLAN都会被覆盖删除 设备在接收到VTP通告后，需要对一些参数进行检查，之后才会合并其中的VLAN信息。首先就是管理域名和密码必须与本地交换机配置的一致。其次，如果配置修订号比当前交换机的高时，交换机才会合并这条VLAN通告信息。在许多Cisco Catalyst交换机上，可以通过修改VTP域名称的方式重置配置修订号；还可以将其模式修改成透明模式，再改回先前的服务器或客户端模式。这两种方法都可以让配置修订号归零。 7、VTP消息类型 汇总通告（Summary Advertisement） 默认情况下，Catalyst交换机会每5分钟发送一次汇总通告消息。汇总通告消息会通知邻接Catalyst交换机当前的VTP域名及配置修订号。当交换机接收到汇总通告数据包时，会将数据包中的域名与本地配置的VTP域名相比较。如果名称不同，交换机就会忽略这个数据包。如果域名相同，交换机会继续比较配置修订号，如果自身的配置修订号高于或等于接收数据包的修订号，数据包也会被忽略。如果本地的配置修订号比收到的低，交换机则会发送一个请求通告消息。 子集通告（Subnet Advertisement） 当管理员在Catalyst交换机上添加、删除或修改VLAN时，配置修订号会相应地增加，并且会发送一条汇总通告消息。随后，还会发送一条或多条子集通告消息。每条自己通告包含一个VLAN信息列表。如果VLAN的数量很多，就会以多条子集通告的形式通告所有VLAN。 请求通告（Request Advertisement） 当交换机重启、VTP域名被修改或当交换机收到了一个配置修订号高于自身的VTP汇总通告时，交换机会发送VTP请求通告消息。在收到了一个请求通告后，VTP设备会发送一条汇总通告消息，随后再发送一条或多条子集通告消息。 8、VTP配置实例 VTP配置所使用的拓扑如下图所示，其中SW1配置成了VTP服务器模式；SW2配置成了VTP客户端模式；SW3配置成了透明模式 在进行VTP配置前，应注意将三台交换机之间的链路配置成Trunk链路，因为VTP消息仅会在Trunk链路上传播 在所有交换机上配置VTP，SW1配置成服务器模式，SW2配置成客户端模式，SW3配置成透明模式 默认状态下的交换机运行的是VTP版本1 1234567891011121314SW1(config)#vtp password ciscoSW1(config)#vtp mode serverSW1(config)#vtp domain shainSW1(config)#vtp version 1SW2(config)#vtp password ciscoSW2(config)#vtp mode client SW2(config)#vtp domain shainSW2(config)#vtp version 1SW3(config)#vtp password ciscoSW3(config)#vtp mode transparent SW3(config)#vtp domain shainSW3(config)#vtp version 1 在SW2上输入命令show vtp status查看本交换机的VTP状态信息 能看到SW2配置成了VTP客户端模式（client），处于VTP域shain内 当前交换机上只有5个默认的VLAN：VLAN1和VLAN1002~1005。VTP配置修订号为0。此值为0以为着这台交换机的VLAN数据库未做任何修改。每次对VLAN进行操作（增加、删除、修改），配置修订号都会加1。 在SW1上输入命令show vtp status 可以看到SW1配置成了VTP服务器模式（server） 与SW2一样，当前设备上只有默认VLAN。VTP配置修订号为0，VTP域名为shain。 在SW3输入命令show vtp status SW3配置成了VTP透明模式（transparent） 和SW1、SW2一样，当前设备上只有默认VLAN。VTP配置修订号为0，VTP域名为shain 在SW1上创建VLAN 10 1SW1(config)#vlan 10 注意：在VTP客户端模式下是无法添加VLAN的。若在SW2上尝试添加VLAN 5，SW2则会提示如下信息： SW2(config)#vlan 5VTP VLAN configuration not allowed when device is in CLIENT mode. 在SW1上检查VLAN数据库及VTP状态 使用命令show vlan和命令show vtp status VLAN 10此时已经出现在了SW1的数据库中 SW1上的配置修订号也增加到了1 检查SW2上的VLAN数据库和VTP状态 使用命令show vlan和命令show vtp status 由于SW2为VTP客户端模式，因此从SW1学习到了VLAN 10 SW2当前的配置修订号与SW1相同，代表两台交换机拥有相同的VLAN数据库 检查SW3上的VLAN数据库和VTP状态 使用命令show vlan和命令show vtp status 由于SW3处于VTP透明模式，因此永远不会和其他处于任何VTP模式的交换机同步自身的VLAN数据库 从某种程度上讲，启用VTP透明模式就等同于关闭了VTP功能 注意此时SW3上并没有VLAN 10 VTP透明模式的交换机配置修订号始终为0 在SW3上创建VLAN 20 1SW3(config)#vlan 20 在三台交换机上检查VLAN 20是否存在 从以下显示结果中可以看出VTP透明模式的交换机可以创建、删除本地VLAN，但是不会将本地VLAN的信息通告给其他交换机 VLAN 20仅存在与SW3上 9、VTP配置覆盖（VTP常见问题） VTP的一个常见问题就是由于管理员的粗心大意，错误地将整个网络中的VLAN数据库配置删除。因此，当向网络中添加一台交换机时，一定不能将错误的信息注入到现网中。如下图所示，SW1是一台VTP服务器，SW2和SW3是VTP客户端。所有交换机同步后的配置修订号均为12，并带有VLAN 10、20、30和40。每台交换机上有多个用户连接到不同的VLAN。 查看SW1上的VTP状态和VLAN数据库信息 SW2和SW3有着与SW1同样的配置修订号及VLAN信息，这是因为VTP已经完全同步 现在假定SW2发生了故障，从配线间取出了另外一台交换机来替代SW2 backup交换机配置了与其他两台交换机相同的VTP域名，VTP的配置修订号为29，比现网中的VTP修订号要高 backup交换机的VLAN信息和VTP信息如下图所示 默认情况下，Cisco IOS VTP服务器和客户端会将VLAN信息保存在flash下的vlan.dat文件中，其中包括了VLAN表以及配置修订号。删除vlan.dat文件并重启交换机可以将VTP和VLAN信息彻底删除，其删除方式根据具体交换机型号而定。 处于VTP透明模式的交换机可以使用show running-config命令查看VLAN和VTP配置，这是由于配置是存放在配置文本文件中的，而不是vlan.dat。因此在VTP透明模式的交换机上执行erase startup-config命令的话，所有的VLAN信息都会被删除。 由于backup交换机带有更高的配置修订号，因此SW1和SW3都会与其同步。分别在SW1和SW3上查看VLAN和VTP状态 VLAN20、30、40将从SW1和SW3上删除，连接到这些VLAN的终端用户也会失去其连通性 查看SW1的VLAN信息和VTP状态 查看SW3上的VLAN信息和VTP状态 因此，当一台带有更高配置修订号的交换机加入到VTP域中时，很有可能会导致重大的网络故障。当VTP客户端交换机加入到网络时，会发送一个自身数据库的汇总通告。也就是说，带有更高配置修订号的交换机，无论是服务器模式还是客户端模式，都会导致现网交换机的VTP配置覆盖（VLAN重新学习）。 10、VTP部署的推荐做法 VTP一般使用在新建网络中，用来减轻VLAN的配置工作。不过，随着网络规模数日渐增大，伴随而来的也有一些风险。如果VTP域内的某台VTP服务器意外地删除了一个VLAN，那么VTP域所在网络都会删除这个VLAN。已经预先配置过VLAN的交换机加入到了网络中，那么VTP域所在网络中的所有交换机的VLAN数据库都可能被覆盖。因此，部署VTP时建议先将所有交换机配置成VTP透明模式，并手动按需添加VLAN，尤其是在大型园区网环境中。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"VTP","slug":"VTP","permalink":"http://shain.top/tags/VTP/"}]},{"title":"NAT和PPP的应用","slug":"NAT和PPP的应用","date":"2020-09-02T15:27:30.000Z","updated":"2020-09-03T01:35:21.332Z","comments":true,"path":"2020/09/02/NAT和PPP的应用/","link":"","permalink":"http://shain.top/2020/09/02/NAT%E5%92%8CPPP%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"1、实验目的1）理解NAT的作用2）理解不同NAT的特点及配置3）理解不同NAT的使用场合4）掌握PPP的PAP和CHAP验证5）理解辅助地址的作用6）掌握NAT的验证和查看命令","text":"1、实验目的1）理解NAT的作用2）理解不同NAT的特点及配置3）理解不同NAT的使用场合4）掌握PPP的PAP和CHAP验证5）理解辅助地址的作用6）掌握NAT的验证和查看命令 2、拓扑结构 3、实验步骤（1）公司COM1和COM2内部网段都为192.168.1.0/24，其中COM1的SRV地址为192.168.1.100/24，COM2的user地址为192.168.1.10/24，COM1内部的其他主机地址自己规划；ISP上的Web_Server地址为211.1.1.1/24，ISP与COM2之间的地址段为202.101.12.0/24，ISP与COM1之间的地址段为202.101.23.0/24，其中COM2连接ISP的接口地址为202.101.12.1/24，COM1连接ISP的接口地址为202.101.23.3/24 IP地址规划如拓扑图所示 （2）要求COM1与ISP之间的PPP链路采用CHAP验证，用户名为20164120，密码为123456 在ISP的s2/0封装PPP，并指定PPP的认证方式为CHAP，指定对方的IP地址为202.101.23.3 在全局下设置用户名和密码，用于chap验证 在COM1上s2/0接口封装PPP，指定IP地址为通过协商获取，填写用户名和密码，并让ISP下发默认路由 查看COM1上的IP地址，可知s2/0接口的IP地址为通过IPCP方式获得 查看COM1的路由表中的静态路由条目，可知存在一条默认路由 （3）在COM1上使用静态NAT实现SRV可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试 在COM1上启用一个loopback接口，用于静态nat的一对一映射 配置静态nat，将SRV的IP地址192.168.1.100映射到COM1上的loopback接口的地址 在ISP上配置静态路由，实现ISP可以访问COM1上的loopback接口 在COM1上配置内部接口和外部接口 此时SRV可以访问ISP上的Web_Server 在COM1上查看nat转换表，可知将192.168.1.100转换成200.100.1.1 由于采用静态NAT，所以此时Web_Server也可以通过200.100.1.1访问SRV 在Web_Server上使用telnet命令远程登录到200.100.1.1，由下图可知此时登录到的设备为SRV （4）在COM1上使用复用地址池的方式实现COM1内的所有用户可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试 在COM1上配置地址池，范围为202.101.23.10~202.101.23.12，掩码为/24 配置ACL，匹配192.168.1.0/24网段的流量 配置复用地址池NAT 此时各PC可以访问Web_Server 在COM1上查看nat转换表，地址在COM1上执行了地址转换 使用debug ip nat命令查看地址转换信息 （5）在COM1和COM2上使用PAT方式实现COM1和COM2内部的用户都可以访问ISP上的Web_Server 由于COM1上已存在ACL 1匹配192.168.1.0/24网段的流量，所以此时可以直接在COM1上配置端口复用NAT 测试COM1内部的用户与Web_Server的连通性 查看地址转换表 在COM2上配置默认路由，下一跳指向ISP的e0/0接口的地址202.101.12.2，确保COM2可以访问Web_Server 在COM2上使用命名的标准ACL匹配192.168.1.0/24网段的流量 配置PAT 指定内外部接口 测试COM2内部用户与Web_Server的连通性 在COM2上查看nat转换表，可知内部用户192.168.1.10在访问外部网络时将地址转换成了202.101.12.1 （6）实现COM2内部的COM2_USER可以远程登录到SRV 在COM1上配置静态nat，将SRV的地址192.168.1.100的tcp23号端口静态映射成200.100.1.1的5656号端口 在COM2_USER上使用telnet命令远程登录到SRV，此时应注意加上端口号","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"NAT","slug":"NAT","permalink":"http://shain.top/tags/NAT/"},{"name":"PPP","slug":"PPP","permalink":"http://shain.top/tags/PPP/"}]},{"title":"ACL的运用","slug":"ACL的运用","date":"2020-09-01T13:46:13.000Z","updated":"2020-09-01T15:58:45.883Z","comments":true,"path":"2020/09/01/ACL的运用/","link":"","permalink":"http://shain.top/2020/09/01/ACL%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"1、实验目的1）掌握ACL的作用2）理解标准和扩展ACL的区别3）熟悉标准和扩展ACL的配置4）掌握ACL的验证和查看命令5）理解命名的ACL的作用与配置","text":"1、实验目的1）掌握ACL的作用2）理解标准和扩展ACL的区别3）熟悉标准和扩展ACL的配置4）掌握ACL的验证和查看命令5）理解命名的ACL的作用与配置 2、拓扑结构 3、实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划 两台PC及三台路由器的IP地址配置如拓扑图所示，此处不再将图贴出 （2）在R2上添加两个loopback接口，loopback1和loopback2，其中loopback1地址为2.2.2.2/24，loopback2地址为22.22.22.22/24 （3）完成必要的配置实现全网可达 在路由器上运行路由协议，实现全网可达 （4）使用标准ACL实现PC1不能访问PC2，并使用ping命令验证结果 标准ACL建议在离目标近的设备上配置，在R3上配置ACL拒绝来自主机172.16.1.1的流量，并在进接口方向调用，此时实现PC1不能访问PC2 （5）使用标准ACL实现只允许PC2远程登录到路由器R2，并使用telnet命令验证结果 在R2上配置ACL，允许主机172.16.3.1的流量，默认隐含一条拒绝所有，即拒绝除PC2之外的流量。在vty中允许其他设备使用telnet远程登录，并在in方向调用ACL 在PC1和PC2上进行测试，此时实现了只允许PC2远程登录到R2 （6）使用标准ACL实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制 在R1上配置ACL，允许loopback1网段，拒绝loopback2网段，然后在e0/1接口的in方向调用 此时实现了R2上的loopback1网段可以访问PC1，而loopback2网段不能 （7）使用命名ACL完整上述标准ACL的需求 实现PC1不能访问PC2 实现只允许PC2远程登录到路由器R2 实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制 （8）使用扩展ACL实现禁止PC1远程登录到R2，对其他访问不做限制 （9）使用扩展ACL实现PC2可以telnet到路由器R1，但不能ping通路由器R1，分别使用ping和telnet验证结果 （10）使用扩展ACL实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果 ICMP echo request –echo的请求包 echo reply –echo的响应包 只有以上两种报文是正常的，那么此时的ping才是能通的 PC1 ping PC2 正常 PC1 给 PC2 发送的echo request是正常的（源是PC1，目标是PC2） PC2给PC1发送的echo reply也是正常的（源是PC2，目标是PC1） PC2 ping PC1 不正常 PC2不能给PC1发送 echo request（源是PC2，目的是PC1） PC2不能接收到来自PC1的echo reply（源是PC1，目的是PC2） （11）使用命名ACL完成上述扩展ACL的需求 实现禁止PC1远程登录到R2，对其他访问不做限制 实现PC2可以telnet到路由器R1，但不能ping路由器R1，分别使用ping和telnet验证结果 实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果 方法一：拒绝PC2向PC1发送icmp的echo-request报文 方法二：拒绝PC1向PC2发送icmp的echo-reply报文","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"ACL","slug":"ACL","permalink":"http://shain.top/tags/ACL/"}]},{"title":"DMVPN验证","slug":"DMVPN验证","date":"2020-09-01T08:14:49.000Z","updated":"2020-09-01T12:07:55.749Z","comments":true,"path":"2020/09/01/DMVPN验证/","link":"","permalink":"http://shain.top/2020/09/01/DMVPN%E9%AA%8C%E8%AF%81/","excerpt":"DMVPN三个阶段 阶段一：中心到节点的设计（Hub-to-Spoke Design） 阶段二：节点到节点的设计（Spoke-to-Spoke Design） 阶段三：分层（基于树的）设计（Hierachical [Tree-Based] Design） 本文将从三个阶段对DMVPN进行验证","text":"DMVPN三个阶段 阶段一：中心到节点的设计（Hub-to-Spoke Design） 阶段二：节点到节点的设计（Spoke-to-Spoke Design） 阶段三：分层（基于树的）设计（Hierachical [Tree-Based] Design） 本文将从三个阶段对DMVPN进行验证 1、拓扑结构 在进行验证之前，确保R1、R3、R4存在默认路由，使得三台路由器之间可以相互ping通 2、phase-1验证 hub端是mGRE，分支端是常规的GRE，分支之间的流量必须经过hub，可以采取关闭水平分割来实现分支之间的路由互相学习，可以在hub端进行手工的路由汇总，来优化分支的路由条目 hub配置 12345678R1(config)#int tunnel 1R1(config-if)#ip address 10.1.1.1 255.255.255.0 //隧道地址R1(config-if)#tunnel source 202.101.12.1 //指定隧道源地址(隧道目的地址可通过nhrp解析)R1(config-if)#tunnel mode gre multipoin //R1为hub，所以指定gre隧道模式为multipointR1(config-if)#tunnel key 100000 //指定隧道的key，可用于隧道的身份验证R1(config-if)#ip nhrp network-id 12345 //指定nhrp的标识，hub和spoke之间的network-id必须一致R1(config-if)#ip nhrp authentication cisco123 //nhrp身份验证R1(config-if)#ip nhrp map multicast dynamic //开启组播映射功能 spoke(R3)配置 12345678910R3(config)#int tunnel 1R3(config-if)#ip address 10.1.1.3 255.255.255.0R3(config-if)#tunnel source 202.101.23.3R3(config-if)#tunnel destination 202.101.12.1R3(config-if)#tunnel key 100000R3(config-if)#ip nhrp network-id 12345R3(config-if)#ip nhrp authentication cisco123 R3(config-if)#ip nhrp map 10.1.1.1 202.101.12.1 //映射hub的逻辑地址到物理地址R3(config-if)#ip nhrp map multicast 202.101.12.1 //映射组播信息到hub地址R3(config-if)#ip nhrp nhs 10.1.1.1 //指定next-hop-server为10.1.1.1 R1和R3的隧道地址可以相互ping通 在R1上查看地址的映射关系——10.1.1.3映射到的公网地址为202.101.23.3 spoke(R4)配置 12345678910R4(config)#int tunnel 1R4(config-if)#ip address 10.1.1.4 255.255.255.0R4(config-if)#ip nhrp network-id 12345R4(config-if)#ip nhrp authentication cisco123R4(config-if)#ip nhrp nhs 10.1.1.1R4(config-if)#ip nhrp map 10.1.1.1 202.101.12.1R4(config-if)#ip nhrp map multicast 202.101.12.1R4(config-if)#tunnel source 202.101.24.4R4(config-if)#tunnel destination 202.101.12.1R4(config-if)#tunnel key 100000 无需再在R1上配置，即可ping通R4的隧道地址，并且也记录了R4的逻辑地址和物理地址的映射关系 分别在R1、R3、R4上各启用一个loopback接口，地址设置如下所示 123456R1(config)#int loopback 1R1(config-if)#ip add 172.16.1.1 255.255.255.0R3(config)#int loopback 1R3(config-if)#ip address 172.16.3.1 255.255.255.0R4(config)#int loopback 1R4(config-if)#ip add 172.16.4.1 255.255.255.0 启用EIGRP协议 1234567891011121314R1(config)#router eigrp 110R1(config-router)#no auto-summary R1(config-router)#network 172.16.1.0 0.0.0.255R1(config-router)#network 10.1.1.0 0.0.0.255R3(config)#router eigrp 110R3(config-router)#no auto-summary R3(config-router)#network 172.16.3.0 0.0.0.255R3(config-router)#network 10.1.1.0 0.0.0.255R4(config)#router eigrp 110R4(config-router)#no auto-summary R4(config-router)#network 172.16.4.0 0.0.0.255R4(config-router)#network 10.1.1.0 0.0.0.255 在R1上查看EIGRP邻居表，可知R1通过1个隧道接口建立了两个邻居关系 在R1的e0/0接口抓包，报文如下图所示，但是此时的报文都为明文显示，需要进行加密 在R1、R3和R4上配置IPSec，保护隧道上的数据 12345678910111213R1(config)#crypto isakmp policy 10R1(config-isakmp)#authentication pre-shareR1(config-isakmp)#exit R1(config)#crypto isakmp key cisco123 address 0.0.0.0R1(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac R1(cfg-crypto-trans)#mode transport R1(cfg-crypto-trans)#exitR1(config)#crypto ipsec profile dprofileR1(ipsec-profile)#set transform-set dmvpnR1(ipsec-profile)#exitR1(config)#int tunnel 1R1(config-if)#tunnel protection ipsec profile dprofile*Aug 31 02:59:34.650: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON 1234567891011121314R3(config)#crypto isakmp policy 10R3(config-isakmp)#authentication pre-share R3(config-isakmp)#exitR3(config)#crypto isakmp key cisco123 address 0.0.0.0R3(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac R3(cfg-crypto-trans)#mode transport R3(cfg-crypto-trans)#exitR3(config)#crypto ipsec profile dprofileR3(ipsec-profile)#set transform-set dmvpnR3(ipsec-profile)#exitR3(config)#int tunnel 1R3(config-if)#tunnel protection ipsec profile dprofile*Aug 31 03:02:49.557: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON 12345678910111213R4(config)#crypto isakmp policy 10R4(config-isakmp)#authentication pre-share R4(config-isakmp)#exit R4(config)#crypto isakmp key cisco123 address 0.0.0.0R4(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac R4(cfg-crypto-trans)#mode transport R4(cfg-crypto-trans)#exitR4(config)#crypto ipsec profile dprofileR4(ipsec-profile)#set transform-set dmvpnR4(ipsec-profile)#exitR4(config)#int tunnel 1R4(config-if)#tunnel protection ipsec profile dprofile*Aug 31 03:06:36.128: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON 验证是否进行了加密 此时R3上的路由表并没有172.16.4.0的路由条目，因为存在水平分割问题 在R1的隧道接口中关闭水平分割 12R1(config)#int tunnel 1R1(config-if)#no ip split-horizon eigrp 110 再次查看R3的路由表 ，此时学习到了172.16.4.0的路由条目 跟踪路由，可知分支之间的流量必须经过hub 可通过在hub上进行路由汇总的方式来优化分支的路由条目，为了便于观察结果，在R3和R4上分别再开启一个回环口，并在EIGRP中通告 123456789R3(config)#int loopback 2R3(config-if)#ip address 172.16.33.1 255.255.255.0R3(config)#router eigrp 110R3(config-router)#network 172.16.33.0 0.0.0.255R4(config)#int loopback 2R4(config-if)#ip add 172.16.44.1 255.255.255.0R4(config)#router eigrp 110R4(config-router)#network 172.16.44.0 0.0.0.255 查看R3和R4的路由表，都学习到了相应的路由条目 在R1的tunnel接口进行路由汇总 12R1(config)#int tunnel 1R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16 再次查看R3和R4的路由表，此时学习到的是经过R1汇总的路由 3、phase-2验证 所有站点都采用mGRE，分支的流量可以无需经过hub，不能在hub端对路由进行汇总；eigrp环境，需要关闭下一跳规则——no ip next-hop-self eigrp，缺点所有的分支都需要维护整个网络的所有路由信息。 在phase1的基础上，将R3、R4的隧道模式改为multipoint 1234567R3(config)#int tunnel 1R3(config-if)#no tunnel destination 202.101.12.1R3(config-if)#tunnel mode gre multipoint R4(config)#int tunnel 1R4(config-if)#no tunnel destination 202.101.12.1R4(config-if)#tunnel mode gre multipoint 在R3上使用traceroute跟踪路由，可知去往172.16.4.1仍然要经过hub 查看R3的路由表，可知去往172.16.4.0/24网段的路由的下一跳为hub 【注】此时并未在R1的隧道接口汇总路由 出现上述问题的原因在于EIGRP路由在传递的时候会将下一跳改为自己，将R1的tunnel接口将该属性关闭 12R1(config)#int tunnel 1R1(config-if)#no ip next-hop-self eigrp 110 此时查看R3的路由表可知去往172.16.4.0/24网段的路由的下一跳变为R4 在R3上再次跟踪路由，如下图所示，可知此时R3直接通过R4访问172.16.4.1，无需再经过hub 4、phase-3验证 在阶段三引入了shortcut（短路）和redirect（重定向） 在R1上开启redirect，在R3和R4上开启shortcut 12345678R1(config)#int tunnel 1R1(config-if)#ip nhrp redirect R3(config)#int tunnel 1R3(config-if)#ip nhrp shortcut R4(config)#int tunnel 1R4(config-if)#ip nhrp shortcut 在R1上将下一跳属性和水平分割恢复 123R1(config)#int tunnel 1R1(config-if)#ip next-hop-self eigrp 110R1(config-if)#ip split-horizon eigrp 110 此时R3和R4的路由表还是无法学习到其他站点的路由条目 为了验证实验结果，此时在R3启用多个回环口，并在eigrp中通告 1234567891011R3(config)#int loopback 3R3(config-if)#ip add 192.168.3.1 255.255.255.0R3(config)#int loopback 4R3(config-if)#ip add 192.168.4.1 255.255.255.0R3(config)#int loopback 5R3(config-if)#ip add 192.168.5.1 255.255.255.0R3(config)#router eigrp 110R3(config-router)#network 192.168.3.0R3(config-router)#network 192.168.4.0R3(config-router)#network 192.168.5.0 在R1上进行路由汇总 123R1(config)#int tunnel 1R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16R1(config-if)#ip summary-address eigrp 110 192.168.0.0/16 再次查看R3和R4的路由表，此时学习到的为经过R1汇总的条目，并且下一跳都指向R1 在R4上跟踪到达172.16.3.1所经过的路径，可知需经过R1 查看R4的路由表，此时出现了”H”的路由条目 此时再次使用traceroute跟踪172.16.3.1，则无需再经过R1 再次进行验证，使用traceroute命令跟踪到达192.168.3.1所经过的路径，首次traceroute需要经过R1 查看R4的路由表，此时通过NHRP学习到了更详细的路由去往192.168.3.0/24网段，下一跳为10.1.1.3 再次使用traceroute跟踪路径，则无需再经过R1 5、总结","categories":[],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://shain.top/tags/VPN/"}]},{"title":"STP的运用","slug":"STP的运用","date":"2020-08-31T14:57:13.000Z","updated":"2020-08-31T16:00:08.291Z","comments":true,"path":"2020/08/31/STP的运用/","link":"","permalink":"http://shain.top/2020/08/31/STP%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"1、实验目的1）理解STP的作用2）熟悉STP的工作原理3）掌握STP的查看命令","text":"1、实验目的1）理解STP的作用2）熟悉STP的工作原理3）掌握STP的查看命令 2、拓扑结构 3、实验步骤（1）在相应的交换机上创建vlan10，并将连接PC1和PC2的交换端口都划分进该vlan中 （2）为主机设置合适的IP地址，IP地址自定，完成必要的配置实现主机间的通信 为两台PC配置IP地址（注意关闭路由功能，因为实验中的PC使用的是路由器的镜像） 将交换机之间的端口封装802.1Q，并配置成trunk 测试PC的连通性 由于PC1和PC2属于同一vlan，所以通过上述配置即可相互ping通 （3）查看各交换机的STP信息 （4）将SW1设置为vlan10的根桥，使用相关命令验证和查看各交换机上根桥的变化 设置SW1为vlan10的根桥 使用show spanning-tree命令查看交换机状态 由于设置SW1为vlan10的根桥，由下图可知，优先级默认降低2*4096，即为24576，加上vlan-id的10，所以优先级为24586 （5）测试正常链路出现故障对主机通信的影响 将SW2的e0/1接口shutdown PC1仍然可以ping通PC2 （6）先断开PC1与交换机的连接，然后恢复PC1与交换机的连接，观察主机重新接入交换机要经历多久才能够进行数据转发 由下图可知，PC1重新接入交换机需要经历30s（由于关闭的是SW2上的端口，可以直接进入listening状态（无需经历20s的blocking状态），再经历15s进入learning状态，最后经历15s进入forwarding状态）","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"},{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"}]},{"title":"单臂路由运用","slug":"单臂路由运用","date":"2020-08-30T15:03:42.000Z","updated":"2020-09-05T08:11:17.808Z","comments":true,"path":"2020/08/30/单臂路由运用/","link":"","permalink":"http://shain.top/2020/08/30/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E8%BF%90%E7%94%A8/","excerpt":"1、实验目的1）掌握交换机上VLAN的创建和划分2）掌握trunk的作用3）掌握VTP的作用与配置4）掌握单臂路由原理与配置5）理解trunk链路上的802.1Q标记的作用","text":"1、实验目的1）掌握交换机上VLAN的创建和划分2）掌握trunk的作用3）掌握VTP的作用与配置4）掌握单臂路由原理与配置5）理解trunk链路上的802.1Q标记的作用 2、拓扑结构 3、实验步骤（1）在SW1上创建两个vlan，vlan10和vlan20，并将vlan10命名为sales，将vlan20命名为engineers （2）完成必要的配置，实现两交换机的vlan数据库同步，并使用相关命令验证和查看vlan数据库的信息 要实现两交换机的vlan数据库同步，需要进行vtp的配置 将两交换机相连的端口设置为trunk 指定vtp的域和密码，并指定SW1的vtp模式为server，SW2的vtp模式为client 在SW2上查看vlna信息，此前并未在SW2上创建vlan，由此可知两交换机之间实现了vlan数据库的同步 尝试在SW2上创建一个vlan，日志提示在vtp的模式为client的条件下不允许创建vlan 在SW1上查看vtp的状态信息，从下图可知SW1的vtp模式为server（默认），已存在的vlan数量为7，修订版本号为8 （3）将连接PC1和PC3的交换端口划分进vlan10，将连接PC2的交换端口划分进vlan20中，并为各PC配置合适的IP地址和网关 依题意将交换机上的端口划分进对应的vlan 由于各PC为使用路由器镜像模拟，需在PC上关闭路由功能。按下图所示为各PC配置IP地址和网关 （4）使用show vlan brief查看各交换机的vlan信息 （5）测试各主机之间的连通性 PC1和PC3之间可以相互ping通（两PC属于同一vlan，无需经过三层设备） PC1和PC2之间无法通信（两PC属于不同vlan，需要经过三层设备，此时还未在路由器上进行相应的配置） （6）在交换机和路由器上完成必要的配置，实现各主机间可以互相通信 将SW1上连路由器的端口配置成trunk 、 在R1上进行单臂路由的配置 单臂路由是指在路由器的一个接口上通过配置子接口(或”逻辑接口”，并不真实存在)的方式，实现原来相互隔离的不同vlan之间的互联互通 值得注意的是这些逻辑子接口不能被单独的开启或关闭，即当物理接口被开启或关闭时，所有的该物理接口的子接口也将对应的被开启或关闭 由于单臂路由存在瓶颈和单点故障的问题，因此必须限制主机/vlan的数量。此时可以通过SVI实现不同vlan间的通信（后续会进行介绍） 测试各主机之间的连通性，如下图所示，三台PC之间可以互相ping通","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"单臂路由","slug":"单臂路由","permalink":"http://shain.top/tags/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/"},{"name":"vtp","slug":"vtp","permalink":"http://shain.top/tags/vtp/"}]},{"title":"单区域OSPF的实现","slug":"单区域OSPF的实现","date":"2020-08-29T14:56:59.000Z","updated":"2020-09-05T08:11:40.073Z","comments":true,"path":"2020/08/29/单区域OSPF的实现/","link":"","permalink":"http://shain.top/2020/08/29/%E5%8D%95%E5%8C%BA%E5%9F%9FOSPF%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"1、实验目的1）掌握OSPF的基本配置2）掌握OSPF的邻居表、拓扑表及路由表的含义3）掌握OSPF的DR和BDR的作用4）掌握OSPF的DR和BDR的选举5）查看和调试OSPF路由协议的相关信息6）熟悉OSPF中hello报文的作用和格式","text":"1、实验目的1）掌握OSPF的基本配置2）掌握OSPF的邻居表、拓扑表及路由表的含义3）掌握OSPF的DR和BDR的作用4）掌握OSPF的DR和BDR的选举5）查看和调试OSPF路由协议的相关信息6）熟悉OSPF中hello报文的作用和格式 2、拓扑结构 3、实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划 各接口地址如拓扑图标记所示进行配置 （2）全网启用OSPF，并划分如区域0 距离矢量为通告 链路状态为使能 network表示的是划分一个范围，路由器上属于此范围的对应接口加入OSPF的相应进程的相应区域 如network 192.168.12.0 0.0.0.255 area 0 表示的是划分一个范围为192.168.12.0，看此路由器上的哪个接口在这个范围内，则这个接口就会被加入OSPF的区域0中 （3）观察各路由器的邻居表、拓扑表及路由表，观察哪些链路上有进行DR/BDR的选举，并测试主机之间的连通性 优先级用于选举DR/BDR——以太网链路存在DR/BDR的选举，串行链路则没有 选举规则： 先比较优先级，优先级大的优先；默认情况下以太网接口的优先级都为1，串行链路的接口优先级都为0（优先级为0不能参与DR/BDR的选举） 如果优先级都一样，继续比较RID，RID大的优先 DR的选举是非抢占的 Hello报文 作用：用来发现、建立、维持邻居之间的关系 每隔10s往224.0.0.5发送Hello报文，如果在40之后没有收到来自邻居的Hello，则认为该邻居挂了，就切断和该邻居之间的关系（死亡时间通常在30-39之间） -————————————————————————————————————————– Neighbor ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pri &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State &nbsp;&nbsp;&nbsp;Dead Time &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface &nbsp;&nbsp;&nbsp;邻居的ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级 &nbsp;&nbsp;状态 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;死亡时间 &nbsp;&nbsp;&nbsp;&nbsp;邻居的IP地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己用于建立邻居的接口 -————————————————————————————————————————– 邻居表 拓扑表 路由表 连通性测试 （4）指定R2的RID为20.20.20.20，R3的RID为30.30.30.30，使用相关命令观察和验证各路由器RID的变化 【RID的选举】 手工指定：最优先 R2(config)#router ospf 1 R2(config-router)#router-id 20.20.20.20 –手动指定RID Reload or use “clear ip ospf process” command, for this to take effect R2#clear ip ospf process –重置OSPF的进程 Reset ALL OSPF processes? [no]: y 自动选择：在没有手工指定情况下，优先选择回环口中IP地址最大的；若没有回环口，选择物理接口（双UP）中IP地址最大。 查看当前R2和R3的RID，由于没有手工指定，也没有存在回环口，则选择物理接口中IP地址最大的作为RID 指定R2和R3路由器的RID 再次查看R2和R3的RID （5）实现R2为以太网链路网段上的DR 由于R1和R2的优先级默认都为1，并且R2的RID为20.20.20.20，而R1的RID为192.168.12.1，此时需要修改R2的e0/0接口的优先级，使之成为以太网链路上的DR。此处指定R2上e0/0接口的优先级为2即可 由于DR、BDR的选举为非抢占，此时应重置OSPF进程 查看R1和R2的邻居表，可知此时R2成为以太网链路上的DR （6）分别在R2和R3的路由器上添加172.16.2.0/24和172.16.3.0/24的网段，添加必要配置实现这两个网络之间的连通性 由于R3上已存在172.16.3.0/24网段，此时在R2上添加一个回环口（地址为172.16.2.2/24）用作测试 123R2(config)#interface loopback 1R2(config-if)#ip address 172.16.2.2 255.255.255.0R2(config-if)#ip ospf 1 area 0 --把该接口加入到OSPF进程1区域0中 （7）开启debug信息，观察OSPF在以太网链路之间信息交互的过程 （8）开启debug信息，观察OSPF在串行链路之间信息交互的过程，比较以太网链路和串行链路上OSPF的debug信息输出的区别 最主要区别在于以太网链路会进行DR/BDR的选举；串行链路则没有进行DR/BDR的选举 以太网链路中，路由信息会先被发送到组播地址224.0.0.6，即被DR/BDR所接收，再由DR将此信息发送到组播地址224.0.0.5 （9）使用wireshark抓取OSPF的hello报文，理解hello报文各字段的含义 hello报文用于邻居的发现，建立和维持 hello报文中的相关信息包括： Network Mask：发送hello报文的接口所在网络的掩码 Hello Interval（默认为10s）：发送hello报文的时间间隔 Options：可选项 E：允许Flood AS-External-LSAs MC：转发IP组播报文 N/P：处理Type-7 LSAs DC：处理按需链路 Router Priority：优先级，默认为1，如果设置为0，则不参与DR或BDR的选举 Router Dead Interval（默认40s）：失效时间，如果在此时间内未收到邻居发送的hello报文，则认为邻居失效 Designated Router：DR的接口地址 Backup Designated Router：BDR的接口地址 Active Neighbor：活跃的邻居，以RID标识","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"}]},{"title":"EIGRP的简单应用","slug":"EIGRP的简单应用","date":"2020-08-28T15:34:08.000Z","updated":"2020-09-05T08:12:14.315Z","comments":true,"path":"2020/08/28/EIGRP的简单应用/","link":"","permalink":"http://shain.top/2020/08/28/EIGRP%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/","excerpt":"1、实验目的1）掌握EIGRP的基本配置2）理解EIGRP的邻居表、拓扑表以及路由表的含义3）掌握查看EIGRP路由协议的相关信息4）掌握FD、AD、S、FS以及FC的含义5）理解EIGRP的hello报文作用6）理解路由快速收敛的含义7）理解EIGRP的不等价负载均衡","text":"1、实验目的1）掌握EIGRP的基本配置2）理解EIGRP的邻居表、拓扑表以及路由表的含义3）掌握查看EIGRP路由协议的相关信息4）掌握FD、AD、S、FS以及FC的含义5）理解EIGRP的hello报文作用6）理解路由快速收敛的含义7）理解EIGRP的不等价负载均衡 2、实验拓扑 3、实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，要求PC1的IP地址设置为172.16.1.1/24，网关设置为172.16.1.254，PC2的IP地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划 IP地址规划如拓扑图标记所示，此处不再列出 （2）全网启用EIGRP，通告各自的直连网络路由，并关闭自动汇总 1234567//启用EIGRP进程，AS号为90，AS号是邻居建立的前提，邻居要建立AS号必须要一样R3(config)#router eigrp 90 //关闭自动汇总R3(config-router)#no auto-summary //通告网段R3(config-router)#network 192.168.23.0 //通告直连网段R3(config-router)#network 172.16.3.0 0.0.0.255 （3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息 Metric weight K1=1, K2=0, K3=1, K4=0, K5=0 – EIGRP的开销计算与这5个K值有关系 邻居要建立，则五个K值必须相同 K1：带宽；K2：负载；K3：延迟；K4：可靠性；K5：MTU 真正与EIGRP开销计算有关系的，只有带宽和延迟； EIGRP开销=带宽+延迟 （4）查看各路由器的邻居表、拓扑表以及路由表，分别找出FD、AD以及S等重要信息 邻居表各字段含义 H：建立顺序 Address：对端的IP Interface：从哪个接口学习到 Hold：定义了等待没有从邻居那里接收到任何包的最大时间，当接收到新的包以后，Hold复位（在10~15s之间循环） Uptime：建立了多久 SRTT：向邻居发送包以及受到邻居回应ACK的平均回程时间 RTO：重传超时时间，路由器在重新传输包之前等待ACK的时间（应为SRTT的6倍，最大5000，若重传16次还未得到确认，则此邻居被宣布无效） Q：队列计数，表示有多少个可靠报文还没有得到确认，在运行正常的环境下该值应为0（如果值大于0则说明发生了拥塞） Seq：序列号 拓扑表 路由表 （5）测试PC1与PC2之间的连通性 （6）在R2上添加一个loopback1接口，地址为200.200.200.200/24，然后在EIGRP中通告，观察R1和R3是否能马上学习到R2上新增的loopback1网段，并测试各主机与该loopback1之间的联通性 R1和R3能马上学习到R2上新增的loopback1网段 （7）使用wireshark抓取EIGRP的报文，理解EIGRP报文各字段的含义 每隔5s发送一个hello包，保持时间为15s，即超过3个hello时间未收到hello则认为对端Down，断开连接 （8）在R1上添加一个loopback1接口，地址为100.100.100.100/24，然后在EIGRP中通告 （9）断开R1和R3与各主机之间的连接，连接R1与R3之间的以太网接口，完成必要配置，实现200.200.200.200访问100.100.100.100的不等价负载均衡 123//使用源200.200.200.200去访问目标100.100.100.100//若没有跟上source，那么默认情况下就是使用出接口去访问目标R2#ping 100.100.100.100 source 200.200.200.200 由于此时R2的路由表中只存在一条路径到达100.100.100.100，所以此时不存在负载均衡 等价负载均衡：有多条开销相等的路径，此时可以同时从这些开销相等的路径去发送数量相同的数据包。 不等价负载均衡：有多条路径，但是开销不一样，此时会根据一定的比例去发送数据包。 对于EIGRP，默认情况下只支持等价负载均衡，并且默认情况下最多可以同时存在4条的等价负载均衡。 R2(config)#router eigrp 90 R2(config-router)#maximum-paths 8 –将等价负载均衡的条数改为8条 EIGRP还可以支持不等价负载均衡，但是有前提： ①次优路径的AD值要小于最优路径的FD值–称为FC条件，只有满足了该条件，才会存在FS。 ②当存在FS之后，EIGRP拓扑表会存在两个下一跳，但是只会选择最优的添加进路由表。此时如果要保证路由表也有两条路径，必须手动修改V值(variance)，使得满足”最优路径的FD*V值&gt;次优路径的FD值”（默认情况下，v值为1） 此题中，最优路径为R2通过R1到达100.100.100.100，次优路径为经过R3、R1到达100.100.100.100 查看R2的路由表，此时显示的为最优路径，FD=409600 次优路径的AD即为R3到达100.100.100.100的开销（FD），也为409600 此时不满足FC条件，则需更改开销，修改K值，更改R2的e0/0接口的延迟为3000（默认为1000），注意倍数关系 将修改延迟的接口关闭再打开 此时满足FC条件，即次优路径的AD值小于最优路径的FD值，在拓扑表中存在两条路径 此时的FS为R3 但是此时路由表中到达100.100.100.100仍然只存在一条最优路径 若想让次优路径加表，则需满足：最优路径的FD*v值 &gt; 次优路径的FD才能加入到路由表 修改V值为6，此时满足条件，路由表中到达100.100.100.0网段存在两个下一跳 查看该路由的详细信息，可知基本满足1:5的关系 1234567相关命令R2(config)#int e0&#x2F;0R2(config-if)#delay n --修改延迟，但是注意，如果输入的是n，那么延迟会改为10*nR2(config-if)#bandwidth n --修改带宽，如果输入的是n，那么带宽就为nR2#show interfaces e0&#x2F;0 --看接口的详细信息，比如说带宽、延迟R2#show ip route 100.100.100.0 255.255.255.0 --查看该路由的详细信息","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"EIGRP","slug":"EIGRP","permalink":"http://shain.top/tags/EIGRP/"}]},{"title":"RIP的应用","slug":"RIP的应用","date":"2020-08-27T13:39:13.000Z","updated":"2020-09-05T08:12:33.705Z","comments":true,"path":"2020/08/27/RIP的应用/","link":"","permalink":"http://shain.top/2020/08/27/RIP%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"1、 实验目的 掌握RIPv2的基本配置 理解RIPv2路由条目的结构含义 理解自动汇总的含义 理解和观察周期性更新 理解debug ip rip 命令 的作用","text":"1、 实验目的 掌握RIPv2的基本配置 理解RIPv2路由条目的结构含义 理解自动汇总的含义 理解和观察周期性更新 理解debug ip rip 命令 的作用 2、 拓扑结构 3、 实验步骤（1）完成各路由器的基本配置，实现各直连设备之间可以互 ping 对方， 要求 PC1 的 IP 地址设置为 172.16.1.1/24，网关设置为172.16.1.254， PC2 的 IP 地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划。 （2）在三台路由器上都启用RIPv2协议，通告各自的直连网络路由，并开启自动汇总 1默认开启自动汇总，会在边界处把一个网段汇总成主类 （3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息 路由更新计时器：30s（默认）路由无效时间：180s（默认）抑制计时器：180s（默认）路由刷新计时器：240s（默认） （4）查看各路由器的路由表，观察RIP路由条目的特征 由于没有关闭自动汇总，R1上存在172.16.0.0网段的路由，则不会再学习R2上的172.16.0.0的路由 同理，R2上存在172.16.0.0网段的路由，则不会学习R1上的172.16.0.0的路由 （5）分别在R2和PC2上测试R2与PC1以及PC2与PC1之间的连通性 （6）在R2上使用debug ip rip观察路由的发送情况 RIPv2组播地址：224.0.0.9 由于没有关闭自动汇总，此时发送的报文都为主类路由 （7）在三台路由器上都关闭自动汇总，观察各路由表的变化，并再次测试R2与PC1以及PC2与PC1之间的连通性 （8）再次在R2上使用debug ip rip观察路由的发送情况，比较关闭自动汇总与开启自动汇总debug输出信息的不同 （9）在R2上添加一个loopback1接口，地址自定 （10）添加必要配置，实现PC1和PC2都能够正常访问在R2上的loopback1 （11）在R1上添加一个loopback1接口，地址自定，然后在RIP中通告，观察R2和R3是否能马上学习到R1上新增的loopback1网段 由于rip的路由表的更新时间为30s，故在R2、R3上无法马上学习到在R1上新增的loopback1网段 （12）将R1上的loopback1接口关闭，观察R2和R3上是否还存在关于R1上的loopback1网段的路由条目 由于触发更新，R1上存在失效路由，则会马上发送更新给相邻的路由器，让他们将失效路由删除 （13）使用wireshark抓取RIPv2报文，理解RIPv2报文各字段的含义 RIPv2运行在UDP的520端口上，属于应用层协议","categories":[{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"RIP","slug":"RIP","permalink":"http://shain.top/tags/RIP/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-26T05:18:32.000Z","updated":"2020-09-14T09:37:22.485Z","comments":true,"path":"2020/08/26/hello-world/","link":"","permalink":"http://shain.top/2020/08/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"http://shain.top/categories/Hello-World/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://shain.top/tags/hello-world/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://shain.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验","slug":"实验","permalink":"http://shain.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://shain.top/categories/Hello-World/"}],"tags":[{"name":"STP","slug":"STP","permalink":"http://shain.top/tags/STP/"},{"name":"VTP","slug":"VTP","permalink":"http://shain.top/tags/VTP/"},{"name":"DHCP","slug":"DHCP","permalink":"http://shain.top/tags/DHCP/"},{"name":"EtherChannel","slug":"EtherChannel","permalink":"http://shain.top/tags/EtherChannel/"},{"name":"交换","slug":"交换","permalink":"http://shain.top/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"SVI","slug":"SVI","permalink":"http://shain.top/tags/SVI/"},{"name":"CCNA","slug":"CCNA","permalink":"http://shain.top/tags/CCNA/"},{"name":"NAT","slug":"NAT","permalink":"http://shain.top/tags/NAT/"},{"name":"PPP","slug":"PPP","permalink":"http://shain.top/tags/PPP/"},{"name":"ACL","slug":"ACL","permalink":"http://shain.top/tags/ACL/"},{"name":"VPN","slug":"VPN","permalink":"http://shain.top/tags/VPN/"},{"name":"单臂路由","slug":"单臂路由","permalink":"http://shain.top/tags/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/"},{"name":"vtp","slug":"vtp","permalink":"http://shain.top/tags/vtp/"},{"name":"路由协议","slug":"路由协议","permalink":"http://shain.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"OSPF","slug":"OSPF","permalink":"http://shain.top/tags/OSPF/"},{"name":"EIGRP","slug":"EIGRP","permalink":"http://shain.top/tags/EIGRP/"},{"name":"RIP","slug":"RIP","permalink":"http://shain.top/tags/RIP/"},{"name":"hello world","slug":"hello-world","permalink":"http://shain.top/tags/hello-world/"}]}
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACL的运用</title>
    <url>/2020/09/01/ACL%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h3><p>1）掌握ACL的作用<br>2）理解标准和扩展ACL的区别<br>3）熟悉标准和扩展ACL的配置<br>4）掌握ACL的验证和查看命令<br>5）理解命名的ACL的作用与配置</p>
<a id="more"></a>
<h3 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h3><p><img src="https://s1.ax1x.com/2020/09/01/dz9FzR.png"></p>
<h3 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h3><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划</strong></p>
<blockquote>
<p>两台PC及三台路由器的IP地址配置如拓扑图所示，此处不再将图贴出</p>
</blockquote>
<p><strong>（2）在R2上添加两个loopback接口，loopback1和loopback2，其中loopback1地址为2.2.2.2/24，loopback2地址为22.22.22.22/24</strong></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCFAS.png"></p>
<p><strong>（3）完成必要的配置实现全网可达</strong></p>
<blockquote>
<p>在路由器上运行路由协议，实现全网可达</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCVpj.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCecn.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCKBV.png"></p>
<p><strong>（4）使用标准ACL实现PC1不能访问PC2，并使用ping命令验证结果</strong></p>
<blockquote>
<p>标准ACL建议在离目标近的设备上配置，在R3上配置ACL拒绝来自主机172.16.1.1的流量，并在进接口方向调用，此时实现PC1不能访问PC2</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCT3j.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCHvn.png"></p>
<p><strong>（5）使用标准ACL实现只允许PC2远程登录到路由器R2，并使用telnet命令验证结果</strong></p>
<blockquote>
<p>在R2上配置ACL，允许主机172.16.3.1的流量，默认隐含一条拒绝所有，即拒绝除PC2之外的流量。在vty中允许其他设备使用telnet远程登录，并在in方向调用ACL</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzPGa8.png"></p>
<blockquote>
<p>在PC1和PC2上进行测试，此时实现了只允许PC2远程登录到R2</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dziPJg.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dziVLq.png"></p>
<p><strong>（6）使用标准ACL实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制</strong></p>
<blockquote>
<p>在R1上配置ACL，允许loopback1网段，拒绝loopback2网段，然后在e0/1接口的in方向调用</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzizc9.png"></p>
<blockquote>
<p>此时实现了R2上的loopback1网段可以访问PC1，而loopback2网段不能</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzFtjs.png"></p>
<p><strong>（7）使用命名ACL完整上述标准ACL的需求</strong></p>
<ul>
<li>实现PC1不能访问PC2</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzecvD.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzeoPP.png"></p>
<ul>
<li>实现只允许PC2远程登录到路由器R2</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dznifP.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dznAl8.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dznVOg.png"></p>
<ul>
<li>实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuCB4.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuPHJ.png"></p>
<p><strong>（8）使用扩展ACL实现禁止PC1远程登录到R2，对其他访问不做限制</strong></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzu34I.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzu1UA.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzulEd.png"></p>
<p><strong>（9）使用扩展ACL实现PC2可以telnet到路由器R1，但不能ping通路由器R1，分别使用ping和telnet验证结果</strong></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuOqe.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuLrD.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuHxK.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuqKO.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzu726.png"></p>
<p><strong>（10）使用扩展ACL实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果</strong></p>
<blockquote>
<p>ICMP</p>
<ul>
<li><p>echo request    –echo的请求包</p>
</li>
<li><p>echo reply         –echo的响应包</p>
</li>
</ul>
<p>只有以上两种报文是正常的，那么此时的ping才是能通的</p>
<p>PC1 ping PC2 正常</p>
<ul>
<li><p>PC1 给 PC2 发送的echo request是正常的（源是PC1，目标是PC2）</p>
</li>
<li><p>PC2给PC1发送的echo reply也是正常的（源是PC2，目标是PC1）</p>
</li>
</ul>
<p>PC2 ping PC1 不正常</p>
<ul>
<li><p>PC2不能给PC1发送 echo request（源是PC2，目的是PC1）</p>
</li>
<li><p>PC2不能接收到来自PC1的echo  reply（源是PC1，目的是PC2）</p>
</li>
</ul>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzKOS0.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzKqWq.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzKbYn.png"></p>
<p><strong>（11）使用命名ACL完成上述扩展ACL的需求</strong></p>
<ul>
<li>实现禁止PC1远程登录到R2，对其他访问不做限制</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQCDS.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQPHg.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQ9u8.png"></p>
<ul>
<li>实现PC2可以telnet到路由器R1，但不能ping路由器R1，分别使用ping和telnet验证结果</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQKDU.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQuuT.png"></p>
<ul>
<li>实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果</li>
</ul>
<p><span style="color:red">方法一：拒绝PC2向PC1发送icmp的echo-request报文</span></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQWqS.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQRr8.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQ2Kf.png"></p>
<p><span style="color:red">方法二：拒绝PC1向PC2发送icmp的echo-reply报文</span></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzl1L8.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzllsf.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzlQQP.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>ACL</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT和PPP的应用</title>
    <url>/2020/09/02/NAT%E5%92%8CPPP%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h3><p>1）理解NAT的作用<br>2）理解不同NAT的特点及配置<br>3）理解不同NAT的使用场合<br>4）掌握PPP的PAP和CHAP验证<br>5）理解辅助地址的作用<br>6）掌握NAT的验证和查看命令</p>
<a id="more"></a>
<h3 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h3><p><img src="https://s1.ax1x.com/2020/09/02/w9dK7d.png"></p>
<h3 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h3><p><strong>（1）公司COM1和COM2内部网段都为192.168.1.0/24，其中COM1的SRV地址为192.168.1.100/24，COM2的user地址为192.168.1.10/24，COM1内部的其他主机地址自己规划；ISP上的Web_Server地址为211.1.1.1/24，ISP与COM2之间的地址段为202.101.12.0/24，ISP与COM1之间的地址段为202.101.23.0/24，其中COM2连接ISP的接口地址为202.101.12.1/24，COM1连接ISP的接口地址为202.101.23.3/24</strong></p>
<blockquote>
<p>IP地址规划如拓扑图所示</p>
</blockquote>
<p><strong>（2）要求COM1与ISP之间的PPP链路采用CHAP验证，用户名为20164120，密码为123456</strong></p>
<ul>
<li>在ISP的s2/0封装PPP，并指定PPP的认证方式为CHAP，指定对方的IP地址为202.101.23.3</li>
<li>在全局下设置用户名和密码，用于chap验证</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wMKU.png"></p>
<ul>
<li>在COM1上s2/0接口封装PPP，指定IP地址为通过协商获取，填写用户名和密码，并让ISP下发默认路由</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wuvT.png"></p>
<ul>
<li>查看COM1上的IP地址，可知s2/0接口的IP地址为通过IPCP方式获得</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wm80.png"></p>
<ul>
<li>查看COM1的路由表中的静态路由条目，可知存在一条默认路由</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wn2V.png"></p>
<p><strong>（3）在COM1上使用静态NAT实现SRV可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试</strong></p>
<ul>
<li>在COM1上启用一个loopback接口，用于静态nat的一对一映射</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90HTH.png"></p>
<ul>
<li>配置静态nat，将SRV的IP地址192.168.1.100映射到COM1上的loopback接口的地址</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90qkd.png"></p>
<ul>
<li>在ISP上配置静态路由，实现ISP可以访问COM1上的loopback接口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90jpt.png"></p>
<ul>
<li>在COM1上配置内部接口和外部接口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90LtA.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/02/w90OfI.png"></p>
<ul>
<li>此时SRV可以访问ISP上的Web_Server</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90v1P.png"></p>
<ul>
<li>在COM1上查看nat转换表，可知将192.168.1.100转换成200.100.1.1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90x6f.png"></p>
<ul>
<li>由于采用静态NAT，所以此时Web_Server也可以通过200.100.1.1访问SRV</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90zX8.png"></p>
<ul>
<li>在Web_Server上使用telnet命令远程登录到200.100.1.1，由下图可知此时登录到的设备为SRV</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9BpnS.png"></p>
<p><strong>（4）在COM1上使用复用地址池的方式实现COM1内的所有用户可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试</strong></p>
<ul>
<li>在COM1上配置地址池，范围为202.101.23.10~202.101.23.12，掩码为/24</li>
<li>配置ACL，匹配192.168.1.0/24网段的流量</li>
<li>配置复用地址池NAT</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9siAe.png"></p>
<ul>
<li>此时各PC可以访问Web_Server</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9s90O.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w9sC7D.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w9spnK.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w9rzX6.png"></p>
<ul>
<li>在COM1上查看nat转换表，地址在COM1上执行了地址转换</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9sFtH.png"></p>
<ul>
<li>使用debug ip nat命令查看地址转换信息</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9skhd.png"></p>
<p><strong>（5）在COM1和COM2上使用PAT方式实现COM1和COM2内部的用户都可以访问ISP上的Web_Server</strong></p>
<ul>
<li>由于COM1上已存在ACL 1匹配192.168.1.0/24网段的流量，所以此时可以直接在COM1上配置端口复用NAT</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96EOP.png"></p>
<ul>
<li>测试COM1内部的用户与Web_Server的连通性</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96Ayt.png"></p>
<ul>
<li>查看地址转换表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96Zef.png"></p>
<ul>
<li>在COM2上配置默认路由，下一跳指向ISP的e0/0接口的地址202.101.12.2，确保COM2可以访问Web_Server</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96ew8.png"></p>
<ul>
<li>在COM2上使用命名的标准ACL匹配192.168.1.0/24网段的流量</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96kQI.png"></p>
<ul>
<li>配置PAT</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96mTS.png"></p>
<ul>
<li>指定内外部接口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w960p9.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w96aY4.png"></p>
<ul>
<li>测试COM2内部用户与Web_Server的连通性</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96dfJ.png"></p>
<ul>
<li>在COM2上查看nat转换表，可知内部用户192.168.1.10在访问外部网络时将地址转换成了202.101.12.1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96UkF.png"></p>
<p><strong>（6）实现COM2内部的COM2_USER可以远程登录到SRV</strong></p>
<ul>
<li>在COM1上配置静态nat，将SRV的地址192.168.1.100的tcp23号端口静态映射成200.100.1.1的5656号端口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/wC9w6J.png"></p>
<ul>
<li>在COM2_USER上使用telnet命令远程登录到SRV，此时应注意加上端口号</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/wC9dl4.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>NAT</tag>
        <tag>PPP</tag>
      </tags>
  </entry>
  <entry>
    <title>DMVPN验证</title>
    <url>/2020/09/01/DMVPN%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>DMVPN三个阶段</p>
<ul>
<li>阶段一：中心到节点的设计（Hub-to-Spoke Design）</li>
<li>阶段二：节点到节点的设计（Spoke-to-Spoke Design）</li>
<li>阶段三：分层（基于树的）设计（Hierachical [Tree-Based] Design）</li>
</ul>
<p>本文将从三个阶段对DMVPN进行验证</p>
<a id="more"></a>

<h3 id="1、拓扑结构"><a href="#1、拓扑结构" class="headerlink" title="1、拓扑结构"></a>1、拓扑结构</h3><p><img src="https://s1.ax1x.com/2020/09/01/dxEvT0.png"></p>
<p>在进行验证之前，确保R1、R3、R4存在默认路由，使得三台路由器之间可以相互ping通</p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxulw9.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxu8F1.png"></p>
<h3 id="2、phase-1验证"><a href="#2、phase-1验证" class="headerlink" title="2、phase-1验证"></a>2、phase-1验证</h3><blockquote>
<p>hub端是mGRE，分支端是常规的GRE，分支之间的流量必须经过hub，可以采取关闭水平分割来实现分支之间的路由互相学习，可以在hub端进行手工的路由汇总，来优化分支的路由条目</p>
</blockquote>
<ul>
<li>hub配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip address 10.1.1.1 255.255.255.0    //隧道地址</span><br><span class="line">R1(config-if)#tunnel source 202.101.12.1    //指定隧道源地址(隧道目的地址可通过nhrp解析)</span><br><span class="line">R1(config-if)#tunnel mode gre multipoin    //R1为hub，所以指定gre隧道模式为multipoint</span><br><span class="line">R1(config-if)#tunnel key 100000    //指定隧道的key，可用于隧道的身份验证</span><br><span class="line">R1(config-if)#ip nhrp network-id 12345    //指定nhrp的标识，hub和spoke之间的network-id必须一致</span><br><span class="line">R1(config-if)#ip nhrp authentication cisco123    //nhrp身份验证</span><br><span class="line">R1(config-if)#ip nhrp map multicast dynamic    //开启组播映射功能</span><br></pre></td></tr></table></figure>

<ul>
<li>spoke(R3)配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#ip address 10.1.1.3 255.255.255.0</span><br><span class="line">R3(config-if)#tunnel source 202.101.23.3</span><br><span class="line">R3(config-if)#tunnel destination 202.101.12.1</span><br><span class="line">R3(config-if)#tunnel key 100000</span><br><span class="line">R3(config-if)#ip nhrp network-id 12345</span><br><span class="line">R3(config-if)#ip nhrp authentication cisco123 </span><br><span class="line">R3(config-if)#ip nhrp map 10.1.1.1 202.101.12.1    //映射hub的逻辑地址到物理地址</span><br><span class="line">R3(config-if)#ip nhrp map multicast 202.101.12.1    //映射组播信息到hub地址</span><br><span class="line">R3(config-if)#ip nhrp nhs 10.1.1.1    //指定next-hop-server为10.1.1.1</span><br></pre></td></tr></table></figure>

<ul>
<li>R1和R3的隧道地址可以相互ping通</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxKljS.png"></p>
<ul>
<li>在R1上查看地址的映射关系——10.1.1.3映射到的公网地址为202.101.23.3</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxKNhq.png"></p>
<ul>
<li>spoke(R4)配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#ip address 10.1.1.4 255.255.255.0</span><br><span class="line">R4(config-if)#ip nhrp network-id 12345</span><br><span class="line">R4(config-if)#ip nhrp authentication cisco123</span><br><span class="line">R4(config-if)#ip nhrp nhs 10.1.1.1</span><br><span class="line">R4(config-if)#ip nhrp map 10.1.1.1 202.101.12.1</span><br><span class="line">R4(config-if)#ip nhrp map multicast 202.101.12.1</span><br><span class="line">R4(config-if)#tunnel source 202.101.24.4</span><br><span class="line">R4(config-if)#tunnel destination 202.101.12.1</span><br><span class="line">R4(config-if)#tunnel key 100000</span><br></pre></td></tr></table></figure>

<ul>
<li>无需再在R1上配置，即可ping通R4的隧道地址，并且也记录了R4的逻辑地址和物理地址的映射关系</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxMdIA.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxMRaj.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxMWIs.png"></p>
<ul>
<li>分别在R1、R3、R4上各启用一个loopback接口，地址设置如下所示</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int loopback 1</span><br><span class="line">R1(config-if)#ip add 172.16.1.1 255.255.255.0</span><br><span class="line">R3(config)#int loopback 1</span><br><span class="line">R3(config-if)#ip address 172.16.3.1 255.255.255.0</span><br><span class="line">R4(config)#int loopback 1</span><br><span class="line">R4(config-if)#ip add 172.16.4.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<ul>
<li>启用EIGRP协议</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#router eigrp 110</span><br><span class="line">R1(config-router)#no auto-summary </span><br><span class="line">R1(config-router)#network 172.16.1.0 0.0.0.255</span><br><span class="line">R1(config-router)#network 10.1.1.0 0.0.0.255</span><br><span class="line"></span><br><span class="line">R3(config)#router eigrp 110</span><br><span class="line">R3(config-router)#no auto-summary </span><br><span class="line">R3(config-router)#network 172.16.3.0 0.0.0.255</span><br><span class="line">R3(config-router)#network 10.1.1.0 0.0.0.255</span><br><span class="line"></span><br><span class="line">R4(config)#router eigrp 110</span><br><span class="line">R4(config-router)#no auto-summary </span><br><span class="line">R4(config-router)#network 172.16.4.0 0.0.0.255</span><br><span class="line">R4(config-router)#network 10.1.1.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<ul>
<li>在R1上查看EIGRP邻居表，可知R1通过1个隧道接口建立了两个邻居关系</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxQj0g.png"></p>
<ul>
<li>在R1的e0/0接口抓包，报文如下图所示，但是此时的报文都为明文显示，需要进行加密</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxlEBF.png"></p>
<ul>
<li>在R1、R3和R4上配置IPSec，保护隧道上的数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">R1(config)#crypto isakmp policy 10</span><br><span class="line">R1(config-isakmp)#authentication pre-share</span><br><span class="line">R1(config-isakmp)#exit </span><br><span class="line">R1(config)#crypto isakmp key cisco123 address 0.0.0.0</span><br><span class="line">R1(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac </span><br><span class="line">R1(cfg-crypto-trans)#mode transport </span><br><span class="line">R1(cfg-crypto-trans)#exit</span><br><span class="line">R1(config)#crypto ipsec profile dprofile</span><br><span class="line">R1(ipsec-profile)#set transform-set dmvpn</span><br><span class="line">R1(ipsec-profile)#exit</span><br><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#tunnel protection ipsec profile dprofile</span><br><span class="line">*Aug <span class="number">31</span> <span class="number">02</span>:<span class="number">59</span>:<span class="number">34.650</span>: %CRYPTO<span class="number">-6</span>-ISAKMP_ON_OFF: ISAKMP is ON</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">R3(config)#crypto isakmp policy 10</span><br><span class="line">R3(config-isakmp)#authentication pre-share </span><br><span class="line">R3(config-isakmp)#exit</span><br><span class="line">R3(config)#crypto isakmp key cisco123 address 0.0.0.0</span><br><span class="line">R3(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac </span><br><span class="line">R3(cfg-crypto-trans)#mode transport </span><br><span class="line">R3(cfg-crypto-trans)#exit</span><br><span class="line">R3(config)#crypto ipsec profile dprofile</span><br><span class="line">R3(ipsec-profile)#set transform-set dmvpn</span><br><span class="line">R3(ipsec-profile)#exit</span><br><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#tunnel protection ipsec profile dprofile</span><br><span class="line">*Aug <span class="number">31</span> <span class="number">03</span>:<span class="number">02</span>:<span class="number">49.557</span>: %CRYPTO<span class="number">-6</span>-ISAKMP_ON_OFF: ISAKMP is ON</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">R4(config)#crypto isakmp policy 10</span><br><span class="line">R4(config-isakmp)#authentication pre-share </span><br><span class="line">R4(config-isakmp)#exit </span><br><span class="line">R4(config)#crypto isakmp key cisco123 address 0.0.0.0</span><br><span class="line">R4(config)#crypto ipsec transform-set dmvpn  esp-3des esp-sha256-hmac </span><br><span class="line">R4(cfg-crypto-trans)#mode transport </span><br><span class="line">R4(cfg-crypto-trans)#exit</span><br><span class="line">R4(config)#crypto ipsec profile dprofile</span><br><span class="line">R4(ipsec-profile)#set transform-set dmvpn</span><br><span class="line">R4(ipsec-profile)#exit</span><br><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#tunnel protection ipsec profile dprofile</span><br><span class="line">*Aug <span class="number">31</span> <span class="number">03</span>:<span class="number">06</span>:<span class="number">36.128</span>: %CRYPTO<span class="number">-6</span>-ISAKMP_ON_OFF: ISAKMP is ON</span><br></pre></td></tr></table></figure>

<ul>
<li>验证是否进行了加密</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx1KaQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dx1UZF.png"></p>
<ul>
<li>此时R3上的路由表并没有172.16.4.0的路由条目，因为存在水平分割问题</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx1xWn.png"></p>
<ul>
<li>在R1的隧道接口中关闭水平分割</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#no ip split-horizon eigrp 110</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看R3的路由表 ，此时学习到了172.16.4.0的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx31Te.png"></p>
<ul>
<li>跟踪路由，可知分支之间的流量必须经过hub</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx3rkQ.png"></p>
<ul>
<li>可通过在hub上进行路由汇总的方式来优化分支的路由条目，为了便于观察结果，在R3和R4上分别再开启一个回环口，并在EIGRP中通告</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int loopback 2</span><br><span class="line">R3(config-if)#ip address 172.16.33.1 255.255.255.0</span><br><span class="line">R3(config)#router eigrp 110</span><br><span class="line">R3(config-router)#network 172.16.33.0  0.0.0.255</span><br><span class="line"></span><br><span class="line">R4(config)#int loopback 2</span><br><span class="line">R4(config-if)#ip add 172.16.44.1 255.255.255.0</span><br><span class="line">R4(config)#router eigrp 110</span><br><span class="line">R4(config-router)#network 172.16.44.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<ul>
<li>查看R3和R4的路由表，都学习到了相应的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx3HpR.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dx3b11.png"></p>
<ul>
<li>在R1的tunnel接口进行路由汇总</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看R3和R4的路由表，此时学习到的是经过R1汇总的路由</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDFvF.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDEDJ.png"></p>
<h3 id="3、phase-2验证"><a href="#3、phase-2验证" class="headerlink" title="3、phase-2验证"></a>3、phase-2验证</h3><blockquote>
<p>所有站点都采用mGRE，分支的流量可以无需经过hub，不能在hub端对路由进行汇总；eigrp环境，需要关闭下一跳规则——<span style="color:red">no ip next-hop-self eigrp</span>，缺点所有的分支都需要维护整个网络的所有路由信息。</p>
</blockquote>
<ul>
<li>在phase1的基础上，将R3、R4的隧道模式改为multipoint</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#no tunnel destination 202.101.12.1</span><br><span class="line">R3(config-if)#tunnel mode gre multipoint </span><br><span class="line"></span><br><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#no tunnel destination 202.101.12.1</span><br><span class="line">R4(config-if)#tunnel mode gre multipoint </span><br></pre></td></tr></table></figure>

<ul>
<li>在R3上使用traceroute跟踪路由，可知去往172.16.4.1仍然要经过hub</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDDKg.png"></p>
<ul>
<li>查看R3的路由表，可知去往172.16.4.0/24网段的路由的下一跳为hub</li>
</ul>
<blockquote>
<p>【注】<span style="color:red">此时并未在R1的隧道接口汇总路由</span></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDsbj.png"></p>
<ul>
<li>出现上述问题的原因在于EIGRP路由在传递的时候会将下一跳改为自己，将R1的tunnel接口将该属性关闭</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#no ip next-hop-self eigrp 110</span><br></pre></td></tr></table></figure>

<ul>
<li>此时查看R3的路由表可知去往172.16.4.0/24网段的路由的下一跳变为R4</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDHaR.png"></p>
<ul>
<li>在R3上再次跟踪路由，如下图所示，可知此时R3直接通过R4访问172.16.4.1，无需再经过hub</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDLPx.png"></p>
<h3 id="4、phase-3验证"><a href="#4、phase-3验证" class="headerlink" title="4、phase-3验证"></a>4、phase-3验证</h3><blockquote>
<p>在阶段三引入了shortcut（短路）和redirect（重定向）</p>
</blockquote>
<ul>
<li>在R1上开启redirect，在R3和R4上开启shortcut</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip nhrp redirect </span><br><span class="line"></span><br><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#ip nhrp shortcut </span><br><span class="line"></span><br><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#ip nhrp shortcut </span><br></pre></td></tr></table></figure>

<ul>
<li>在R1上将下一跳属性和水平分割恢复</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip next-hop-self eigrp 110</span><br><span class="line">R1(config-if)#ip split-horizon eigrp 110</span><br></pre></td></tr></table></figure>

<ul>
<li>此时R3和R4的路由表还是无法学习到其他站点的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxrMon.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxrliq.png"></p>
<ul>
<li>为了验证实验结果，此时在R3启用多个回环口，并在eigrp中通告</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int loopback 3</span><br><span class="line">R3(config-if)#ip add 192.168.3.1 255.255.255.0</span><br><span class="line">R3(config)#int loopback 4</span><br><span class="line">R3(config-if)#ip add 192.168.4.1 255.255.255.0</span><br><span class="line">R3(config)#int loopback 5</span><br><span class="line">R3(config-if)#ip add 192.168.5.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">R3(config)#router eigrp 110</span><br><span class="line">R3(config-router)#network 192.168.3.0</span><br><span class="line">R3(config-router)#network 192.168.4.0</span><br><span class="line">R3(config-router)#network 192.168.5.0</span><br></pre></td></tr></table></figure>

<ul>
<li>在R1上进行路由汇总</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16</span><br><span class="line">R1(config-if)#ip summary-address eigrp 110 192.168.0.0/16</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看R3和R4的路由表，此时学习到的为经过R1汇总的条目，并且下一跳都指向R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxrsSK.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxr6yD.png"></p>
<ul>
<li>在R4上跟踪到达172.16.3.1所经过的路径，可知需经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxr4Yt.png"></p>
<ul>
<li>查看R4的路由表，此时出现了”H”的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxroSf.png"></p>
<ul>
<li>此时再次使用traceroute跟踪172.16.3.1，则无需再经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxs96U.png"></p>
<ul>
<li>再次进行验证，使用traceroute命令跟踪到达192.168.3.1所经过的路径，首次traceroute需要经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxsUc8.png"></p>
<ul>
<li>查看R4的路由表，此时通过NHRP学习到了更详细的路由去往192.168.3.0/24网段，下一跳为10.1.1.3</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxsrAs.png"></p>
<ul>
<li>再次使用traceroute跟踪路径，则无需再经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxsT41.png"></p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p><img src="https://s1.ax1x.com/2020/09/01/dx5hkT.png"></p>
]]></content>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>EIGRP的简单应用</title>
    <url>/2020/08/28/EIGRP%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）掌握EIGRP的基本配置<br>2）理解EIGRP的邻居表、拓扑表以及路由表的含义<br>3）掌握查看EIGRP路由协议的相关信息<br>4）掌握FD、AD、S、FS以及FC的含义<br>5）理解EIGRP的hello报文作用<br>6）理解路由快速收敛的含义<br>7）理解EIGRP的不等价负载均衡</p>
<a id="more"></a>

<h4 id="2、实验拓扑"><a href="#2、实验拓扑" class="headerlink" title="2、实验拓扑"></a>2、实验拓扑</h4><p><img src="https://s1.ax1x.com/2020/08/28/dTeEvT.png"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，要求PC1的IP地址设置为172.16.1.1/24，网关设置为172.16.1.254，PC2的IP地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划</strong></p>
<blockquote>
<p>IP地址规划如拓扑图标记所示，此处不再列出</p>
</blockquote>
<p><strong>（2）全网启用EIGRP，通告各自的直连网络路由，并关闭自动汇总</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用EIGRP进程，AS号为90，AS号是邻居建立的前提，邻居要建立AS号必须要一样</span></span><br><span class="line">R3(config)#router eigrp 90 </span><br><span class="line"><span class="comment">//关闭自动汇总</span></span><br><span class="line">R3(config-router)#no auto-summary  </span><br><span class="line"><span class="comment">//通告网段</span></span><br><span class="line">R3(config-router)#network 192.168.23.0  //通告直连网段</span><br><span class="line">R3(config-router)#network 172.16.3.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/28/dTmotA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTmj0g.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTnCpq.png"></p>
<p><strong>（3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息</strong></p>
<blockquote>
<p>Metric weight K1=1, K2=0, K3=1, K4=0, K5=0   – EIGRP的开销计算与这5个K值有关系</p>
<p>邻居要建立，则五个K值必须相同</p>
<p>K1：带宽；K2：负载；K3：延迟；K4：可靠性；K5：MTU</p>
<p>真正与EIGRP开销计算有关系的，只有带宽和延迟；</p>
<p>EIGRP开销=带宽+延迟</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTnHUJ.png"></p>
<p><strong>（4）查看各路由器的邻居表、拓扑表以及路由表，分别找出FD、AD以及S等重要信息</strong></p>
<blockquote>
<p>邻居表各字段含义</p>
<p>H：建立顺序</p>
<p>Address：对端的IP</p>
<p>Interface：从哪个接口学习到</p>
<p>Hold：定义了等待没有从邻居那里接收到任何包的最大时间，当接收到新的包以后，Hold复位（在10~15s之间循环）</p>
<p>Uptime：建立了多久</p>
<p>SRTT：向邻居发送包以及受到邻居回应ACK的平均回程时间</p>
<p>RTO：重传超时时间，路由器在重新传输包之前等待ACK的时间（应为SRTT的6倍，最大5000，若重传16次还未得到确认，则此邻居被宣布无效）</p>
<p>Q：队列计数，表示有多少个可靠报文还没有得到确认，在运行正常的环境下该值应为0（如果值大于0则说明发生了拥塞）</p>
<p>Seq：序列号</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuKaQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTulPs.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTu1Gn.png"></p>
<blockquote>
<p>拓扑表</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuRde.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuWIH.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuhid.png"></p>
<blockquote>
<p>路由表</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuTQP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuOoQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuvJs.png"></p>
<p><strong>（5）测试PC1与PC2之间的连通性</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKGYd.png"></p>
<p><strong>（6）在R2上添加一个loopback1接口，地址为200.200.200.200/24，然后在EIGRP中通告，观察R1和R3是否能马上学习到R2上新增的loopback1网段，并测试各主机与该loopback1之间的联通性</strong></p>
<blockquote>
<p>R1和R3能马上学习到R2上新增的loopback1网段</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKaOf.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTK00S.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKsYj.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKcpn.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKglq.png"></p>
<p><strong>（7）使用wireshark抓取EIGRP的报文，理解EIGRP报文各字段的含义</strong></p>
<blockquote>
<p>每隔5s发送一个hello包，保持时间为15s，即超过3个hello时间未收到hello则认为对端Down，断开连接</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKTh9.png"></p>
<p><strong>（8）在R1上添加一个loopback1接口，地址为100.100.100.100/24，然后在EIGRP中通告</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKj0O.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKv7D.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTMphd.png"></p>
<p><strong>（9）断开R1和R3与各主机之间的连接，连接R1与R3之间的以太网接口，完成必要配置，实现200.200.200.200访问100.100.100.100的不等价负载均衡</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTM0jx.png"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用源200.200.200.200去访问目标100.100.100.100</span></span><br><span class="line"><span class="comment">//若没有跟上source，那么默认情况下就是使用出接口去访问目标</span></span><br><span class="line">R2#ping 100.100.100.100 source 200.200.200.200  </span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/29/dTQP54.png"></p>
<blockquote>
<p>由于此时R2的路由表中只存在一条路径到达100.100.100.100，所以此时不存在负载均衡</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTQlPH.png"></p>
<blockquote>
<p>等价负载均衡：有多条开销相等的路径，此时可以同时从这些开销相等的路径去发送数量相同的数据包。</p>
<p>不等价负载均衡：有多条路径，但是开销不一样，此时会根据一定的比例去发送数据包。</p>
<p>对于EIGRP，默认情况下只支持等价负载均衡，并且默认情况下最多可以同时存在4条的等价负载均衡。</p>
<p>R2(config)#router eigrp 90</p>
<p>R2(config-router)#maximum-paths 8     –将等价负载均衡的条数改为8条</p>
<p>EIGRP还可以支持不等价负载均衡，但是有前提：</p>
<p>①次优路径的AD值要小于最优路径的FD值–称为FC条件，只有满足了该条件，才会存在FS。</p>
<p>②当存在FS之后，EIGRP拓扑表会存在两个下一跳，但是只会选择最优的添加进路由表。此时如果要保证路由表也有两条路径，必须手动修改V值(variance)，使得满足”最优路径的FD*V值&gt;次优路径的FD值”（默认情况下，v值为1）</p>
</blockquote>
<blockquote>
<p>此题中，最优路径为R2通过R1到达100.100.100.100，次优路径为经过R3、R1到达100.100.100.100</p>
</blockquote>
<blockquote>
<p>查看R2的路由表，此时显示的为最优路径，FD=409600</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTlmSs.png"></p>
<blockquote>
<p>次优路径的AD即为R3到达100.100.100.100的开销（FD），也为409600</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTl00K.png"></p>
<blockquote>
<p>此时不满足FC条件，则需更改开销，修改K值，更改R2的e0/0接口的延迟为3000（默认为1000），注意倍数关系</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTlfnP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTgwut.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTgRvn.png"></p>
<blockquote>
<p>将修改延迟的接口关闭再打开</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTgjDx.png"></p>
<blockquote>
<p>此时满足FC条件，即次优路径的AD值小于最优路径的FD值，在拓扑表中存在两条路径</p>
<p>此时的FS为R3</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dT2nIS.png"></p>
<blockquote>
<p>但是此时路由表中到达100.100.100.100仍然只存在一条最优路径</p>
<p>若想让次优路径加表，则需满足：最优路径的FD*v值 &gt; 次优路径的FD才能加入到路由表</p>
<p>修改V值为6，此时满足条件，路由表中到达100.100.100.0网段存在两个下一跳</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dT26Z6.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dT27eP.png"></p>
<blockquote>
<p>查看该路由的详细信息，可知基本满足1:5的关系</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTRdTf.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相关命令</span><br><span class="line">R2(config)#int e0&#x2F;0</span><br><span class="line">R2(config-if)#delay n  --修改延迟，但是注意，如果输入的是n，那么延迟会改为10*n</span><br><span class="line">R2(config-if)#bandwidth n  --修改带宽，如果输入的是n，那么带宽就为n</span><br><span class="line"></span><br><span class="line">R2#show interfaces e0&#x2F;0  --看接口的详细信息，比如说带宽、延迟</span><br><span class="line">R2#show ip route 100.100.100.0 255.255.255.0  --查看该路由的详细信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>路由协议</tag>
        <tag>EIGRP</tag>
      </tags>
  </entry>
  <entry>
    <title>RIP的应用</title>
    <url>/2020/08/27/RIP%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、-实验目的"><a href="#1、-实验目的" class="headerlink" title="1、 实验目的"></a>1、 实验目的</h4><ol>
<li>掌握RIPv2的基本配置<br></li>
<li>理解RIPv2路由条目的结构含义<br></li>
<li>理解自动汇总的含义<br></li>
<li>理解和观察周期性更新<br></li>
<li>理解debug ip rip 命令 的作用<a id="more"></a>

</li>
</ol>
<h4 id="2、-拓扑结构"><a href="#2、-拓扑结构" class="headerlink" title="2、 拓扑结构"></a>2、 拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/28/doIIiV.png"></p>
<h4 id="3、-实验步骤"><a href="#3、-实验步骤" class="headerlink" title="3、 实验步骤"></a>3、 实验步骤</h4><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互 ping 对方， 要求 PC1 的 IP 地址设置为 172.16.1.1/24，网关设置为172.16.1.254， PC2 的 IP 地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划。</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5mDb9.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5uw79.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5NpXn.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5NkkT.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5Ne1J.png"></p>
<p><strong>（2）在三台路由器上都启用RIPv2协议，通告各自的直连网络路由，并开启自动汇总</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认开启自动汇总，会在边界处把一个网段汇总成主类</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/28/do543D.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do5HHI.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do5v8S.png"></p>
<p><strong>（3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息</strong></p>
<blockquote>
<p>路由更新计时器：30s（默认）<br>路由无效时间：180s（默认）<br>抑制计时器：180s（默认）<br>路由刷新计时器：240s（默认）</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dooEdI.png"></p>
<p><strong>（4）查看各路由器的路由表，观察RIP路由条目的特征</strong></p>
<blockquote>
<p>由于没有关闭自动汇总，R1上存在172.16.0.0网段的路由，则不会再学习R2上的172.16.0.0的路由</p>
<p>同理，R2上存在172.16.0.0网段的路由，则不会学习R1上的172.16.0.0的路由</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/doowy4.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dooRSO.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doo7kt.png"></p>
<p><strong>（5）分别在R2和PC2上测试R2与PC1以及PC2与PC1之间的连通性</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTJnH.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTtHA.png"></p>
<p><strong>（6）在R2上使用debug ip rip观察路由的发送情况</strong></p>
<blockquote>
<p>RIPv2组播地址：224.0.0.9</p>
<p>由于没有关闭自动汇总，此时发送的报文都为主类路由</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/doT09f.png"></p>
<p><strong>（7）在三台路由器上都关闭自动汇总，观察各路由表的变化，并再次测试R2与PC1以及PC2与PC1之间的连通性</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTrjg.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doT43T.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTLU1.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7Z28.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7urQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7QVs.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do70aR.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7yRK.png"></p>
<p><strong>（8）再次在R2上使用debug ip rip观察路由的发送情况，比较关闭自动汇总与开启自动汇总debug输出信息的不同</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7von.png"></p>
<p><strong>（9）在R2上添加一个loopback1接口，地址自定</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doHAeJ.png"></p>
<p><strong>（10）添加必要配置，实现PC1和PC2都能够正常访问在R2上的loopback1</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTPgQH.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTPhwt.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTPTfS.png"></p>
<p><strong>（11）在R1上添加一个loopback1接口，地址自定，然后在RIP中通告，观察R2和R3是否能马上学习到R1上新增的loopback1网段</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTiwcQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTi7Ax.png"></p>
<blockquote>
<p>由于rip的路由表的更新时间为30s，故在R2、R3上无法马上学习到在R1上新增的loopback1网段</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTFJKJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTFtbR.png"></p>
<p><strong>（12）将R1上的loopback1接口关闭，观察R2和R3上是否还存在关于R1上的loopback1网段的路由条目</strong></p>
<blockquote>
<p>由于触发更新，R1上存在失效路由，则会马上发送更新给相邻的路由器，让他们将失效路由删除</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTA5uQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTAoHs.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTA7En.png"></p>
<p><strong>（13）使用wireshark抓取RIPv2报文，理解RIPv2报文各字段的含义</strong></p>
<blockquote>
<p>RIPv2运行在UDP的520端口上，属于应用层协议</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTAHNq.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>路由协议</tag>
        <tag>RIP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>STP的运用</title>
    <url>/2020/08/31/STP%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）理解STP的作用<br>2）熟悉STP的工作原理<br>3）掌握STP的查看命令</p>
<a id="more"></a>

<h4 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/31/djPbAe.png"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）在相应的交换机上创建vlan10，并将连接PC1和PC2的交换端口都划分进该vlan中</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djiiNQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djiVcq.png"></p>
<p><strong>（2）为主机设置合适的IP地址，IP地址自定，完成必要的配置实现主机间的通信</strong></p>
<ul>
<li>为两台PC配置IP地址（注意关闭路由功能，因为实验中的PC使用的是路由器的镜像）</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djiUHO.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djiDCd.png"></p>
<ul>
<li>将交换机之间的端口封装802.1Q，并配置成trunk</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djFmRA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djFKMt.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djFYGj.png"></p>
<ul>
<li>测试PC的连通性</li>
</ul>
<blockquote>
<p>由于PC1和PC2属于同一vlan，所以通过上述配置即可相互ping通</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/31/djFxw8.png"></p>
<p><strong>（3）查看各交换机的STP信息</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djksnP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djk678.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djkgAS.png"></p>
<p><strong>（4）将SW1设置为vlan10的根桥，使用相关命令验证和查看各交换机上根桥的变化</strong></p>
<ul>
<li>设置SW1为vlan10的根桥</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djAmut.png"></p>
<ul>
<li>使用<span style="color:red">show spanning-tree</span>命令查看交换机状态</li>
</ul>
<blockquote>
<p>由于设置SW1为vlan10的根桥，由下图可知，优先级默认降低2*4096，即为24576，加上vlan-id的10，所以优先级为24586</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/31/djZVgJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djZQUK.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djZGgH.png"></p>
<p><strong>（5）测试正常链路出现故障对主机通信的影响</strong></p>
<ul>
<li>将SW2的e0/1接口shutdown</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djZcKs.png"></p>
<ul>
<li>PC1仍然可以ping通PC2</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djZ2bq.png"></p>
<p><strong>（6）先断开PC1与交换机的连接，然后恢复PC1与交换机的连接，观察主机重新接入交换机要经历多久才能够进行数据转发</strong></p>
<blockquote>
<p>由下图可知，PC1重新接入交换机需要经历30s（由于关闭的是SW2上的端口，可以直接进入listening状态（无需经历20s的blocking状态），再经历15s进入learning状态，最后经历15s进入forwarding状态）</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/31/djero6.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>交换</tag>
        <tag>STP</tag>
      </tags>
  </entry>
  <entry>
    <title>单区域OSPF的实现</title>
    <url>/2020/08/29/%E5%8D%95%E5%8C%BA%E5%9F%9FOSPF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）掌握OSPF的基本配置<br>2）掌握OSPF的邻居表、拓扑表及路由表的含义<br>3）掌握OSPF的DR和BDR的作用<br>4）掌握OSPF的DR和BDR的选举<br>5）查看和调试OSPF路由协议的相关信息<br>6）熟悉OSPF中hello报文的作用和格式</p>
<a id="more"></a>
<h4 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/29/dHg68e.png" alt="拓扑图"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划</strong></p>
<ul>
<li>各接口地址如拓扑图标记所示进行配置</li>
</ul>
<p><strong>（2）全网启用OSPF，并划分如区域0</strong></p>
<blockquote>
<p>距离矢量为通告</p>
<p>链路状态为使能</p>
<p>network表示的是划分一个范围，路由器上属于此范围的对应接口加入OSPF的相应进程的相应区域</p>
<p>如network 192.168.12.0 0.0.0.255 area 0 表示的是划分一个范围为192.168.12.0，看此路由器上的哪个接口在这个范围内，则这个接口就会被加入OSPF的区域0中</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dH2hQJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH2Tdx.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH2qJO.png"></p>
<p><strong>（3）观察各路由器的邻居表、拓扑表及路由表，观察哪些链路上有进行DR/BDR的选举，并测试主机之间的连通性</strong></p>
<blockquote>
<p>优先级用于选举DR/BDR——以太网链路存在DR/BDR的选举，串行链路则没有</p>
<p>选举规则：</p>
<ul>
<li><p>先比较优先级，优先级大的优先；默认情况下以太网接口的优先级都为1，串行链路的接口优先级都为0（优先级为0不能参与DR/BDR的选举）</p>
</li>
<li><p>如果优先级都一样，继续比较RID，RID大的优先</p>
</li>
<li><p>DR的选举是非抢占的</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>Hello报文</p>
<p>作用：用来发现、建立、维持邻居之间的关系</p>
<p>每隔10s往224.0.0.5发送Hello报文，如果在40之后没有收到来自邻居的Hello，则认为该邻居挂了，就切断和该邻居之间的关系（死亡时间通常在30-39之间）</p>
</blockquote>
<blockquote>
<p>-————————————————————————————————————————–</p>
<p>Neighbor ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pri &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State &nbsp;&nbsp;&nbsp;Dead Time &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface</p>
<p>&nbsp;&nbsp;&nbsp;邻居的ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级 &nbsp;&nbsp;状态 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;死亡时间 &nbsp;&nbsp;&nbsp;&nbsp;邻居的IP地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己用于建立邻居的接口</p>
<p>-————————————————————————————————————————–</p>
</blockquote>
<ul>
<li>邻居表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHWXqA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHWxat.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHWzIP.png"></p>
<ul>
<li>拓扑表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfVZn.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfeI0.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfuGT.png"></p>
<ul>
<li>路由表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfydI.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfgFP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHffSS.png"></p>
<ul>
<li>连通性测试</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHhpwR.png"></p>
<p><strong>（4）指定R2的RID为20.20.20.20，R3的RID为30.30.30.30，使用相关命令观察和验证各路由器RID的变化</strong></p>
<blockquote>
<p>【RID的选举】</p>
<ul>
<li><p>手工指定：最优先</p>
<p>R2(config)#router ospf 1</p>
<p>R2(config-router)#router-id 20.20.20.20    –手动指定RID</p>
<p>Reload or use “clear ip ospf process” command, for this to take effect</p>
<p>R2#clear ip ospf process    –重置OSPF的进程 </p>
<p>Reset ALL OSPF processes? [no]: y</p>
</li>
<li><p>自动选择：在没有手工指定情况下，优先选择回环口中IP地址最大的；若没有回环口，选择物理接口（双UP）中IP地址最大。</p>
</li>
</ul>
</blockquote>
<ul>
<li>查看当前R2和R3的RID，由于没有手工指定，也没有存在回环口，则选择物理接口中IP地址最大的作为RID</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHhI1O.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHhTje.png"></p>
<ul>
<li>指定R2和R3路由器的RID</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4PBj.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4kEn.png"></p>
<ul>
<li>再次查看R2和R3的RID</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4ANq.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4E40.png"></p>
<p><strong>（5）实现R2为以太网链路网段上的DR</strong></p>
<ul>
<li>由于R1和R2的优先级默认都为1，并且R2的RID为20.20.20.20，而R1的RID为192.168.12.1，此时需要修改R2的e0/0接口的优先级，使之成为以太网链路上的DR。此处指定R2上e0/0接口的优先级为2即可</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4zI1.png"></p>
<ul>
<li>由于DR、BDR的选举为非抢占，此时应重置OSPF进程</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHIpwj.png"></p>
<ul>
<li>查看R1和R2的邻居表，可知此时R2成为以太网链路上的DR</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHIFf0.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHIApV.png"></p>
<p><strong>（6）分别在R2和R3的路由器上添加172.16.2.0/24和172.16.3.0/24的网段，添加必要配置实现这两个网络之间的连通性</strong></p>
<ul>
<li>由于R3上已存在172.16.3.0/24网段，此时在R2上添加一个回环口（地址为172.16.2.2/24）用作测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R2(config)#interface loopback 1</span><br><span class="line">R2(config-if)#ip address 172.16.2.2 255.255.255.0</span><br><span class="line">R2(config-if)#ip ospf 1 area 0  --把该接口加入到OSPF进程1区域0中</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/30/dHIqHJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dHIXNR.png"></p>
<p><strong>（7）开启debug信息，观察OSPF在以太网链路之间信息交互的过程</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dHIx9x.png"></p>
<p><strong>（8）开启debug信息，观察OSPF在串行链路之间信息交互的过程，比较以太网链路和串行链路上OSPF的debug信息输出的区别</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dHoPDe.png"></p>
<blockquote>
<p>最主要区别在于以太网链路会进行DR/BDR的选举；串行链路则没有进行DR/BDR的选举</p>
<p>以太网链路中，路由信息会先被发送到组播地址224.0.0.6，即被DR/BDR所接收，再由DR将此信息发送到组播地址224.0.0.5</p>
</blockquote>
<p><strong>（9）使用wireshark抓取OSPF的hello报文，理解hello报文各字段的含义</strong></p>
<blockquote>
<p>hello报文用于邻居的发现，建立和维持</p>
<p>hello报文中的相关信息包括：</p>
<ul>
<li>Network Mask：发送hello报文的接口所在网络的掩码</li>
<li>Hello Interval（默认为10s）：发送hello报文的时间间隔</li>
<li>Options：可选项<ul>
<li>E：允许Flood AS-External-LSAs</li>
<li>MC：转发IP组播报文</li>
<li>N/P：处理Type-7 LSAs</li>
<li>DC：处理按需链路</li>
</ul>
</li>
<li>Router Priority：优先级，默认为1，如果设置为0，则不参与DR或BDR的选举</li>
<li>Router Dead Interval（默认40s）：失效时间，如果在此时间内未收到邻居发送的hello报文，则认为邻居失效</li>
<li>Designated Router：DR的接口地址</li>
<li>Backup Designated Router：BDR的接口地址</li>
<li>Active Neighbor：活跃的邻居，以RID标识</li>
</ul>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/30/dHoE4I.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>路由协议</tag>
        <tag>OSPF</tag>
      </tags>
  </entry>
  <entry>
    <title>单臂路由运用</title>
    <url>/2020/08/30/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）掌握交换机上VLAN的创建和划分<br>2）掌握trunk的作用<br>3）掌握VTP的作用与配置<br>4）掌握单臂路由原理与配置<br>5）理解trunk链路上的802.1Q标记的作用</p>
<a id="more"></a>
<h4 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/30/dqOjXR.png"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）在SW1上创建两个vlan，vlan10和vlan20，并将vlan10命名为sales，将vlan20命名为engineers</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqXEjA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqXeBt.png"></p>
<p><strong>（2）完成必要的配置，实现两交换机的vlan数据库同步，并使用相关命令验证和查看vlan数据库的信息</strong></p>
<blockquote>
<p>要实现两交换机的vlan数据库同步，需要进行vtp的配置</p>
</blockquote>
<ul>
<li>将两交换机相连的端口设置为trunk</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqXJun.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqj8PO.png"></p>
<ul>
<li>指定vtp的域和密码，并指定SW1的vtp模式为server，SW2的vtp模式为client</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqjyRg.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqvFOA.png"></p>
<ul>
<li>在SW2上查看vlna信息，此前并未在SW2上创建vlan，由此可知两交换机之间实现了vlan数据库的同步</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqv6k6.png"></p>
<ul>
<li>尝试在SW2上创建一个vlan，日志提示在vtp的模式为client的条件下不允许创建vlan</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqvRpD.png"></p>
<ul>
<li>在SW1上查看vtp的状态信息，从下图可知SW1的vtp模式为server（默认），已存在的vlan数量为7，修订版本号为8</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqx9A0.png"></p>
<p><strong>（3）将连接PC1和PC3的交换端口划分进vlan10，将连接PC2的交换端口划分进vlan20中，并为各PC配置合适的IP地址和网关</strong></p>
<ul>
<li>依题意将交换机上的端口划分进对应的vlan</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxYDA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxUEt.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxd4f.png"></p>
<ul>
<li>由于各PC为使用路由器镜像模拟，需在PC上关闭路由功能。按下图所示为各PC配置IP地址和网关</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxIv4.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxHbR.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxLUx.png"></p>
<p><strong>（4）使用show vlan brief查看各交换机的vlan信息</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzFat.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzEPf.png"></p>
<p><strong>（5）测试各主机之间的连通性</strong></p>
<blockquote>
<p>PC1和PC3之间可以相互ping通（两PC属于同一vlan，无需经过三层设备）</p>
<p>PC1和PC2之间无法通信（两PC属于不同vlan，需要经过三层设备，此时还未在路由器上进行相应的配置）</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzlaq.png"></p>
<p><strong>（6）在交换机和路由器上完成必要的配置，实现各主机间可以互相通信</strong></p>
<ul>
<li>将SW1上连路由器的端口配置成trunk</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzTW8.png">、</p>
<ul>
<li><p>在R1上进行单臂路由的配置</p>
<blockquote>
<p>单臂路由是指在路由器的一个接口上通过配置子接口(或”逻辑接口”，并不真实存在)的方式，实现原来相互隔离的不同vlan之间的互联互通</p>
<p>值得注意的是这些逻辑子接口不能被单独的开启或关闭，即当物理接口被开启或关闭时，所有的该物理接口的子接口也将对应的被开启或关闭</p>
<p>由于单臂路由存在瓶颈和单点故障的问题，因此必须限制主机/vlan的数量。此时可以通过SVI实现不同vlan间的通信（后续会进行介绍）</p>
</blockquote>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzHSS.png"></p>
<ul>
<li>测试各主机之间的连通性，如下图所示，三台PC之间可以互相ping通</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzbQg.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzLLj.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>单臂路由</tag>
        <tag>trunk</tag>
        <tag>vtp</tag>
      </tags>
  </entry>
</search>

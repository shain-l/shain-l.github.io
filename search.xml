<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACL的运用</title>
    <url>/2020/09/01/ACL%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h3><p>1）掌握ACL的作用<br>2）理解标准和扩展ACL的区别<br>3）熟悉标准和扩展ACL的配置<br>4）掌握ACL的验证和查看命令<br>5）理解命名的ACL的作用与配置</p>
<a id="more"></a>
<h3 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h3><p><img src="https://s1.ax1x.com/2020/09/01/dz9FzR.png"></p>
<h3 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h3><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划</strong></p>
<blockquote>
<p>两台PC及三台路由器的IP地址配置如拓扑图所示，此处不再将图贴出</p>
</blockquote>
<p><strong>（2）在R2上添加两个loopback接口，loopback1和loopback2，其中loopback1地址为2.2.2.2/24，loopback2地址为22.22.22.22/24</strong></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCFAS.png"></p>
<p><strong>（3）完成必要的配置实现全网可达</strong></p>
<blockquote>
<p>在路由器上运行路由协议，实现全网可达</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCVpj.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCecn.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCKBV.png"></p>
<p><strong>（4）使用标准ACL实现PC1不能访问PC2，并使用ping命令验证结果</strong></p>
<blockquote>
<p>标准ACL建议在离目标近的设备上配置，在R3上配置ACL拒绝来自主机172.16.1.1的流量，并在进接口方向调用，此时实现PC1不能访问PC2</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCT3j.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzCHvn.png"></p>
<p><strong>（5）使用标准ACL实现只允许PC2远程登录到路由器R2，并使用telnet命令验证结果</strong></p>
<blockquote>
<p>在R2上配置ACL，允许主机172.16.3.1的流量，默认隐含一条拒绝所有，即拒绝除PC2之外的流量。在vty中允许其他设备使用telnet远程登录，并在in方向调用ACL</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzPGa8.png"></p>
<blockquote>
<p>在PC1和PC2上进行测试，此时实现了只允许PC2远程登录到R2</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dziPJg.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dziVLq.png"></p>
<p><strong>（6）使用标准ACL实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制</strong></p>
<blockquote>
<p>在R1上配置ACL，允许loopback1网段，拒绝loopback2网段，然后在e0/1接口的in方向调用</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzizc9.png"></p>
<blockquote>
<p>此时实现了R2上的loopback1网段可以访问PC1，而loopback2网段不能</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzFtjs.png"></p>
<p><strong>（7）使用命名ACL完整上述标准ACL的需求</strong></p>
<ul>
<li>实现PC1不能访问PC2</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzecvD.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzeoPP.png"></p>
<ul>
<li>实现只允许PC2远程登录到路由器R2</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dznifP.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dznAl8.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dznVOg.png"></p>
<ul>
<li>实现禁止loopback2所在网段的所有主机访问PC1，对loopback1所在网段主机的访问不做限制</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuCB4.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuPHJ.png"></p>
<p><strong>（8）使用扩展ACL实现禁止PC1远程登录到R2，对其他访问不做限制</strong></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzu34I.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzu1UA.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzulEd.png"></p>
<p><strong>（9）使用扩展ACL实现PC2可以telnet到路由器R1，但不能ping通路由器R1，分别使用ping和telnet验证结果</strong></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuOqe.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuLrD.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuHxK.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzuqKO.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzu726.png"></p>
<p><strong>（10）使用扩展ACL实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果</strong></p>
<blockquote>
<p>ICMP</p>
<ul>
<li><p>echo request    –echo的请求包</p>
</li>
<li><p>echo reply         –echo的响应包</p>
</li>
</ul>
<p>只有以上两种报文是正常的，那么此时的ping才是能通的</p>
<p>PC1 ping PC2 正常</p>
<ul>
<li><p>PC1 给 PC2 发送的echo request是正常的（源是PC1，目标是PC2）</p>
</li>
<li><p>PC2给PC1发送的echo reply也是正常的（源是PC2，目标是PC1）</p>
</li>
</ul>
<p>PC2 ping PC1 不正常</p>
<ul>
<li><p>PC2不能给PC1发送 echo request（源是PC2，目的是PC1）</p>
</li>
<li><p>PC2不能接收到来自PC1的echo  reply（源是PC1，目的是PC2）</p>
</li>
</ul>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dzKOS0.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzKqWq.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzKbYn.png"></p>
<p><strong>（11）使用命名ACL完成上述扩展ACL的需求</strong></p>
<ul>
<li>实现禁止PC1远程登录到R2，对其他访问不做限制</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQCDS.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQPHg.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQ9u8.png"></p>
<ul>
<li>实现PC2可以telnet到路由器R1，但不能ping路由器R1，分别使用ping和telnet验证结果</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQKDU.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQuuT.png"></p>
<ul>
<li>实现PC1可以pingPC2，但禁止PC2pingPC1，其他的访问不受限制，使用ping验证结果</li>
</ul>
<p><span style="color:red">方法一：拒绝PC2向PC1发送icmp的echo-request报文</span></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQWqS.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQRr8.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzQ2Kf.png"></p>
<p><span style="color:red">方法二：拒绝PC1向PC2发送icmp的echo-reply报文</span></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzl1L8.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzllsf.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dzlQQP.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>ACL</tag>
      </tags>
  </entry>
  <entry>
    <title>DMVPN验证</title>
    <url>/2020/09/01/DMVPN%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>DMVPN三个阶段</p>
<ul>
<li>阶段一：中心到节点的设计（Hub-to-Spoke Design）</li>
<li>阶段二：节点到节点的设计（Spoke-to-Spoke Design）</li>
<li>阶段三：分层（基于树的）设计（Hierachical [Tree-Based] Design）</li>
</ul>
<p>本文将从三个阶段对DMVPN进行验证</p>
<a id="more"></a>

<h3 id="1、拓扑结构"><a href="#1、拓扑结构" class="headerlink" title="1、拓扑结构"></a>1、拓扑结构</h3><p><img src="https://s1.ax1x.com/2020/09/01/dxEvT0.png"></p>
<p>在进行验证之前，确保R1、R3、R4存在默认路由，使得三台路由器之间可以相互ping通</p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxulw9.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxu8F1.png"></p>
<h3 id="2、phase-1验证"><a href="#2、phase-1验证" class="headerlink" title="2、phase-1验证"></a>2、phase-1验证</h3><blockquote>
<p>hub端是mGRE，分支端是常规的GRE，分支之间的流量必须经过hub，可以采取关闭水平分割来实现分支之间的路由互相学习，可以在hub端进行手工的路由汇总，来优化分支的路由条目</p>
</blockquote>
<ul>
<li>hub配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip address 10.1.1.1 255.255.255.0    //隧道地址</span><br><span class="line">R1(config-if)#tunnel source 202.101.12.1    //指定隧道源地址(隧道目的地址可通过nhrp解析)</span><br><span class="line">R1(config-if)#tunnel mode gre multipoin    //R1为hub，所以指定gre隧道模式为multipoint</span><br><span class="line">R1(config-if)#tunnel key 100000    //指定隧道的key，可用于隧道的身份验证</span><br><span class="line">R1(config-if)#ip nhrp network-id 12345    //指定nhrp的标识，hub和spoke之间的network-id必须一致</span><br><span class="line">R1(config-if)#ip nhrp authentication cisco123    //nhrp身份验证</span><br><span class="line">R1(config-if)#ip nhrp map multicast dynamic    //开启组播映射功能</span><br></pre></td></tr></table></figure>

<ul>
<li>spoke(R3)配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#ip address 10.1.1.3 255.255.255.0</span><br><span class="line">R3(config-if)#tunnel source 202.101.23.3</span><br><span class="line">R3(config-if)#tunnel destination 202.101.12.1</span><br><span class="line">R3(config-if)#tunnel key 100000</span><br><span class="line">R3(config-if)#ip nhrp network-id 12345</span><br><span class="line">R3(config-if)#ip nhrp authentication cisco123 </span><br><span class="line">R3(config-if)#ip nhrp map 10.1.1.1 202.101.12.1    //映射hub的逻辑地址到物理地址</span><br><span class="line">R3(config-if)#ip nhrp map multicast 202.101.12.1    //映射组播信息到hub地址</span><br><span class="line">R3(config-if)#ip nhrp nhs 10.1.1.1    //指定next-hop-server为10.1.1.1</span><br></pre></td></tr></table></figure>

<ul>
<li>R1和R3的隧道地址可以相互ping通</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxKljS.png"></p>
<ul>
<li>在R1上查看地址的映射关系——10.1.1.3映射到的公网地址为202.101.23.3</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxKNhq.png"></p>
<ul>
<li>spoke(R4)配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#ip address 10.1.1.4 255.255.255.0</span><br><span class="line">R4(config-if)#ip nhrp network-id 12345</span><br><span class="line">R4(config-if)#ip nhrp authentication cisco123</span><br><span class="line">R4(config-if)#ip nhrp nhs 10.1.1.1</span><br><span class="line">R4(config-if)#ip nhrp map 10.1.1.1 202.101.12.1</span><br><span class="line">R4(config-if)#ip nhrp map multicast 202.101.12.1</span><br><span class="line">R4(config-if)#tunnel source 202.101.24.4</span><br><span class="line">R4(config-if)#tunnel destination 202.101.12.1</span><br><span class="line">R4(config-if)#tunnel key 100000</span><br></pre></td></tr></table></figure>

<ul>
<li>无需再在R1上配置，即可ping通R4的隧道地址，并且也记录了R4的逻辑地址和物理地址的映射关系</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxMdIA.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxMRaj.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxMWIs.png"></p>
<ul>
<li>分别在R1、R3、R4上各启用一个loopback接口，地址设置如下所示</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int loopback 1</span><br><span class="line">R1(config-if)#ip add 172.16.1.1 255.255.255.0</span><br><span class="line">R3(config)#int loopback 1</span><br><span class="line">R3(config-if)#ip address 172.16.3.1 255.255.255.0</span><br><span class="line">R4(config)#int loopback 1</span><br><span class="line">R4(config-if)#ip add 172.16.4.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<ul>
<li>启用EIGRP协议</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#router eigrp 110</span><br><span class="line">R1(config-router)#no auto-summary </span><br><span class="line">R1(config-router)#network 172.16.1.0 0.0.0.255</span><br><span class="line">R1(config-router)#network 10.1.1.0 0.0.0.255</span><br><span class="line"></span><br><span class="line">R3(config)#router eigrp 110</span><br><span class="line">R3(config-router)#no auto-summary </span><br><span class="line">R3(config-router)#network 172.16.3.0 0.0.0.255</span><br><span class="line">R3(config-router)#network 10.1.1.0 0.0.0.255</span><br><span class="line"></span><br><span class="line">R4(config)#router eigrp 110</span><br><span class="line">R4(config-router)#no auto-summary </span><br><span class="line">R4(config-router)#network 172.16.4.0 0.0.0.255</span><br><span class="line">R4(config-router)#network 10.1.1.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<ul>
<li>在R1上查看EIGRP邻居表，可知R1通过1个隧道接口建立了两个邻居关系</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxQj0g.png"></p>
<ul>
<li>在R1的e0/0接口抓包，报文如下图所示，但是此时的报文都为明文显示，需要进行加密</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxlEBF.png"></p>
<ul>
<li>在R1、R3和R4上配置IPSec，保护隧道上的数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">R1(config)#crypto isakmp policy 10</span><br><span class="line">R1(config-isakmp)#authentication pre-share</span><br><span class="line">R1(config-isakmp)#exit </span><br><span class="line">R1(config)#crypto isakmp key cisco123 address 0.0.0.0</span><br><span class="line">R1(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac </span><br><span class="line">R1(cfg-crypto-trans)#mode transport </span><br><span class="line">R1(cfg-crypto-trans)#exit</span><br><span class="line">R1(config)#crypto ipsec profile dprofile</span><br><span class="line">R1(ipsec-profile)#set transform-set dmvpn</span><br><span class="line">R1(ipsec-profile)#exit</span><br><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#tunnel protection ipsec profile dprofile</span><br><span class="line">*Aug <span class="number">31</span> <span class="number">02</span>:<span class="number">59</span>:<span class="number">34.650</span>: %CRYPTO<span class="number">-6</span>-ISAKMP_ON_OFF: ISAKMP is ON</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">R3(config)#crypto isakmp policy 10</span><br><span class="line">R3(config-isakmp)#authentication pre-share </span><br><span class="line">R3(config-isakmp)#exit</span><br><span class="line">R3(config)#crypto isakmp key cisco123 address 0.0.0.0</span><br><span class="line">R3(config)#crypto ipsec transform-set dmvpn esp-3des esp-sha256-hmac </span><br><span class="line">R3(cfg-crypto-trans)#mode transport </span><br><span class="line">R3(cfg-crypto-trans)#exit</span><br><span class="line">R3(config)#crypto ipsec profile dprofile</span><br><span class="line">R3(ipsec-profile)#set transform-set dmvpn</span><br><span class="line">R3(ipsec-profile)#exit</span><br><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#tunnel protection ipsec profile dprofile</span><br><span class="line">*Aug <span class="number">31</span> <span class="number">03</span>:<span class="number">02</span>:<span class="number">49.557</span>: %CRYPTO<span class="number">-6</span>-ISAKMP_ON_OFF: ISAKMP is ON</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">R4(config)#crypto isakmp policy 10</span><br><span class="line">R4(config-isakmp)#authentication pre-share </span><br><span class="line">R4(config-isakmp)#exit </span><br><span class="line">R4(config)#crypto isakmp key cisco123 address 0.0.0.0</span><br><span class="line">R4(config)#crypto ipsec transform-set dmvpn  esp-3des esp-sha256-hmac </span><br><span class="line">R4(cfg-crypto-trans)#mode transport </span><br><span class="line">R4(cfg-crypto-trans)#exit</span><br><span class="line">R4(config)#crypto ipsec profile dprofile</span><br><span class="line">R4(ipsec-profile)#set transform-set dmvpn</span><br><span class="line">R4(ipsec-profile)#exit</span><br><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#tunnel protection ipsec profile dprofile</span><br><span class="line">*Aug <span class="number">31</span> <span class="number">03</span>:<span class="number">06</span>:<span class="number">36.128</span>: %CRYPTO<span class="number">-6</span>-ISAKMP_ON_OFF: ISAKMP is ON</span><br></pre></td></tr></table></figure>

<ul>
<li>验证是否进行了加密</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx1KaQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dx1UZF.png"></p>
<ul>
<li>此时R3上的路由表并没有172.16.4.0的路由条目，因为存在水平分割问题</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx1xWn.png"></p>
<ul>
<li>在R1的隧道接口中关闭水平分割</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#no ip split-horizon eigrp 110</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看R3的路由表 ，此时学习到了172.16.4.0的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx31Te.png"></p>
<ul>
<li>跟踪路由，可知分支之间的流量必须经过hub</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx3rkQ.png"></p>
<ul>
<li>可通过在hub上进行路由汇总的方式来优化分支的路由条目，为了便于观察结果，在R3和R4上分别再开启一个回环口，并在EIGRP中通告</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int loopback 2</span><br><span class="line">R3(config-if)#ip address 172.16.33.1 255.255.255.0</span><br><span class="line">R3(config)#router eigrp 110</span><br><span class="line">R3(config-router)#network 172.16.33.0  0.0.0.255</span><br><span class="line"></span><br><span class="line">R4(config)#int loopback 2</span><br><span class="line">R4(config-if)#ip add 172.16.44.1 255.255.255.0</span><br><span class="line">R4(config)#router eigrp 110</span><br><span class="line">R4(config-router)#network 172.16.44.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<ul>
<li>查看R3和R4的路由表，都学习到了相应的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dx3HpR.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dx3b11.png"></p>
<ul>
<li>在R1的tunnel接口进行路由汇总</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看R3和R4的路由表，此时学习到的是经过R1汇总的路由</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDFvF.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDEDJ.png"></p>
<h3 id="3、phase-2验证"><a href="#3、phase-2验证" class="headerlink" title="3、phase-2验证"></a>3、phase-2验证</h3><blockquote>
<p>所有站点都采用mGRE，分支的流量可以无需经过hub，不能在hub端对路由进行汇总；eigrp环境，需要关闭下一跳规则——<span style="color:red">no ip next-hop-self eigrp</span>，缺点所有的分支都需要维护整个网络的所有路由信息。</p>
</blockquote>
<ul>
<li>在phase1的基础上，将R3、R4的隧道模式改为multipoint</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#no tunnel destination 202.101.12.1</span><br><span class="line">R3(config-if)#tunnel mode gre multipoint </span><br><span class="line"></span><br><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#no tunnel destination 202.101.12.1</span><br><span class="line">R4(config-if)#tunnel mode gre multipoint </span><br></pre></td></tr></table></figure>

<ul>
<li>在R3上使用traceroute跟踪路由，可知去往172.16.4.1仍然要经过hub</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDDKg.png"></p>
<ul>
<li>查看R3的路由表，可知去往172.16.4.0/24网段的路由的下一跳为hub</li>
</ul>
<blockquote>
<p>【注】<span style="color:red">此时并未在R1的隧道接口汇总路由</span></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDsbj.png"></p>
<ul>
<li>出现上述问题的原因在于EIGRP路由在传递的时候会将下一跳改为自己，将R1的tunnel接口将该属性关闭</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#no ip next-hop-self eigrp 110</span><br></pre></td></tr></table></figure>

<ul>
<li>此时查看R3的路由表可知去往172.16.4.0/24网段的路由的下一跳变为R4</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDHaR.png"></p>
<ul>
<li>在R3上再次跟踪路由，如下图所示，可知此时R3直接通过R4访问172.16.4.1，无需再经过hub</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxDLPx.png"></p>
<h3 id="4、phase-3验证"><a href="#4、phase-3验证" class="headerlink" title="4、phase-3验证"></a>4、phase-3验证</h3><blockquote>
<p>在阶段三引入了shortcut（短路）和redirect（重定向）</p>
</blockquote>
<ul>
<li>在R1上开启redirect，在R3和R4上开启shortcut</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip nhrp redirect </span><br><span class="line"></span><br><span class="line">R3(config)#int tunnel 1</span><br><span class="line">R3(config-if)#ip nhrp shortcut </span><br><span class="line"></span><br><span class="line">R4(config)#int tunnel 1</span><br><span class="line">R4(config-if)#ip nhrp shortcut </span><br></pre></td></tr></table></figure>

<ul>
<li>在R1上将下一跳属性和水平分割恢复</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip next-hop-self eigrp 110</span><br><span class="line">R1(config-if)#ip split-horizon eigrp 110</span><br></pre></td></tr></table></figure>

<ul>
<li>此时R3和R4的路由表还是无法学习到其他站点的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxrMon.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxrliq.png"></p>
<ul>
<li>为了验证实验结果，此时在R3启用多个回环口，并在eigrp中通告</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R3(config)#int loopback 3</span><br><span class="line">R3(config-if)#ip add 192.168.3.1 255.255.255.0</span><br><span class="line">R3(config)#int loopback 4</span><br><span class="line">R3(config-if)#ip add 192.168.4.1 255.255.255.0</span><br><span class="line">R3(config)#int loopback 5</span><br><span class="line">R3(config-if)#ip add 192.168.5.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">R3(config)#router eigrp 110</span><br><span class="line">R3(config-router)#network 192.168.3.0</span><br><span class="line">R3(config-router)#network 192.168.4.0</span><br><span class="line">R3(config-router)#network 192.168.5.0</span><br></pre></td></tr></table></figure>

<ul>
<li>在R1上进行路由汇总</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">R1(config)#int tunnel 1</span><br><span class="line">R1(config-if)#ip summary-address eigrp 110 172.16.0.0/16</span><br><span class="line">R1(config-if)#ip summary-address eigrp 110 192.168.0.0/16</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看R3和R4的路由表，此时学习到的为经过R1汇总的条目，并且下一跳都指向R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxrsSK.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxr6yD.png"></p>
<ul>
<li>在R4上跟踪到达172.16.3.1所经过的路径，可知需经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxr4Yt.png"></p>
<ul>
<li>查看R4的路由表，此时出现了”H”的路由条目</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxroSf.png"></p>
<ul>
<li>此时再次使用traceroute跟踪172.16.3.1，则无需再经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxs96U.png"></p>
<ul>
<li>再次进行验证，使用traceroute命令跟踪到达192.168.3.1所经过的路径，首次traceroute需要经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxsUc8.png"></p>
<ul>
<li>查看R4的路由表，此时通过NHRP学习到了更详细的路由去往192.168.3.0/24网段，下一跳为10.1.1.3</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxsrAs.png"></p>
<ul>
<li>再次使用traceroute跟踪路径，则无需再经过R1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/01/dxsT41.png"></p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p><img src="https://s1.ax1x.com/2020/09/01/dx5hkT.png"></p>
]]></content>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT和PPP的应用</title>
    <url>/2020/09/02/NAT%E5%92%8CPPP%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h3><p>1）理解NAT的作用<br>2）理解不同NAT的特点及配置<br>3）理解不同NAT的使用场合<br>4）掌握PPP的PAP和CHAP验证<br>5）理解辅助地址的作用<br>6）掌握NAT的验证和查看命令</p>
<a id="more"></a>
<h3 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h3><p><img src="https://s1.ax1x.com/2020/09/02/w9dK7d.png"></p>
<h3 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h3><p><strong>（1）公司COM1和COM2内部网段都为192.168.1.0/24，其中COM1的SRV地址为192.168.1.100/24，COM2的user地址为192.168.1.10/24，COM1内部的其他主机地址自己规划；ISP上的Web_Server地址为211.1.1.1/24，ISP与COM2之间的地址段为202.101.12.0/24，ISP与COM1之间的地址段为202.101.23.0/24，其中COM2连接ISP的接口地址为202.101.12.1/24，COM1连接ISP的接口地址为202.101.23.3/24</strong></p>
<blockquote>
<p>IP地址规划如拓扑图所示</p>
</blockquote>
<p><strong>（2）要求COM1与ISP之间的PPP链路采用CHAP验证，用户名为20164120，密码为123456</strong></p>
<ul>
<li>在ISP的s2/0封装PPP，并指定PPP的认证方式为CHAP，指定对方的IP地址为202.101.23.3</li>
<li>在全局下设置用户名和密码，用于chap验证</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wMKU.png"></p>
<ul>
<li>在COM1上s2/0接口封装PPP，指定IP地址为通过协商获取，填写用户名和密码，并让ISP下发默认路由</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wuvT.png"></p>
<ul>
<li>查看COM1上的IP地址，可知s2/0接口的IP地址为通过IPCP方式获得</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wm80.png"></p>
<ul>
<li>查看COM1的路由表中的静态路由条目，可知存在一条默认路由</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9wn2V.png"></p>
<p><strong>（3）在COM1上使用静态NAT实现SRV可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试</strong></p>
<ul>
<li>在COM1上启用一个loopback接口，用于静态nat的一对一映射</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90HTH.png"></p>
<ul>
<li>配置静态nat，将SRV的IP地址192.168.1.100映射到COM1上的loopback接口的地址</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90qkd.png"></p>
<ul>
<li>在ISP上配置静态路由，实现ISP可以访问COM1上的loopback接口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90jpt.png"></p>
<ul>
<li>在COM1上配置内部接口和外部接口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90LtA.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/02/w90OfI.png"></p>
<ul>
<li>此时SRV可以访问ISP上的Web_Server</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90v1P.png"></p>
<ul>
<li>在COM1上查看nat转换表，可知将192.168.1.100转换成200.100.1.1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90x6f.png"></p>
<ul>
<li>由于采用静态NAT，所以此时Web_Server也可以通过200.100.1.1访问SRV</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w90zX8.png"></p>
<ul>
<li>在Web_Server上使用telnet命令远程登录到200.100.1.1，由下图可知此时登录到的设备为SRV</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/w9BpnS.png"></p>
<p><strong>（4）在COM1上使用复用地址池的方式实现COM1内的所有用户可以访问ISP上的Web_Server，分别使用ping和debug ip nat进行验证和测试</strong></p>
<ul>
<li>在COM1上配置地址池，范围为202.101.23.10~202.101.23.12，掩码为/24</li>
<li>配置ACL，匹配192.168.1.0/24网段的流量</li>
<li>配置复用地址池NAT</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9siAe.png"></p>
<ul>
<li>此时各PC可以访问Web_Server</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9s90O.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w9sC7D.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w9spnK.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w9rzX6.png"></p>
<ul>
<li>在COM1上查看nat转换表，地址在COM1上执行了地址转换</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9sFtH.png"></p>
<ul>
<li>使用debug ip nat命令查看地址转换信息</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w9skhd.png"></p>
<p><strong>（5）在COM1和COM2上使用PAT方式实现COM1和COM2内部的用户都可以访问ISP上的Web_Server</strong></p>
<ul>
<li>由于COM1上已存在ACL 1匹配192.168.1.0/24网段的流量，所以此时可以直接在COM1上配置端口复用NAT</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96EOP.png"></p>
<ul>
<li>测试COM1内部的用户与Web_Server的连通性</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96Ayt.png"></p>
<ul>
<li>查看地址转换表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96Zef.png"></p>
<ul>
<li>在COM2上配置默认路由，下一跳指向ISP的e0/0接口的地址202.101.12.2，确保COM2可以访问Web_Server</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96ew8.png"></p>
<ul>
<li>在COM2上使用命名的标准ACL匹配192.168.1.0/24网段的流量</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96kQI.png"></p>
<ul>
<li>配置PAT</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96mTS.png"></p>
<ul>
<li>指定内外部接口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w960p9.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/03/w96aY4.png"></p>
<ul>
<li>测试COM2内部用户与Web_Server的连通性</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96dfJ.png"></p>
<ul>
<li>在COM2上查看nat转换表，可知内部用户192.168.1.10在访问外部网络时将地址转换成了202.101.12.1</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/w96UkF.png"></p>
<p><strong>（6）实现COM2内部的COM2_USER可以远程登录到SRV</strong></p>
<ul>
<li>在COM1上配置静态nat，将SRV的地址192.168.1.100的tcp23号端口静态映射成200.100.1.1的5656号端口</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/wC9w6J.png"></p>
<ul>
<li>在COM2_USER上使用telnet命令远程登录到SRV，此时应注意加上端口号</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/03/wC9dl4.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>NAT</tag>
        <tag>PPP</tag>
      </tags>
  </entry>
  <entry>
    <title>EIGRP的简单应用</title>
    <url>/2020/08/28/EIGRP%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）掌握EIGRP的基本配置<br>2）理解EIGRP的邻居表、拓扑表以及路由表的含义<br>3）掌握查看EIGRP路由协议的相关信息<br>4）掌握FD、AD、S、FS以及FC的含义<br>5）理解EIGRP的hello报文作用<br>6）理解路由快速收敛的含义<br>7）理解EIGRP的不等价负载均衡</p>
<a id="more"></a>

<h4 id="2、实验拓扑"><a href="#2、实验拓扑" class="headerlink" title="2、实验拓扑"></a>2、实验拓扑</h4><p><img src="https://s1.ax1x.com/2020/08/28/dTeEvT.png"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，要求PC1的IP地址设置为172.16.1.1/24，网关设置为172.16.1.254，PC2的IP地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划</strong></p>
<blockquote>
<p>IP地址规划如拓扑图标记所示，此处不再列出</p>
</blockquote>
<p><strong>（2）全网启用EIGRP，通告各自的直连网络路由，并关闭自动汇总</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用EIGRP进程，AS号为90，AS号是邻居建立的前提，邻居要建立AS号必须要一样</span></span><br><span class="line">R3(config)#router eigrp 90 </span><br><span class="line"><span class="comment">//关闭自动汇总</span></span><br><span class="line">R3(config-router)#no auto-summary  </span><br><span class="line"><span class="comment">//通告网段</span></span><br><span class="line">R3(config-router)#network 192.168.23.0  //通告直连网段</span><br><span class="line">R3(config-router)#network 172.16.3.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/28/dTmotA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTmj0g.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTnCpq.png"></p>
<p><strong>（3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息</strong></p>
<blockquote>
<p>Metric weight K1=1, K2=0, K3=1, K4=0, K5=0   – EIGRP的开销计算与这5个K值有关系</p>
<p>邻居要建立，则五个K值必须相同</p>
<p>K1：带宽；K2：负载；K3：延迟；K4：可靠性；K5：MTU</p>
<p>真正与EIGRP开销计算有关系的，只有带宽和延迟；</p>
<p>EIGRP开销=带宽+延迟</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTnHUJ.png"></p>
<p><strong>（4）查看各路由器的邻居表、拓扑表以及路由表，分别找出FD、AD以及S等重要信息</strong></p>
<blockquote>
<p>邻居表各字段含义</p>
<p>H：建立顺序</p>
<p>Address：对端的IP</p>
<p>Interface：从哪个接口学习到</p>
<p>Hold：定义了等待没有从邻居那里接收到任何包的最大时间，当接收到新的包以后，Hold复位（在10~15s之间循环）</p>
<p>Uptime：建立了多久</p>
<p>SRTT：向邻居发送包以及受到邻居回应ACK的平均回程时间</p>
<p>RTO：重传超时时间，路由器在重新传输包之前等待ACK的时间（应为SRTT的6倍，最大5000，若重传16次还未得到确认，则此邻居被宣布无效）</p>
<p>Q：队列计数，表示有多少个可靠报文还没有得到确认，在运行正常的环境下该值应为0（如果值大于0则说明发生了拥塞）</p>
<p>Seq：序列号</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuKaQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTulPs.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTu1Gn.png"></p>
<blockquote>
<p>拓扑表</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuRde.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuWIH.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuhid.png"></p>
<blockquote>
<p>路由表</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuTQP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuOoQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTuvJs.png"></p>
<p><strong>（5）测试PC1与PC2之间的连通性</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKGYd.png"></p>
<p><strong>（6）在R2上添加一个loopback1接口，地址为200.200.200.200/24，然后在EIGRP中通告，观察R1和R3是否能马上学习到R2上新增的loopback1网段，并测试各主机与该loopback1之间的联通性</strong></p>
<blockquote>
<p>R1和R3能马上学习到R2上新增的loopback1网段</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKaOf.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTK00S.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKsYj.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKcpn.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKglq.png"></p>
<p><strong>（7）使用wireshark抓取EIGRP的报文，理解EIGRP报文各字段的含义</strong></p>
<blockquote>
<p>每隔5s发送一个hello包，保持时间为15s，即超过3个hello时间未收到hello则认为对端Down，断开连接</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKTh9.png"></p>
<p><strong>（8）在R1上添加一个loopback1接口，地址为100.100.100.100/24，然后在EIGRP中通告</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKj0O.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTKv7D.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTMphd.png"></p>
<p><strong>（9）断开R1和R3与各主机之间的连接，连接R1与R3之间的以太网接口，完成必要配置，实现200.200.200.200访问100.100.100.100的不等价负载均衡</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTM0jx.png"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用源200.200.200.200去访问目标100.100.100.100</span></span><br><span class="line"><span class="comment">//若没有跟上source，那么默认情况下就是使用出接口去访问目标</span></span><br><span class="line">R2#ping 100.100.100.100 source 200.200.200.200  </span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/29/dTQP54.png"></p>
<blockquote>
<p>由于此时R2的路由表中只存在一条路径到达100.100.100.100，所以此时不存在负载均衡</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTQlPH.png"></p>
<blockquote>
<p>等价负载均衡：有多条开销相等的路径，此时可以同时从这些开销相等的路径去发送数量相同的数据包。</p>
<p>不等价负载均衡：有多条路径，但是开销不一样，此时会根据一定的比例去发送数据包。</p>
<p>对于EIGRP，默认情况下只支持等价负载均衡，并且默认情况下最多可以同时存在4条的等价负载均衡。</p>
<p>R2(config)#router eigrp 90</p>
<p>R2(config-router)#maximum-paths 8     –将等价负载均衡的条数改为8条</p>
<p>EIGRP还可以支持不等价负载均衡，但是有前提：</p>
<p>①次优路径的AD值要小于最优路径的FD值–称为FC条件，只有满足了该条件，才会存在FS。</p>
<p>②当存在FS之后，EIGRP拓扑表会存在两个下一跳，但是只会选择最优的添加进路由表。此时如果要保证路由表也有两条路径，必须手动修改V值(variance)，使得满足”最优路径的FD*V值&gt;次优路径的FD值”（默认情况下，v值为1）</p>
</blockquote>
<blockquote>
<p>此题中，最优路径为R2通过R1到达100.100.100.100，次优路径为经过R3、R1到达100.100.100.100</p>
</blockquote>
<blockquote>
<p>查看R2的路由表，此时显示的为最优路径，FD=409600</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTlmSs.png"></p>
<blockquote>
<p>次优路径的AD即为R3到达100.100.100.100的开销（FD），也为409600</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTl00K.png"></p>
<blockquote>
<p>此时不满足FC条件，则需更改开销，修改K值，更改R2的e0/0接口的延迟为3000（默认为1000），注意倍数关系</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTlfnP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTgwut.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dTgRvn.png"></p>
<blockquote>
<p>将修改延迟的接口关闭再打开</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTgjDx.png"></p>
<blockquote>
<p>此时满足FC条件，即次优路径的AD值小于最优路径的FD值，在拓扑表中存在两条路径</p>
<p>此时的FS为R3</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dT2nIS.png"></p>
<blockquote>
<p>但是此时路由表中到达100.100.100.100仍然只存在一条最优路径</p>
<p>若想让次优路径加表，则需满足：最优路径的FD*v值 &gt; 次优路径的FD才能加入到路由表</p>
<p>修改V值为6，此时满足条件，路由表中到达100.100.100.0网段存在两个下一跳</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dT26Z6.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dT27eP.png"></p>
<blockquote>
<p>查看该路由的详细信息，可知基本满足1:5的关系</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dTRdTf.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相关命令</span><br><span class="line">R2(config)#int e0&#x2F;0</span><br><span class="line">R2(config-if)#delay n  --修改延迟，但是注意，如果输入的是n，那么延迟会改为10*n</span><br><span class="line">R2(config-if)#bandwidth n  --修改带宽，如果输入的是n，那么带宽就为n</span><br><span class="line"></span><br><span class="line">R2#show interfaces e0&#x2F;0  --看接口的详细信息，比如说带宽、延迟</span><br><span class="line">R2#show ip route 100.100.100.0 255.255.255.0  --查看该路由的详细信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>路由协议</tag>
        <tag>EIGRP</tag>
      </tags>
  </entry>
  <entry>
    <title>RIP的应用</title>
    <url>/2020/08/27/RIP%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、-实验目的"><a href="#1、-实验目的" class="headerlink" title="1、 实验目的"></a>1、 实验目的</h4><ol>
<li>掌握RIPv2的基本配置<br></li>
<li>理解RIPv2路由条目的结构含义<br></li>
<li>理解自动汇总的含义<br></li>
<li>理解和观察周期性更新<br></li>
<li>理解debug ip rip 命令 的作用<a id="more"></a>

</li>
</ol>
<h4 id="2、-拓扑结构"><a href="#2、-拓扑结构" class="headerlink" title="2、 拓扑结构"></a>2、 拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/28/doIIiV.png"></p>
<h4 id="3、-实验步骤"><a href="#3、-实验步骤" class="headerlink" title="3、 实验步骤"></a>3、 实验步骤</h4><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互 ping 对方， 要求 PC1 的 IP 地址设置为 172.16.1.1/24，网关设置为172.16.1.254， PC2 的 IP 地址设置为172.16.3.1/24，网关设置为172.16.3.254，各路由器接口间的地址自己规划。</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5mDb9.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5uw79.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5NpXn.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5NkkT.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/27/d5Ne1J.png"></p>
<p><strong>（2）在三台路由器上都启用RIPv2协议，通告各自的直连网络路由，并开启自动汇总</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认开启自动汇总，会在边界处把一个网段汇总成主类</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/28/do543D.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do5HHI.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do5v8S.png"></p>
<p><strong>（3）在R1上使用show ip protocols命令，观察并理解该命令的输出信息</strong></p>
<blockquote>
<p>路由更新计时器：30s（默认）<br>路由无效时间：180s（默认）<br>抑制计时器：180s（默认）<br>路由刷新计时器：240s（默认）</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dooEdI.png"></p>
<p><strong>（4）查看各路由器的路由表，观察RIP路由条目的特征</strong></p>
<blockquote>
<p>由于没有关闭自动汇总，R1上存在172.16.0.0网段的路由，则不会再学习R2上的172.16.0.0的路由</p>
<p>同理，R2上存在172.16.0.0网段的路由，则不会学习R1上的172.16.0.0的路由</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/doowy4.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dooRSO.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doo7kt.png"></p>
<p><strong>（5）分别在R2和PC2上测试R2与PC1以及PC2与PC1之间的连通性</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTJnH.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTtHA.png"></p>
<p><strong>（6）在R2上使用debug ip rip观察路由的发送情况</strong></p>
<blockquote>
<p>RIPv2组播地址：224.0.0.9</p>
<p>由于没有关闭自动汇总，此时发送的报文都为主类路由</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/doT09f.png"></p>
<p><strong>（7）在三台路由器上都关闭自动汇总，观察各路由表的变化，并再次测试R2与PC1以及PC2与PC1之间的连通性</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTrjg.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doT43T.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doTLU1.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7Z28.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7urQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7QVs.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do70aR.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7yRK.png"></p>
<p><strong>（8）再次在R2上使用debug ip rip观察路由的发送情况，比较关闭自动汇总与开启自动汇总debug输出信息的不同</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/do7von.png"></p>
<p><strong>（9）在R2上添加一个loopback1接口，地址自定</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/doHAeJ.png"></p>
<p><strong>（10）添加必要配置，实现PC1和PC2都能够正常访问在R2上的loopback1</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTPgQH.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTPhwt.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTPTfS.png"></p>
<p><strong>（11）在R1上添加一个loopback1接口，地址自定，然后在RIP中通告，观察R2和R3是否能马上学习到R1上新增的loopback1网段</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTiwcQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTi7Ax.png"></p>
<blockquote>
<p>由于rip的路由表的更新时间为30s，故在R2、R3上无法马上学习到在R1上新增的loopback1网段</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTFJKJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTFtbR.png"></p>
<p><strong>（12）将R1上的loopback1接口关闭，观察R2和R3上是否还存在关于R1上的loopback1网段的路由条目</strong></p>
<blockquote>
<p>由于触发更新，R1上存在失效路由，则会马上发送更新给相邻的路由器，让他们将失效路由删除</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTA5uQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTAoHs.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/28/dTA7En.png"></p>
<p><strong>（13）使用wireshark抓取RIPv2报文，理解RIPv2报文各字段的含义</strong></p>
<blockquote>
<p>RIPv2运行在UDP的520端口上，属于应用层协议</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/28/dTAHNq.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>路由协议</tag>
        <tag>RIP</tag>
      </tags>
  </entry>
  <entry>
    <title>STP的运用</title>
    <url>/2020/08/31/STP%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）理解STP的作用<br>2）熟悉STP的工作原理<br>3）掌握STP的查看命令</p>
<a id="more"></a>

<h4 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/31/djPbAe.png"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）在相应的交换机上创建vlan10，并将连接PC1和PC2的交换端口都划分进该vlan中</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djiiNQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djiVcq.png"></p>
<p><strong>（2）为主机设置合适的IP地址，IP地址自定，完成必要的配置实现主机间的通信</strong></p>
<ul>
<li>为两台PC配置IP地址（注意关闭路由功能，因为实验中的PC使用的是路由器的镜像）</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djiUHO.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djiDCd.png"></p>
<ul>
<li>将交换机之间的端口封装802.1Q，并配置成trunk</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djFmRA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djFKMt.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djFYGj.png"></p>
<ul>
<li>测试PC的连通性</li>
</ul>
<blockquote>
<p>由于PC1和PC2属于同一vlan，所以通过上述配置即可相互ping通</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/31/djFxw8.png"></p>
<p><strong>（3）查看各交换机的STP信息</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djksnP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djk678.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djkgAS.png"></p>
<p><strong>（4）将SW1设置为vlan10的根桥，使用相关命令验证和查看各交换机上根桥的变化</strong></p>
<ul>
<li>设置SW1为vlan10的根桥</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djAmut.png"></p>
<ul>
<li>使用<span style="color:red">show spanning-tree</span>命令查看交换机状态</li>
</ul>
<blockquote>
<p>由于设置SW1为vlan10的根桥，由下图可知，优先级默认降低2*4096，即为24576，加上vlan-id的10，所以优先级为24586</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/31/djZVgJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djZQUK.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/31/djZGgH.png"></p>
<p><strong>（5）测试正常链路出现故障对主机通信的影响</strong></p>
<ul>
<li>将SW2的e0/1接口shutdown</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djZcKs.png"></p>
<ul>
<li>PC1仍然可以ping通PC2</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/31/djZ2bq.png"></p>
<p><strong>（6）先断开PC1与交换机的连接，然后恢复PC1与交换机的连接，观察主机重新接入交换机要经历多久才能够进行数据转发</strong></p>
<blockquote>
<p>由下图可知，PC1重新接入交换机需要经历30s（由于关闭的是SW2上的端口，可以直接进入listening状态（无需经历20s的blocking状态），再经历15s进入learning状态，最后经历15s进入forwarding状态）</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/31/djero6.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>交换</tag>
        <tag>STP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>单区域OSPF的实现</title>
    <url>/2020/08/29/%E5%8D%95%E5%8C%BA%E5%9F%9FOSPF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）掌握OSPF的基本配置<br>2）掌握OSPF的邻居表、拓扑表及路由表的含义<br>3）掌握OSPF的DR和BDR的作用<br>4）掌握OSPF的DR和BDR的选举<br>5）查看和调试OSPF路由协议的相关信息<br>6）熟悉OSPF中hello报文的作用和格式</p>
<a id="more"></a>
<h4 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/29/dHg68e.png" alt="拓扑图"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）完成各路由器的基本配置，实现各直连设备之间可以互ping对方，主机和路由器接口的地址自己规划</strong></p>
<ul>
<li>各接口地址如拓扑图标记所示进行配置</li>
</ul>
<p><strong>（2）全网启用OSPF，并划分如区域0</strong></p>
<blockquote>
<p>距离矢量为通告</p>
<p>链路状态为使能</p>
<p>network表示的是划分一个范围，路由器上属于此范围的对应接口加入OSPF的相应进程的相应区域</p>
<p>如network 192.168.12.0 0.0.0.255 area 0 表示的是划分一个范围为192.168.12.0，看此路由器上的哪个接口在这个范围内，则这个接口就会被加入OSPF的区域0中</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/29/dH2hQJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH2Tdx.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH2qJO.png"></p>
<p><strong>（3）观察各路由器的邻居表、拓扑表及路由表，观察哪些链路上有进行DR/BDR的选举，并测试主机之间的连通性</strong></p>
<blockquote>
<p>优先级用于选举DR/BDR——以太网链路存在DR/BDR的选举，串行链路则没有</p>
<p>选举规则：</p>
<ul>
<li><p>先比较优先级，优先级大的优先；默认情况下以太网接口的优先级都为1，串行链路的接口优先级都为0（优先级为0不能参与DR/BDR的选举）</p>
</li>
<li><p>如果优先级都一样，继续比较RID，RID大的优先</p>
</li>
<li><p>DR的选举是非抢占的</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>Hello报文</p>
<p>作用：用来发现、建立、维持邻居之间的关系</p>
<p>每隔10s往224.0.0.5发送Hello报文，如果在40之后没有收到来自邻居的Hello，则认为该邻居挂了，就切断和该邻居之间的关系（死亡时间通常在30-39之间）</p>
</blockquote>
<blockquote>
<p>-————————————————————————————————————————–</p>
<p>Neighbor ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pri &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State &nbsp;&nbsp;&nbsp;Dead Time &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface</p>
<p>&nbsp;&nbsp;&nbsp;邻居的ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级 &nbsp;&nbsp;状态 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;死亡时间 &nbsp;&nbsp;&nbsp;&nbsp;邻居的IP地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己用于建立邻居的接口</p>
<p>-————————————————————————————————————————–</p>
</blockquote>
<ul>
<li>邻居表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHWXqA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHWxat.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHWzIP.png"></p>
<ul>
<li>拓扑表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfVZn.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfeI0.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfuGT.png"></p>
<ul>
<li>路由表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfydI.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfgFP.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHffSS.png"></p>
<ul>
<li>连通性测试</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHhpwR.png"></p>
<p><strong>（4）指定R2的RID为20.20.20.20，R3的RID为30.30.30.30，使用相关命令观察和验证各路由器RID的变化</strong></p>
<blockquote>
<p>【RID的选举】</p>
<ul>
<li><p>手工指定：最优先</p>
<p>R2(config)#router ospf 1</p>
<p>R2(config-router)#router-id 20.20.20.20    –手动指定RID</p>
<p>Reload or use “clear ip ospf process” command, for this to take effect</p>
<p>R2#clear ip ospf process    –重置OSPF的进程 </p>
<p>Reset ALL OSPF processes? [no]: y</p>
</li>
<li><p>自动选择：在没有手工指定情况下，优先选择回环口中IP地址最大的；若没有回环口，选择物理接口（双UP）中IP地址最大。</p>
</li>
</ul>
</blockquote>
<ul>
<li>查看当前R2和R3的RID，由于没有手工指定，也没有存在回环口，则选择物理接口中IP地址最大的作为RID</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHhI1O.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHhTje.png"></p>
<ul>
<li>指定R2和R3路由器的RID</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4PBj.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4kEn.png"></p>
<ul>
<li>再次查看R2和R3的RID</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4ANq.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4E40.png"></p>
<p><strong>（5）实现R2为以太网链路网段上的DR</strong></p>
<ul>
<li>由于R1和R2的优先级默认都为1，并且R2的RID为20.20.20.20，而R1的RID为192.168.12.1，此时需要修改R2的e0/0接口的优先级，使之成为以太网链路上的DR。此处指定R2上e0/0接口的优先级为2即可</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dH4zI1.png"></p>
<ul>
<li>由于DR、BDR的选举为非抢占，此时应重置OSPF进程</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHIpwj.png"></p>
<ul>
<li>查看R1和R2的邻居表，可知此时R2成为以太网链路上的DR</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/29/dHIFf0.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHIApV.png"></p>
<p><strong>（6）分别在R2和R3的路由器上添加172.16.2.0/24和172.16.3.0/24的网段，添加必要配置实现这两个网络之间的连通性</strong></p>
<ul>
<li>由于R3上已存在172.16.3.0/24网段，此时在R2上添加一个回环口（地址为172.16.2.2/24）用作测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R2(config)#interface loopback 1</span><br><span class="line">R2(config-if)#ip address 172.16.2.2 255.255.255.0</span><br><span class="line">R2(config-if)#ip ospf 1 area 0  --把该接口加入到OSPF进程1区域0中</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/30/dHIqHJ.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dHIXNR.png"></p>
<p><strong>（7）开启debug信息，观察OSPF在以太网链路之间信息交互的过程</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dHIx9x.png"></p>
<p><strong>（8）开启debug信息，观察OSPF在串行链路之间信息交互的过程，比较以太网链路和串行链路上OSPF的debug信息输出的区别</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dHoPDe.png"></p>
<blockquote>
<p>最主要区别在于以太网链路会进行DR/BDR的选举；串行链路则没有进行DR/BDR的选举</p>
<p>以太网链路中，路由信息会先被发送到组播地址224.0.0.6，即被DR/BDR所接收，再由DR将此信息发送到组播地址224.0.0.5</p>
</blockquote>
<p><strong>（9）使用wireshark抓取OSPF的hello报文，理解hello报文各字段的含义</strong></p>
<blockquote>
<p>hello报文用于邻居的发现，建立和维持</p>
<p>hello报文中的相关信息包括：</p>
<ul>
<li>Network Mask：发送hello报文的接口所在网络的掩码</li>
<li>Hello Interval（默认为10s）：发送hello报文的时间间隔</li>
<li>Options：可选项<ul>
<li>E：允许Flood AS-External-LSAs</li>
<li>MC：转发IP组播报文</li>
<li>N/P：处理Type-7 LSAs</li>
<li>DC：处理按需链路</li>
</ul>
</li>
<li>Router Priority：优先级，默认为1，如果设置为0，则不参与DR或BDR的选举</li>
<li>Router Dead Interval（默认40s）：失效时间，如果在此时间内未收到邻居发送的hello报文，则认为邻居失效</li>
<li>Designated Router：DR的接口地址</li>
<li>Backup Designated Router：BDR的接口地址</li>
<li>Active Neighbor：活跃的邻居，以RID标识</li>
</ul>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/30/dHoE4I.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>路由协议</tag>
        <tag>OSPF</tag>
      </tags>
  </entry>
  <entry>
    <title>单臂路由运用</title>
    <url>/2020/08/30/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h4><p>1）掌握交换机上VLAN的创建和划分<br>2）掌握trunk的作用<br>3）掌握VTP的作用与配置<br>4）掌握单臂路由原理与配置<br>5）理解trunk链路上的802.1Q标记的作用</p>
<a id="more"></a>
<h4 id="2、拓扑结构"><a href="#2、拓扑结构" class="headerlink" title="2、拓扑结构"></a>2、拓扑结构</h4><p><img src="https://s1.ax1x.com/2020/08/30/dqOjXR.png"></p>
<h4 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h4><p><strong>（1）在SW1上创建两个vlan，vlan10和vlan20，并将vlan10命名为sales，将vlan20命名为engineers</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqXEjA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqXeBt.png"></p>
<p><strong>（2）完成必要的配置，实现两交换机的vlan数据库同步，并使用相关命令验证和查看vlan数据库的信息</strong></p>
<blockquote>
<p>要实现两交换机的vlan数据库同步，需要进行vtp的配置</p>
</blockquote>
<ul>
<li>将两交换机相连的端口设置为trunk</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqXJun.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqj8PO.png"></p>
<ul>
<li>指定vtp的域和密码，并指定SW1的vtp模式为server，SW2的vtp模式为client</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqjyRg.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqvFOA.png"></p>
<ul>
<li>在SW2上查看vlna信息，此前并未在SW2上创建vlan，由此可知两交换机之间实现了vlan数据库的同步</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqv6k6.png"></p>
<ul>
<li>尝试在SW2上创建一个vlan，日志提示在vtp的模式为client的条件下不允许创建vlan</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqvRpD.png"></p>
<ul>
<li>在SW1上查看vtp的状态信息，从下图可知SW1的vtp模式为server（默认），已存在的vlan数量为7，修订版本号为8</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqx9A0.png"></p>
<p><strong>（3）将连接PC1和PC3的交换端口划分进vlan10，将连接PC2的交换端口划分进vlan20中，并为各PC配置合适的IP地址和网关</strong></p>
<ul>
<li>依题意将交换机上的端口划分进对应的vlan</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxYDA.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxUEt.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxd4f.png"></p>
<ul>
<li>由于各PC为使用路由器镜像模拟，需在PC上关闭路由功能。按下图所示为各PC配置IP地址和网关</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxIv4.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxHbR.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqxLUx.png"></p>
<p><strong>（4）使用show vlan brief查看各交换机的vlan信息</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzFat.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzEPf.png"></p>
<p><strong>（5）测试各主机之间的连通性</strong></p>
<blockquote>
<p>PC1和PC3之间可以相互ping通（两PC属于同一vlan，无需经过三层设备）</p>
<p>PC1和PC2之间无法通信（两PC属于不同vlan，需要经过三层设备，此时还未在路由器上进行相应的配置）</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzlaq.png"></p>
<p><strong>（6）在交换机和路由器上完成必要的配置，实现各主机间可以互相通信</strong></p>
<ul>
<li>将SW1上连路由器的端口配置成trunk</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzTW8.png">、</p>
<ul>
<li><p>在R1上进行单臂路由的配置</p>
<blockquote>
<p>单臂路由是指在路由器的一个接口上通过配置子接口(或”逻辑接口”，并不真实存在)的方式，实现原来相互隔离的不同vlan之间的互联互通</p>
<p>值得注意的是这些逻辑子接口不能被单独的开启或关闭，即当物理接口被开启或关闭时，所有的该物理接口的子接口也将对应的被开启或关闭</p>
<p>由于单臂路由存在瓶颈和单点故障的问题，因此必须限制主机/vlan的数量。此时可以通过SVI实现不同vlan间的通信（后续会进行介绍）</p>
</blockquote>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzHSS.png"></p>
<ul>
<li>测试各主机之间的连通性，如下图所示，三台PC之间可以互相ping通</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzbQg.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqzLLj.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CCNA</tag>
        <tag>单臂路由</tag>
        <tag>vtp</tag>
      </tags>
  </entry>
  <entry>
    <title>在交换网络中部署EtherChannel技术</title>
    <url>/2020/09/05/%E5%9C%A8%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%83%A8%E7%BD%B2EtherChannel%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>　　在有些网络环境中，用户与资源之间的距离也许非常远，交换机与交换机之间或交换机与服务器之间的链路可能会变得非常阻塞。虽然通过线路改造可以增加这些链路的带宽，但并不是所有的链路都具备带宽升级的条件。因此，在以最大化节省现有投资为目的的前提下，EtherChannel技术应运而生。EtherChannel技术可以将多条物理链路捆绑成一条逻辑链路来解决流量拥塞的问题，在提升带宽的同时，也实现了冗余性。</p>
<a id="more"></a>

<h3 id="1、EtherChannel技术背景"><a href="#1、EtherChannel技术背景" class="headerlink" title="1、EtherChannel技术背景"></a>1、EtherChannel技术背景</h3><p>　　EtherChannel技术最初是由Cisco开发的一种LAN交换机之间的链路技术，用来将多个百兆或千兆以太网端口放入一个逻辑的通道中。EtherChannel拥有以下多种优势：</p>
<ul>
<li>利用已有交换机端口。无需升级交换机互联链路，从而节省投资成本。</li>
<li>大多数的配置都可以在EtherChannel接口下完成，而不需要分别在每个端口进行配置，这可以保证交换机之间端口配置的一致性。</li>
<li>EtherChannel技术支持多条链路的负载均衡。根据硬件平台的不同，可以在多条物理链路之间部署多种方式的负载均衡，如基于源MAC和目的MAC，或是基于源IP和目的IP。</li>
</ul>
<p>　　除了交换机，其他网络设备也广泛地支持EtherChannel技术。在任何情况下，EtherChannel创建的都是一对一的逻辑链路。EtherChannel链路可以部署在两台交换机之间，也可以部署在启用了EtherChannel服务的服务器和交换机之间，但是，同一条EtherChannel不能向两台不同的交换机发送流量。一条EtherChannel链路的两端始终只连接着两台设备，而且这两台设备上EtherChannel组成员的端口配置也必须相同。</p>
<p>　　EtherChannel创建的汇聚链路会被看做是一条逻辑链路。当两台交换机之间存在多条EtherChannel链路时，生成树可能会阻塞其中的一条来防止出现环路。当生成树阻断了某条冗余链路时，也就阻断了一条EtherChannel链路，这条EtherChannel链路中的所有端口也都会被阻塞。如果仅有一条EtherChannel链路，捆绑中所有物理端口都会处于Active状态。因为对于生成树算法来说，多条物理链路捆绑后的EtherChannel链路是一条逻辑链路。如果EtherChannel中的某条物理链路出现了故障，EtherChannel会自动更新其捆绑带宽，对应的STP开销也会重新计算。</p>
<blockquote>
<p>注：在三层交换机上，可以将设备的交换端口转化成路由端口。转换后的三层端口同样可以配置EtherChannel链路。在使用了例如VSS（虚拟交换系统）或vPC（虚拟端口通道）技术后，可以在一台接入层交换机和两台不同的汇聚层交换机之间创建EtherChannel链路。</p>
</blockquote>
<h3 id="2、EtherChannel协商协议"><a href="#2、EtherChannel协商协议" class="headerlink" title="2、EtherChannel协商协议"></a>2、EtherChannel协商协议</h3><p>　　可以使用以下三种机制之一来创建EtherChannel</p>
<blockquote>
<p>LACP： IEEE标准协商协议</p>
<p>PAgP： Cisco私有协商协议</p>
<p>静态配置： 无协商协议</p>
</blockquote>
<ul>
<li><strong>LACP</strong></li>
</ul>
<p>　　链路汇聚控制协议（LACP）是一种由IEEE定义的标准（802.3ad），允许将多个 物理端口捆绑到一起形成一个逻辑通道。LACP允许交换机发送LACP数据包来与对端自动协商捆绑通道。由于LACP属于IEEE制定的业界标准，因此可以在不同厂商设备的环境中协商EtherChannel链路。LACP会检查两台交换机的配置一致性以及链路状态，用来确保EtherChannel创建时，所有端口配置有相同的端口速率、双工模式、VLAN信息等。在通道建立之后，任一端口的配置修改都会影响通道另一端的端口状态。</p>
<p>　　LACP数据包会在启用了EtherChannel功能的端口上进行交换。接收方会将对端的端口属性与自身的端口属性进行比较。LACP会为EtherChannel端口分配角色。带有最低的系统优先级的交换机将决定哪些活动端口可以加入EtherChannel。端口根据其优先级选举出Active端口。<span style="color:red">数值越低表示越优先。</span>一般来说，一个EtherChannel最大支持16条链路。同一时间只能有8条处于Active（活动）状态。其余8条非Active端口将处于Standby（备用）状态。如果某条Active链路发生故障，Standby端口将接管成为Active端口。</p>
<blockquote>
<p>两台交换机之间建立EtherChannel的最大Active链路数量是可变的</p>
</blockquote>
<p>　　LACP操作模式如下</p>
<p>　　　　①Active：使端口进入主动协商状态，发送LACP数据包主动与其他接口进行协商</p>
<p>　　　　②Passive：使端口进入被动协商状态，对LACP数据包做出响应</p>
<p>　　　　③On：强制端口形成EtherChannel，不需要使用LACP或PAgP进行协商</p>
<ul>
<li><strong>PAgP</strong></li>
</ul>
<p>　　端口聚合协议（PAgP）提供了与LACP类似的协商优点。PAgP是Cisco私有协议，因此只能运行在Cisco设备上。PAgP数据包会在启用了EtherChannel功能的端口上进行交换，每30s发送过一次。接收方会将对端的端口属性与自身的端口属性进行比较，具有相同属性的端口将被捆绑进同一个EtherChannel中。PAgP只能在配置有相同VLAN或Trunk属性的端口上形成EtherChannel。如果捆绑中的端口修改了配置，那么PAgP也会重新协商EtherChannel的参数。例如，捆绑中的某个端口的速率、双工模式或VLAN信息做了配置修改，PAgP将会重新考虑捆绑中其他端口的参数。<span style="color:red">PAgP与LACP协议之间不能兼容。</span></p>
<p>　　PAgP操作模式如下：</p>
<p>　　　　①Desirable：使端口进入主动协商的状态，发送PAgP数据包</p>
<p>　　　　②Auto：使端口进入被动协商的状态，对PAgP数据包做出响应</p>
<p>　　　　③On：强制端口不使用PAgP而形成EtherChannel，不会交换PAgP数据包</p>
<h3 id="3、EtherChannel配置实例"><a href="#3、EtherChannel配置实例" class="headerlink" title="3、EtherChannel配置实例"></a>3、EtherChannel配置实例</h3><ul>
<li>LACP验证</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/06/wmAPhT.png"></p>
<p>①首先将交换机之间的端口配置成Trunk</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#int range e0/0-1</span><br><span class="line">SW1(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW1(config-if-range)#switchport mode trunk </span><br><span class="line">SW2(config)#int range e0/0-1</span><br><span class="line">SW2(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW2(config-if-range)#switchport mode trunk </span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/06/wmVMlD.png"></p>
<p>②在SW1上配置EtherChannel，创建端口组1，模式为Active</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">SW1(config)#int range e0/0-1</span><br><span class="line">SW1(config-if-range)#channel-group 1 mode active </span><br><span class="line">Creating a port-channel interface Port-channel <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>③在SW2上配置EtherChannel，创建端口组1，模式为Passive</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">SW2(config)#int range e0/0-1</span><br><span class="line">SW2(config-if-range)#channel-group 1 mode passive </span><br><span class="line">Creating a port-channel interface Port-channel <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置后，两个端口将被捆绑到channel-group 1中。由于使用了active关键字，因此将使用LACP协议进行协商。SW1配置了LACP的active模式，SW2配置了LACP的passive模式，因此EtherChannel可以协商成功。</p>
</blockquote>
<p>④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#int port-channel 1</span><br><span class="line">SW1(config-if)#switchport trunk encapsulation dot1q </span><br><span class="line">SW1(config-if)#switchport mode trunk </span><br><span class="line">SW2(config)#int port-channel 1</span><br><span class="line">SW2(config-if)#switchport trunk encapsulation dot1q </span><br><span class="line">SW2(config-if)#switchport mode trunk </span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/06/wmDsbQ.png"></p>
<p>⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息</p>
<blockquote>
<p>如下图所示，port-channel 1是一个正在使用的2层EtherChannel（SU标志）。协商协议使用的是LACP，捆绑成功的端口包括Ethernet 0/0和Ethernet 0/1（P标志）</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/06/wmsEk9.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/06/wmsg10.png"></p>
<p>⑥在SW1上查看Ethernet 0/0和port-channel 1的信息，可知带宽变为原来的两倍</p>
<p><img src="https://s1.ax1x.com/2020/09/06/wmyrDO.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/06/wmyYE4.png"></p>
<hr>

<ul>
<li>PAgP验证</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/06/wmyn4s.png"></p>
<p>①将交换机之间的端口配置成Trunk</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#int range e0/0-1</span><br><span class="line">SW1(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW1(config-if-range)#switchport mode trunk </span><br><span class="line">SW2(config)#int range e0/0-1</span><br><span class="line">SW2(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW2(config-if-range)#switchport mode trunk </span><br></pre></td></tr></table></figure>

<p>②在SW1上配置EtherChannel，创建端口组1，模式为Desirable</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">SW1(config)#int range e0/0-1</span><br><span class="line">SW1(config-if-range)#channel-group 1 mode desirable </span><br><span class="line">Creating a port-channel interface Port-channel <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>③在SW2上配置EtherChannel，创建端口组2，模式为auto</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">SW2(config)#int range e0/0-1</span><br><span class="line">SW2(config-if-range)#channel-group 2 mode auto </span><br><span class="line">Creating a port-channel interface Port-channel <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#int port-channel 1</span><br><span class="line">SW1(config-if)#switchport trunk encapsulation dot1q </span><br><span class="line">SW1(config-if)#switchport mode trunk </span><br><span class="line">SW2(config)#int port-channel 2</span><br><span class="line">SW2(config-if)#switchport trunk encapsulation dot1q </span><br><span class="line">SW2(config-if)#switchport mode trunk </span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/06/wmcKXV.png"></p>
<p>⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息</p>
<p><img src="https://s1.ax1x.com/2020/09/06/wmcwnK.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/06/wmcaX6.png"></p>
<p>⑥在SW2上查看Ethernet 0/0和port-channel 2的信息，可知带宽变为原来的两倍</p>
<p><img src="https://s1.ax1x.com/2020/09/06/wmcXuV.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/06/wmcjBT.png"></p>
<hr>

<ul>
<li>On验证</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/06/wmg8Df.png"></p>
<p>①将交换机之间的端口配置成Trunk</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#int range e0/0-1</span><br><span class="line">SW1(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW1(config-if-range)#switchport mode trunk </span><br><span class="line">SW2(config)#int range e0/0-1</span><br><span class="line">SW2(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW2(config-if-range)#switchport mode trunk </span><br></pre></td></tr></table></figure>

<p>②在SW1和SW2上配置EtherChannel，创建端口组1，模式为On</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">SW1(config)#int range e0/0-1</span><br><span class="line">SW1(config-if-range)#channel-group 1 mode on</span><br><span class="line">SW2(config)#int range e0/0-1</span><br><span class="line">SW2(config-if-range)#channel-group 1 mode on </span><br><span class="line">Creating a port-channel interface Port-channel <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>④在SW1和SW2上分别进入新建的port-channel的接口配置模式，将其配置成dot1Q的trunk模式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#int range e0/0-1</span><br><span class="line">SW1(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW1(config-if-range)#switchport mode trunk </span><br><span class="line">SW2(config)#int range e0/0-1</span><br><span class="line">SW2(config-if-range)#switchport trunk encapsulation dot1q </span><br><span class="line">SW2(config-if-range)#switchport mode trunk </span><br></pre></td></tr></table></figure>

<p>⑤在SW1和SW2上使用show etherchannel summary命令查看EtherChannel的摘要信息</p>
<p><img src="https://s1.ax1x.com/2020/09/06/wm2Ysx.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/06/wm2JQ1.png"></p>
<p>⑥在SW2上查看Ethernet 0/0和port-channel 2的信息，可知带宽变为原来的两倍</p>
<p><img src="https://s1.ax1x.com/2020/09/07/wm2WTS.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/07/wm2Rw8.png"></p>
<h3 id="4、EtherChannel负载均衡方式"><a href="#4、EtherChannel负载均衡方式" class="headerlink" title="4、EtherChannel负载均衡方式"></a>4、EtherChannel负载均衡方式</h3><p>　　EtherChannel中的流量可以分担到捆绑中的每条链路上。不过，流量并不是严格平均分布到每条链路上的。数据帧选择EtherChannel链路上哪条链路转发取决于哈希算法的结果，不同的设备平台使用的哈希计算算法也不尽相同。</p>
<p>　　在同一个EtherChannel的多个端口成员之间实现负载分担是配置EtherChannel的一个重要因素。管理员可以把负载分担选项当作一个规则，从而极大程度上丰富配置的多样性。举例来说，如果某条通道上的流量只去往单一的MAC地址，那么管理员既可以根据目的MAC地址进行配置，使其总是选择通道中的相同链路;也可以根据源地址进行配置，这样做可以实现更好的负载分担。</p>
<p>　　负载分担会在全局应用于交换机上的所有EtherChannel，可以使用命令<strong>port-channel load-balance</strong>来实现这项技术。负载分担可以基于以下变量实现：</p>
<ul>
<li>src-mac：源MAC地址</li>
<li>dst-mac：目的MAC地址</li>
<li>src-dst-mac：源和目的MAC地址</li>
<li>src-ip：源IP地址</li>
<li>dst-ip：目的IP地址</li>
<li>src-dst-ip：源和目的IP地址（默认）</li>
<li>src-port：源TCP/UDP（用户数据报协议）端口</li>
<li>dst-port：目的TCP/UDP端口</li>
<li>src-dst-port：源和目的TCP/UDP端口</li>
</ul>
<p>　　例如，源MAC地址转发是指当数据包被发送给EtherChannel，设备会根据入站数据包的源MAC地址来判断应该将数据包从通道的哪个端口转发出去。于是，来自不同主机的数据包就会从通道的不同端口中转发出去，而来自同一台主机的数据包会从通道的同一端口中转发出去，这就是实现了负载分担。</p>
<p>　　SW1和SW2之间使用LACP协商建立EtherChannel链路，如下图所示</p>
<p><img src="https://s1.ax1x.com/2020/09/09/wlxaVI.png"></p>
<ul>
<li>输入<span style="color:red">show etherchannel load-balance</span>命令来查看EtherChannel使用的负载均衡信息</li>
</ul>
<blockquote>
<p>此前并未在交换机上配置负载均衡，可见该交换机上默认的负载均衡方式为src-dst-ip，即基于源和目的IP地址进行负载分担</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/09/wlxnbR.png"></p>
<ul>
<li>为了测试上图所示的拓扑中每条链路上分布的流量，在SW1上输入<span style="color:red">clear counters</span>命令清空计数器，即可准确地测试出每条链路分布的流量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">SW1#clear counters </span><br><span class="line">Clear <span class="string">&quot;show interface&quot;</span> counters on all interfaces [confirm]</span><br></pre></td></tr></table></figure>

<ul>
<li>使用扩展ping命令，从PC1上 ping PC3</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/09/wlzMLj.png"></p>
<ul>
<li>在SW1上查看两个端口的计数器</li>
</ul>
<blockquote>
<p>可见大多数流量都分布在了E0/0接口上，通过E0/0端口承载</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/09/wlz5TI.png"></p>
<ul>
<li>将SW1的负载均衡方式修改为dst-ip</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#port-channel load-balance dst-ip</span><br></pre></td></tr></table></figure>

<ul>
<li>查看修改后的负载均衡方式</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/09/w1sPPO.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>交换</tag>
        <tag>EtherChannel</tag>
      </tags>
  </entry>
  <entry>
    <title>VTP协议</title>
    <url>/2020/09/03/VTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>　　VTP（VLAN Trunking Protocol）用来在整个交换网络中分发和同步VLAN数据库，可以将配置错误和配置不一致等问题导致障碍的几率降至最低。这些问题包括重复的VLAN名称、不正确的VLAN类型，以及安全性违规等。</p>
<a id="more"></a>

<h3 id="1、VTP概述"><a href="#1、VTP概述" class="headerlink" title="1、VTP概述"></a>1、VTP概述</h3><p>　　VTP是一种通过添加、删除、修改VLAN等管理操作，来维护网络内VLAN配置一致性的2层协议。</p>
<p>　　交换机只能通过802.1Q或ISL Trunk传输VTP消息。Cisco交换机会通过管理VLAN（默认为VLAN 1），使用2层组播数据帧每5分钟传输一次VTP汇总通告。在单台VTP服务器上的VLAN配置会通过Trunk链路宣告给网络中的所有互联交换机。例如，当管理者添加了一个新的VLAN，那么VTP会将VLAN信息宣告给VTP域内的所有交换机，每台交换机会同步VLAN信息，再将这些信息合并成新的VLAN数据库。</p>
<p>　　VTP域是由一台或多台共享相同VTP配置的互联的交换机组成的，每台交换机只能处于一个VTP域中。默认情况下，Cisco Catalyst交换机处于”no-management-domain”状态（null状态），直到通过Trunk链路收到了带有域名的VTP通告，或手动配置了VTP域名。配置应在VTP服务器上执行，随后会通过Trunk链路宣告给网络中的所有互联交换机。当VTP域名及VTP密码匹配之后，配置信息将会同步。</p>
<p>　　<span style="color:red">VTP是Cisco私有的协议。</span></p>
<h3 id="2、VTP模式"><a href="#2、VTP模式" class="headerlink" title="2、VTP模式"></a>2、VTP模式</h3><p>　　VTP可以工作在3种模式下：服务器（server）模式、客户端（client）模式、透明（transparent）模式。VTP服务器模式是默认的模式，不过在未配置或未学习到 VTP域名时，VLAN信息是不会宣告到网络中的。需要注意的是，VTP消息仅会在Trunk链路上传播。VTP客户端模式与服务器模式相似，在Trunk链路上发送和接收VTP更新。处于VTP客户端模式的交换机无法创建、删除或修改VLAN，其学习到的VLAN都是由域内的VTP服务器模式的交换机所创建的。处于VTP透明模式的交换机对VLAN进行操作时，配置仅会影响到本地交换机，VLAN的修改信息并不会宣告给VTP域中的其他交换机，但是在该模式下的交换机可以将收到的VTP宣告转发出去。三种模式总结如下所示：</p>
<ul>
<li>服务器模式<ul>
<li>可以创建、删除、修改VLAN</li>
<li>可以发送及转发VTP通告</li>
<li>同步VLAN的配置</li>
</ul>
</li>
<li>客户端模式<ul>
<li>不能创建、删除、修改VLAN</li>
<li>可以发送及转发VTP通告</li>
<li>同步VLAN的配置</li>
</ul>
</li>
<li>透明模式<ul>
<li>可以创建、删除、修改<span style="color:red">本地VLAN</span></li>
<li>可以转发VTP通告</li>
<li>不同步VLAN配置</li>
</ul>
</li>
</ul>
<h3 id="3、VTP版本"><a href="#3、VTP版本" class="headerlink" title="3、VTP版本"></a>3、VTP版本</h3><p>　　Ｃisco Catalyst交换机支持三种不同版本的VTP：版本1、版本2、版本3。不同版本的VTP之间无法通信，因此管理者必须确定使用哪个版本的VTP。此外，出于稳定性方面的考虑，Cisco建议只使用一种版本的VTP。</p>
<p>　　Ｃisco交换机上默认启用的VTP版本是版本1。相比于旧版本的VTP，新版本的VTP支持以下特性：</p>
<ul>
<li><strong>与版本无关的透明模式：</strong>在VTP版本1中，VTP透明模式的网络设备会检查VTP消息中的域名和版本信息，而且只有当域名和版本号相匹配时才会转发此消息。由于Cisco IOS软件中只支持一个VTP域，因此在VTP版本2中会直接转发VTP消息，而不会检查其版本号。</li>
<li><strong>一致性检查：</strong>在VTP版本2中，会对VLAN名称及VLAN编号进行VLAN一致性检查。不过，只有通过命令行界面（CLI）或简单网络管理协议（SNMP）输入的信息才会触发一致性检查，如果新信息是通过VTP消息或NVRAM中读取的，则不会执行一致性检查。如果接收到的VTP消息MD5比对正确，VTP版本2会直接接收此消息，而不会执行一致性检查。</li>
<li><strong>支持令牌环：</strong>VTP版本2支持令牌环交换和令牌环VLAN。</li>
<li><strong>支持未识别TLV（Type-Length-Value）：</strong>在VTP版本1中，未被识别的VTP消息会被直接丢弃，而VTP版本2会将未识别的消息转发出去并将其保存在NVRAM中。</li>
<li><strong>支持扩展VLAN：</strong>VTP版本3可支持VLAN1025<del>4094的消息通告（VLAN编号1006</del>1024以及4095~4096被保留）。</li>
<li><strong>域名不自动学习：</strong>在VTP版本2中，交换机会从接收的VTP信息中自动学习到新的VTP域名。由于这种行为比较危险，因此在VTP版本3中，此功能需要手动强制开启。</li>
<li><strong>更优的安全性：</strong>VTP域密码以一种安全的方式传输并存储在交换机数据库中。</li>
<li><strong>更优的数据库宣告机制：</strong>只有主用服务器允许更新其他设备，而且每个VTP域内一台主用服务器。</li>
<li><strong>支持多生成树（MST）：</strong>VTP版本3加入了对MST进程通告的支持。</li>
</ul>
<h3 id="4、VTP修剪"><a href="#4、VTP修剪" class="headerlink" title="4、VTP修剪"></a>4、VTP修剪</h3><p>　　VTP修剪（pruning）技术使用VLAN通告消息来判断Trunk连接何时正在泛洪不必要的流量。默认情况下，Trunk连接会承受VTP管理域中所有的VLAN流量，但一般情况下，企业网络中的多数交换机并没有为每个VLAN都配置本地端口。</p>
<p>　　VTP修剪技术可以将可泛洪的流量限制在合适的范围内，仅允许必要的VLAN流量通过Trunk链路，从而提高链路的可用带宽。如下图所示的交换网络启用了VTP的修剪功能，从Red VLAN中的主机或工作站发出的广播流量不会转发给交换机3、5和6，因为Red VLAN已经在交换机2、4的链路上被修剪掉了。</p>
<p><img src="https://s1.ax1x.com/2020/09/04/wAKLaq.png" alt="VTP修剪"></p>
<p>　　无论是否使用了VTP修剪功能，Catalyst交换机都会为每个VLAN运行一个STP实例，即使VLAN中没有活动端口，或VTP修剪已经将VLAN从接口上移除了出去。因此，VTP修剪能够防止将流量泛洪传播给没有特定VLAN成员的交换机。不过，VTP修剪不会将已被修剪的VLAN信息从交换机上删除。</p>
<h3 id="5、VTP认证"><a href="#5、VTP认证" class="headerlink" title="5、VTP认证"></a>5、VTP认证</h3><p>　　管理员可以使用VTP密码特性来增强VTP域的安全性。必须要保证VTP域内的所有交换机使用了相同的密码及域名；否则，交换机无法成为VTP域的成员。Cisco交换机使用MD5算法将密码编码成16字节的密码。这些密码会在VTP汇总通告中进行传播。在VTP中，密码是区分大小写的，长度为8~64个字符。建议在所有VTP域中使用VTP认证特性。</p>
<h3 id="6、VTP通告"><a href="#6、VTP通告" class="headerlink" title="6、VTP通告"></a>6、VTP通告</h3><p>　　VTP通告会在整个管理域中泛洪。交换机默认每隔5分钟发送过一次VTP通告，当VLAN的配置发生变化时会触发发送VTP通告。VTP通告使用组播帧在native VLAN（默认为VLAN 1）中以不打标签的方式传播。每个VTP通告中都包含了一个配置修订号。配置修订号越高，表示VLAN信息越新。配置修订号（configuration revision number）是VTP中非常重要的参数。每次VTP服务器在对VLAN进行操作（增加、删除、修改VLAN信息）时，都会将配置修订号加1。随后VTP服务器发送的VTP通告将带有新的配置修订号。如果VTP域内的其他交换机收到了带有更高配置修订号的VTP通告，将会使用新收到的VLAN信息更新自身的VLAN配置。由于VTP透明模式的交换机不会与域内的其他交换机同步VLAN的信息，所以其配置修订号或VLAN数据库将不会改变（始终为0）。</p>
<blockquote>
<p>注意：根据VTP的更新规则，如果一台删除了所有VLAN并带有更高的配置修订号的VTP服务器加入到VTP域中，那么域内所有设备上的VLAN都会被覆盖删除</p>
</blockquote>
<p>　　设备在接收到VTP通告后，需要对一些参数进行检查，之后才会合并其中的VLAN信息。首先就是管理域名和密码必须与本地交换机配置的一致。其次，如果配置修订号比当前交换机的高时，交换机才会合并这条VLAN通告信息。在许多Cisco Catalyst交换机上，可以通过修改VTP域名称的方式重置配置修订号；还可以将其模式修改成透明模式，再改回先前的服务器或客户端模式。这两种方法都可以让配置修订号归零。</p>
<h3 id="7、VTP消息类型"><a href="#7、VTP消息类型" class="headerlink" title="7、VTP消息类型"></a>7、VTP消息类型</h3><ul>
<li>汇总通告（Summary Advertisement）</li>
</ul>
<p>　　默认情况下，Catalyst交换机会每5分钟发送一次汇总通告消息。汇总通告消息会通知邻接Catalyst交换机当前的VTP域名及配置修订号。当交换机接收到汇总通告数据包时，会将数据包中的域名与本地配置的VTP域名相比较。如果名称不同，交换机就会忽略这个数据包。如果域名相同，交换机会继续比较配置修订号，如果自身的配置修订号高于或等于接收数据包的修订号，数据包也会被忽略。如果本地的配置修订号比收到的低，交换机则会发送一个请求通告消息。</p>
<ul>
<li>子集通告（Subnet Advertisement）</li>
</ul>
<p>　　当管理员在Catalyst交换机上添加、删除或修改VLAN时，配置修订号会相应地增加，并且会发送一条汇总通告消息。随后，还会发送一条或多条子集通告消息。每条自己通告包含一个VLAN信息列表。如果VLAN的数量很多，就会以多条子集通告的形式通告所有VLAN。</p>
<ul>
<li>请求通告（Request Advertisement）</li>
</ul>
<p>　　当交换机重启、VTP域名被修改或当交换机收到了一个配置修订号高于自身的VTP汇总通告时，交换机会发送VTP请求通告消息。在收到了一个请求通告后，VTP设备会发送一条汇总通告消息，随后再发送一条或多条子集通告消息。</p>
<h3 id="8、VTP配置实例"><a href="#8、VTP配置实例" class="headerlink" title="8、VTP配置实例"></a>8、VTP配置实例</h3><blockquote>
<p>VTP配置所使用的拓扑如下图所示，其中SW1配置成了VTP服务器模式；SW2配置成了VTP客户端模式；SW3配置成了透明模式</p>
</blockquote>
<blockquote>
<p>在进行VTP配置前，应注意将三台交换机之间的链路配置成Trunk链路，因为VTP消息仅会在Trunk链路上传播</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/04/wABjxJ.png"></p>
<ul>
<li>在所有交换机上配置VTP，SW1配置成服务器模式，SW2配置成客户端模式，SW3配置成透明模式</li>
</ul>
<blockquote>
<p>默认状态下的交换机运行的是VTP版本1</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW1(config)#vtp password cisco</span><br><span class="line">SW1(config)#vtp mode server</span><br><span class="line">SW1(config)#vtp domain shain</span><br><span class="line">SW1(config)#vtp version 1</span><br><span class="line"></span><br><span class="line">SW2(config)#vtp password cisco</span><br><span class="line">SW2(config)#vtp mode client </span><br><span class="line">SW2(config)#vtp domain shain</span><br><span class="line">SW2(config)#vtp version 1</span><br><span class="line"></span><br><span class="line">SW3(config)#vtp password cisco</span><br><span class="line">SW3(config)#vtp mode transparent </span><br><span class="line">SW3(config)#vtp domain shain</span><br><span class="line">SW3(config)#vtp version 1</span><br></pre></td></tr></table></figure>

<ul>
<li>在SW2上输入命令<span style="color:red">show vtp status</span>查看本交换机的VTP状态信息</li>
</ul>
<blockquote>
<p>能看到SW2配置成了VTP客户端模式（client），处于VTP域shain内</p>
</blockquote>
<blockquote>
<p>当前交换机上只有5个默认的VLAN：VLAN1和VLAN1002~1005。VTP配置修订号为0。此值为0以为着这台交换机的VLAN数据库未做任何修改。每次对VLAN进行操作（增加、删除、修改），配置修订号都会加1。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/04/wADxfS.png"></p>
<ul>
<li>在SW1上输入命令show vtp status</li>
</ul>
<blockquote>
<p>可以看到SW1配置成了VTP服务器模式（server）</p>
</blockquote>
<blockquote>
<p>与SW2一样，当前设备上只有默认VLAN。VTP配置修订号为0，VTP域名为shain。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wAroNV.png"></p>
<ul>
<li>在SW3输入命令show vtp status</li>
</ul>
<blockquote>
<p>SW3配置成了VTP透明模式（transparent）</p>
</blockquote>
<blockquote>
<p>和SW1、SW2一样，当前设备上只有默认VLAN。VTP配置修订号为0，VTP域名为shain</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wAsQgg.png"></p>
<ul>
<li>在SW1上创建VLAN 10</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SW1(config)<span class="meta">#vlan 10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在VTP客户端模式下是无法添加VLAN的。若在SW2上尝试添加VLAN 5，SW2则会提示如下信息：</p>
<p>SW2(config)#vlan 5<br>VTP VLAN configuration not allowed when device is in CLIENT mode.</p>
</blockquote>
<ul>
<li>在SW1上检查VLAN数据库及VTP状态</li>
</ul>
<blockquote>
<p>使用命令show vlan和命令show vtp status</p>
<p>VLAN 10此时已经出现在了SW1的数据库中</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wA6rA1.png"></p>
<blockquote>
<p>SW1上的配置修订号也增加到了1</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wA617n.png"></p>
<ul>
<li>检查SW2上的VLAN数据库和VTP状态</li>
</ul>
<blockquote>
<p>使用命令show vlan和命令show vtp status</p>
<p>由于SW2为VTP客户端模式，因此从SW1学习到了VLAN 10</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wA6wnJ.png"></p>
<blockquote>
<p>SW2当前的配置修订号与SW1相同，代表两台交换机拥有相同的VLAN数据库</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wA62cD.png"></p>
<ul>
<li>检查SW3上的VLAN数据库和VTP状态</li>
</ul>
<blockquote>
<p>使用命令show vlan和命令show vtp status</p>
<p>由于SW3处于VTP透明模式，因此永远不会和其他处于任何VTP模式的交换机同步自身的VLAN数据库</p>
<p>从某种程度上讲，启用VTP透明模式就等同于关闭了VTP功能</p>
</blockquote>
<blockquote>
<p>注意此时SW3上并没有VLAN 10</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wAcAu4.png"></p>
<blockquote>
<p>VTP透明模式的交换机配置修订号始终为0</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wAcM8K.png"></p>
<ul>
<li>在SW3上创建VLAN 20</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SW3(config)#vlan 20</span><br></pre></td></tr></table></figure>

<ul>
<li>在三台交换机上检查VLAN 20是否存在</li>
</ul>
<blockquote>
<p>从以下显示结果中可以看出VTP透明模式的交换机可以创建、删除本地VLAN，但是不会将本地VLAN的信息通告给其他交换机</p>
<p>VLAN 20仅存在与SW3上</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wAcYVA.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/05/wAcN5t.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/05/wActUI.png"></p>
<h3 id="9、VTP配置覆盖（VTP常见问题）"><a href="#9、VTP配置覆盖（VTP常见问题）" class="headerlink" title="9、VTP配置覆盖（VTP常见问题）"></a>9、VTP配置覆盖（VTP常见问题）</h3><p>　　VTP的一个常见问题就是由于管理员的粗心大意，错误地将整个网络中的VLAN数据库配置删除。因此，当向网络中添加一台交换机时，一定不能将错误的信息注入到现网中。如下图所示，SW1是一台VTP服务器，SW2和SW3是VTP客户端。所有交换机同步后的配置修订号均为12，并带有VLAN 10、20、30和40。每台交换机上有多个用户连接到不同的VLAN。</p>
<p><img src="https://s1.ax1x.com/2020/09/05/wAg5fP.png"></p>
<ul>
<li>查看SW1上的VTP状态和VLAN数据库信息</li>
</ul>
<blockquote>
<p>SW2和SW3有着与SW1同样的配置修订号及VLAN信息，这是因为VTP已经完全同步</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wEfxTe.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/05/wEhkOf.png"></p>
<ul>
<li>现在假定SW2发生了故障，从配线间取出了另外一台交换机来替代SW2</li>
</ul>
<blockquote>
<p>backup交换机配置了与其他两台交换机相同的VTP域名，VTP的配置修订号为29，比现网中的VTP修订号要高</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wE46K0.png"></p>
<blockquote>
<p>backup交换机的VLAN信息和VTP信息如下图所示</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wEIl6I.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/05/wEIsBV.png"></p>
<blockquote>
<p>默认情况下，Cisco IOS VTP服务器和客户端会将VLAN信息保存在flash下的vlan.dat文件中，其中包括了VLAN表以及配置修订号。删除vlan.dat文件并重启交换机可以将VTP和VLAN信息彻底删除，其删除方式根据具体交换机型号而定。</p>
<p>处于VTP透明模式的交换机可以使用show running-config命令查看VLAN和VTP配置，这是由于配置是存放在配置文本文件中的，而不是vlan.dat。因此在VTP透明模式的交换机上执行erase startup-config命令的话，所有的VLAN信息都会被删除。</p>
</blockquote>
<ul>
<li>由于backup交换机带有更高的配置修订号，因此SW1和SW3都会与其同步。分别在SW1和SW3上查看VLAN和VTP状态</li>
</ul>
<blockquote>
<p>VLAN20、30、40将从SW1和SW3上删除，连接到这些VLAN的终端用户也会失去其连通性</p>
</blockquote>
<blockquote>
<p>查看SW1的VLAN信息和VTP状态</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wEbL6J.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/05/wEqtA0.png"></p>
<blockquote>
<p>查看SW3上的VLAN信息和VTP状态</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/05/wELA8U.png"></p>
<p><img src="https://s1.ax1x.com/2020/09/05/wELkCT.png"></p>
<blockquote>
<p>因此，当一台带有更高配置修订号的交换机加入到VTP域中时，很有可能会导致重大的网络故障。当VTP客户端交换机加入到网络时，会发送一个自身数据库的汇总通告。也就是说，带有更高配置修订号的交换机，无论是服务器模式还是客户端模式，都会导致现网交换机的VTP配置覆盖（VLAN重新学习）。</p>
</blockquote>
<h3 id="10、VTP部署的推荐做法"><a href="#10、VTP部署的推荐做法" class="headerlink" title="10、VTP部署的推荐做法"></a>10、VTP部署的推荐做法</h3><p>　　VTP一般使用在新建网络中，用来减轻VLAN的配置工作。不过，随着网络规模数日渐增大，伴随而来的也有一些风险。如果VTP域内的某台VTP服务器意外地删除了一个VLAN，那么VTP域所在网络都会删除这个VLAN。已经预先配置过VLAN的交换机加入到了网络中，那么VTP域所在网络中的所有交换机的VLAN数据库都可能被覆盖。因此，部署VTP时建议先将所有交换机配置成VTP透明模式，并手动按需添加VLAN，尤其是在大型园区网环境中。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>交换</tag>
        <tag>VTP</tag>
      </tags>
  </entry>
</search>
